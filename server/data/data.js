/**
 * Created by Administrator on 2018/4/4.
 */

module.exports = {
    '/getHomeViewList':[{"id":1,"name":"Node 调试工具入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>JavaScript 程序越来越复杂，调试工具的重要性日益凸显。客户端脚本有浏览器，Node 脚本怎么调试呢？</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec2b77d560a7fa934a82bcb95433251c989d5aef\" alt=\"\" title=\"\"></p>\n\n<p>2016年，Node 决定将 Chrome 浏览器的&quot;开发者工具&quot;作为官方的调试工具，使得 Node 脚本也可以使用图形界面调试，这大大方便了开发者。</p>\n\n<p>本文介绍如何使用 Node 脚本的调试工具。</p>\n\n<h2>一、示例程序</h2>\n\n<p>为了方便讲解，下面是一个示例脚本。首先，新建一个工作目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir debug-demo\n$ cd debug-demo\n</code></pre></blockquote>\n\n<p>然后，生成<code>package.json</code>文件，并安装 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">Koa</a> 框架和 koa-route 模块。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ npm init -y\n$ npm install --save koa koa-route\n</code></pre></blockquote>\n\n<p>接着，新建一个脚本<code>app.js</code>，并写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// app.js\nconst Koa = require(&apos;koa&apos;);\nconst router = require(&apos;koa-route&apos;);\n\nconst app = new Koa();\n\nconst main = ctx =&gt; {\n  ctx.response.body = &apos;Hello World&apos;;\n};\n\nconst welcome = (ctx, name) =&gt; {\n  ctx.response.body = &apos;Hello &apos; + name;\n};\n\napp.use(router.get(&apos;/&apos;, main));\napp.use(router.get(&apos;/:name&apos;, welcome));\n\napp.listen(3000);\nconsole.log(&apos;listening on port 3000&apos;);\n</code></pre></blockquote>\n\n<p>上面代码是一个简单的 Web 应用，指定了两个路由，访问后会显示一行欢迎信息。如果想了解代码的详细含义，可以参考 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">Koa 教程</a>。</p>\n\n<h2>二、启动开发者工具</h2>\n\n<p>现在，运行上面的脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect app.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect</code>参数是启动调试模式必需的。这时，打开浏览器访问<code>http://127.0.0.1:3000</code>，就可以看到 Hello World 了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031902.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0f7a5869f754fed79c42e1096b7b743b44f496b2\" alt=\"\" title=\"\"></p>\n\n<p>接下来，就要开始调试了。一共有两种打开调试工具的方法，第一种是在 Chrome 浏览器的地址栏，键入 <code>chrome://inspect</code>或者<code>about:inspect</code>，回车后就可以看到下面的界面。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031903.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D992dcac9c22a8adbfaeb168e224236ca4bac471d\" alt=\"\" title=\"\"></p>\n\n<p>在 Target 部分，点击 inspect 链接，就能进入调试工具了。</p>\n\n<p>第二种进入调试工具的方法，是在 http://127.0.0.1:3000 的窗口打开&quot;开发者工具&quot;，顶部左上角有一个 Node 的绿色标志，点击就可以进入。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031904.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D16cb3df6b7f535a5685a46f90fc99cbf3d3fa42e\" alt=\"\" title=\"\"></p>\n\n<h2>三、调试工具窗口</h2>\n\n<p>调试工具其实就是&quot;开发者工具&quot;的定制版，省去了那些对服务器脚本没用的部分。</p>\n\n<p>它主要有四个面板。</p>\n\n<blockquote>\n  <ul>\n<li>Console：控制台</li>\n<li>Memory：内存</li>\n<li>Profiler：性能</li>\n<li>Sources：源码</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031905.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D38b8828893983c02e08f13980c7dbe0a25c03e4a\" alt=\"\" title=\"\"></p>\n\n<p>这些面板的用法，基本上跟浏览器环境差不多，这里只介绍 Sources （源码）面板。</p>\n\n<h2>四、设置断点</h2>\n\n<p>进入 Sources 面板，找到正在运行的脚本<code>app.js</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031906.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D40e8b76d4f31b0cd4e747af4476603e093a43f32\" alt=\"\" title=\"\"></p>\n\n<p>在第11行（也就是下面这一行）的行号上点一下，就设置了一个断点。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nctx.response.body = &apos;Hello &apos; + name;\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031907.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8f3da848b36efaaa3971de6db9ec575d1cee8740\" alt=\"\" title=\"\"></p>\n\n<p>这时，浏览器访问 http://127.0.0.1:3000/alice ，页面会显示正在等待服务器返回。切换到调试工具，可以看到 Node 主线程处于暂停（paused）阶段。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031908.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc0c3235e83a3b74b5bbe565aa0e3e334ea52c150\" alt=\"\" title=\"\"></p>\n\n<p>进入 Console 面板，输入 name，会返回 alice。这表明我们正处在断点处的上下文（context）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031909.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da3ad58d41a9079a3d038577c53188148dcb4be77\" alt=\"\" title=\"\"></p>\n\n<p>再切回 Sources 面板，右侧可以看到 Watch、Call Stack、Scope、Breakpoints 等折叠项。打开 Scope 折叠项，可以看到 Local 作用域和 Global 作用域里面的所有变量。</p>\n\n<p>Local 作用域里面，变量<code>name</code>的值是<code>alice</code>，双击进入编辑状态，把它改成<code>bob</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031910.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4f31b96a584a0a1d0f77bd474f24adf2b9444dfa\" alt=\"\" title=\"\"></p>\n\n<p>然后，点击顶部工具栏的继续运行按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031911.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da87d5772442cffce7fb042dd63cf309daebdcd05\" alt=\"\" title=\"\"></p>\n\n<p>页面上就可以看到 Hello bob 了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031912.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D82c8d21bfcf9e0433dcbdd8b806c38f7d9276d34\" alt=\"\" title=\"\"></p>\n\n<p>命令行下，按下 ctrl + c，终止运行<code>app.js</code>。</p>\n\n<h2>五、调试非服务脚本</h2>\n\n<p>Web 服务脚本会一直在后台运行，但是大部分脚本只是处理某个任务，运行完就会终止。这时，你可能根本没有时间打开调试工具。等你打开了，脚本早就结束运行了。这时怎么调试呢？</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect=9229 -e &quot;setTimeout(function() { console.log(&apos;yes&apos;); }, 30000)&quot;\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect=9229</code>指定调试端口为 9229，这是调试工具默认的通信端口。<code>-e</code>参数指定一个字符串，作为代码运行。</p>\n\n<p>访问<code>chrome://inspect</code>，就可以进入调试工具，调试这段代码了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031913.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfc40b600a1945a361ca5e44607b48d2ce9e6944a\" alt=\"\" title=\"\"></p>\n\n<p>代码放在<code>setTimeout</code>里面，总是不太方便。那些运行时间较短的脚本，可能根本来不及打开调试工具。这时就要使用下面的方法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect-brk=9229 app.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect-brk</code>指定在第一行就设置断点。也就是说，一开始运行，就是暂停的状态。</p>\n\n<h2>六、忘了写 --inspect 怎么办？</h2>\n\n<p>打开调试工具的前提是，启动 Node 脚本时就加上<code>--inspect</code>参数。如果忘了这个参数，还能不能调试呢？</p>\n\n<p>回答是可以的。首先，正常启动脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node app.js\n</code></pre></blockquote>\n\n<p>然后，在另一个命令行窗口，查找上面脚本的进程号。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ ps ax | grep app.js \n\n30464 pts/11   Sl+    0:00 node app.js\n30541 pts/12   S+     0:00 grep app.js\n</code></pre></blockquote>\n\n<p>上面命令中，<code>app.js</code>的进程号是<code>30464</code>。</p>\n\n<p>接着，运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node -e &apos;process._debugProcess(30464)&apos;\n</code></pre></blockquote>\n\n<p>上面命令会建立进程 30464 与调试工具的连接，然后就可以打开调试工具了。</p>\n\n<p>还有一种方法，就是向脚本进程发送 <a href=\"https://stackoverflow.com/questions/13052548/node-js-how-to-attach-to-a-running-process-and-to-debug-the-server-with-a-conso\">SIGUSR1</a> 信号，也可以建立调试连接。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ kill -SIGUSR1 30464\n</code></pre></blockquote>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4\">Debugging Node.js with Google Chrome</a>, by Jacopo Daeli</li>\n<li><a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\">Debugging Node.js with Chrome DevTools</a>, by Paul Irish</li>\n<li><a href=\"https://remysharp.com/2018/03/03/last-minute-node-debugging\">Last minute node debugging</a>, by Remy Sharp</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec2b77d560a7fa934a82bcb95433251c989d5aef","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/node-debugger.html","sourceType":"blog","time":"2018-03-20 08:11:35"},{"id":2,"name":"日本70岁退休谈起","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>1、</p>\n\n<p>2018年初，日本政府<a href=\"https://www.qdaily.com/articles/50475.html\">修改法律</a>，推迟公务员的退休年龄。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>现在，日本的公务员是60岁～63岁退休。新法律生效后，退休年龄立刻推迟到65岁，然后逐步推迟到70岁。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd6988d1648c21c3199c38b43b17cdea5e89e1045\" alt=\"\" title=\"\"></p>\n\n<p>更厉害的是，日本政府同时宣布，养老金制度也要改革。现在是65岁领取养老金，将来只有到了70岁才能领。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030802.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D033a894aa81cac356403331c5a1b8e2ccab96a55\" alt=\"\" title=\"\"></p>\n\n<p>如果我是一个刚刚毕业的日本大学生，听到这种消息，恐怕腿都要软了。日本那种毕恭毕敬、论资排辈的社会里面，上班简直像受罪一样。你必须每天小心翼翼地勤勉工作，日复一日地加班，所有前辈都下班了，你才能下班。这种生活要一直过到七十岁，怎不令人害怕？</p>\n\n<p>等到你走也走不动了，吃也吃不下了，才能领养老金，那么养老金又有多大意义呢，能够保障什么质量的生活呢？毕竟七十岁以前，都要靠自己啊。</p>\n\n<p>2、</p>\n\n<p>日本政府推迟退休，实在是迫不得已，因为日本的人口老龄化太严重了。</p>\n\n<p>日本是全世界人均寿命最高的国家之一，男81.7岁，女88.5岁。同时，日本也是全世界出生率最低的国家之一。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030804.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db5026b30c86604653251a9a03fb161231788124c\" alt=\"\" title=\"\"></p>\n\n<p>结果就是人口不断萎缩，国民的平均年龄越来越大。2015年，日本人的平均年龄已经到了46.5岁，是全世界平均年龄最大的国家，而且这个数字以后还会变大。据估计，四十年后，日本人口会减少三分之一。</p>\n\n<p>日本对输入外国劳动力和外国移民控制极严，导致劳动力越来越少。日本政府发现，一方面，交税的人口不断减少；另一方面，领取养老金的人口不断增多，而且领的时间越来越长。于是别无选择，只能让老年人多上几年班，晚几年领养老金。</p>\n\n<p>3、</p>\n\n<p>几乎所有发达国家都存在同样的问题：养老金存在缺口，无法满足越来越多的老年人口。日本只是问题最严重而已。</p>\n\n<p>有些地区还不那么发达，也出现养老金问题，比如台湾地区。台湾的生育率也是世界最低之一，养老金早就不够用了，破产在即，不得不立刻改革，减少养老金发放规模，每个人的缴款增加，但是未来领取的金额却要减少。台湾年轻人的薪水并不高，台北房价却直逼香港东京，现在养老金又要减少，年轻人的郁闷和绝望可想而知。一个台湾网友给出了三条对策。</p>\n\n<blockquote>\n  <ul>\n<li>上策：要求改变制度设计，每一代人自己养自己，让有钱的老人补贴没钱的老人，不要拿下一代的钱发给上一代人。</li>\n<li>中策：移民，彻底脱离这个制度。自己出不去，也要让下一代出去。</li>\n<li>下策：如果走不了，就不要生育，并且拼命地挣钱和存钱。同时，支持安乐死合法化，因为未来很可能，你的钱都用光了，人却还没死。</li>\n</ul>\n</blockquote>\n\n<p>4、</p>\n\n<p>请设想这样一种情景。未来很可能过了65岁，你的头发白了、眼睛花了、牙齿松了，还不得不朝九晚五地上班，为别人打工。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030803.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df39c32ae18eb0396a025d9ba0fef256d54c8bda3\" alt=\"\" title=\"\"></p>\n\n<p>就算你能健康活过七十岁领到养老金，那些钱也很可能由于通货膨胀，以及僧多粥少，而变得非常微薄。</p>\n\n<p>这种前景只要想一想，就会觉得不寒而栗。大多数人之所以工作，不是因为热爱工作，而是因为这样可以挣到钱，可以有保障，得到安稳的退休生活。但是这一切看上去很难实现了，如今你必须忍受着疲惫，工作更多年，到头来发现，你的养老并没有保障。</p>\n\n<p>难怪日本和台湾的很多年轻人，看不到前景，对未来不抱希望。日本和台湾都有很高的<a href=\"https://www.zhihu.com/question/19840174\">自杀率</a>，我想这绝不是偶然的。</p>\n\n<p>5、</p>\n\n<p>作为个人，要摆脱这种老无所依的命运，马上能想到的解决办法就是要多多挣钱。你不得不拼命工作，挣更多的钱。但是，这条路上已经挤满了人，很可能你为雇主投入了100%的心力，年复一年，到老还是在为生存挣扎。另一方面，很多人上班其实并不开心，想想看，如果要一直苦闷地熬到60多岁，人生一定没有什么幸福感。</p>\n\n<p>我有时会有另外一种想法：反正已经是这种处境了，为什么不索性换一种活法呢？如果不喜欢这个工作，你是否还要继续下去，熬到退休拿养老金？如果养老金是苦苦支撑到七十岁才能拿到，那能不能就当它不存在，趁早去干一些自己想干的事情？至少也要找一些自己喜欢、做起来开心的工作吧。</p>\n\n<p>甚至可不可以再进一步，与其等待别人决定，你应该在什么时候退休。我也可以做一回命运的主人，哪天觉得没意思了，拍拍衣服说，从现在开始我退休了，过另外一种生活。以前还有养老金可以期待，现在这种期待即使存在，也肯定小多了。</p>\n\n<p>提前退休并不意味着，从此你什么也不干了，而是让你有机会，转身尝试另一种生活，在一个自己有热情的领域创造出更大的价值。一旦你体验过，按照自己的想法生活，自由安排时间，你就完全回不去了，再也无法忍受那种大公司小隔间的呆板压抑的生活了。</p>\n\n<p>6、</p>\n\n<p>你可能会说，我的这种想法是水中月，镜中花，一厢情愿而已。没工作了就没钱，没钱怎么活？确实，提前退休就没收入了，但这注定我一定要为别人打工到退休吗？</p>\n\n<p>事实上，美国早有人研究过这个问题：一个普通的工薪族，怎么样才能在40岁退休？结论居然是，只要你不是那么穷，有一定的积蓄，普通人也可以40岁退休。</p>\n\n<p>这里有一个计算公式，如果你的所有钱都投资在证券上面，只要你一年的支出小于投资组合原始金额的4%，那么你就可以退休了。这被称为<a href=\"https://www.bloomberg.com/features/2016-early-retirement/\">&quot;百分之四&quot;规则</a>（Four Percent Rule）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030805.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8348c9d06d0930aa8d40dc192c34e826c21a2303\" alt=\"\" title=\"\"></p>\n\n<p>它的依据是1926年至1976年的美国证券投资回报率，有人发现即使这段时间熊市居多，如果你每年取出原始投资金额的4%，一直要到33年以后才会把钱取光。要是碰到大牛市，就可以撑更久。</p>\n\n<p>如果这条规则正确，那么可以推算，如果你每年的总支出为4万人民币，而你现在的证券投资有100万，那么你就可以退休了。如果每年支出40万，那么证券投资需要1000万。这些钱能够支撑30多年，中国人的平均寿命现在也就是70多岁。事实上，有一项研究专门验证这项规则，结果发现它（在美国）成立的概率是94%。</p>\n\n<p>7、</p>\n\n<p>当然，我不是说，你真的用这个规则，来安排自己的退休规划。尽管随着年龄变老，人的支出一般会越来越少，但是万一有突发事件（比如生了大病），恐怕马上就会耗尽存款。（不过，即使你没有退休，突发事件也有可能耗尽你的存款，你的生活保障并不会因为有没有正在上班，而有实质的不同。）</p>\n\n<p>我举这条规则的用意是，我想用它证明，只要管控好支出，提前退休在财务上是完全可行的。如果你很早就开始提前规划，可能性就会大大增加，如果你对自己的消费有严格的纪律，就完全有可能做到。</p>\n\n<p>普通人的生存正在变得越来越难，养老金和退休这样的字眼，正在离你越来越远，全世界皆是如此。你必须为自己早做打算，而在我看来，如果规划得当，你的人生至少可以不是那么悲惨，要熬到七十岁油干灯尽才能退休。</p>\n\n<p>（说明：本文收录在即将出版的<a href=\"http://www.ruanyifeng.com/survivor/\">《未来世界的幸存者》</a>一书之中。）</p>\n\n<p>（正文完）</p>\n\n<p>=========================================</p>\n\n<p>你最近有没有换工作的打算？下面向大家介绍一个国内著名的 IT 行业招聘网站：<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a>。</p>\n\n<p>优秀的人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力，从海量机会中找到最适合的那个。<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 让您可以向数百家互联网企业，匿名展示简历和职业期望，省下查找职位和投递简历的时间。通过这种方式，对您感兴趣的企业，主动邀请您参加面试。</p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030806.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D01fcbcfdcf5889695623b23f2cd43b6c8cbd35da\" alt=\"\" title=\"\"></a></p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 的用户之中，既有厌倦了大公司螺丝钉般的重复工作，转而进入创业公司的前 BAT 员工；也有在小公司工作多年，一心想进入大公司的互联网人；还有向往国外的工作与生活，成功肉身翻墙新加坡的工程师。</p>\n\n<p>准备好用不一样的方式迎接更好的职业机会了吗？现在就<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">提交申请</a>吧！</p>\n\n<p>关注 100offer 的公众号，了解更多资讯。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030808.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1600ed69252681ee5b8828e6e69c3359562899f1\" alt=\"\" title=\"\"></p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd6988d1648c21c3199c38b43b17cdea5e89e1045","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/retire-at-70.html","sourceType":"blog","time":"2018-03-08 08:15:38"},{"id":3,"name":"HTTP/2 服务器推送（Server Push）教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p><a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\">HTTP/2 协议</a>的主要目的是提高网页性能。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>头信息（header）原来是直接传输文本，现在是压缩后传输。原来是同一个 TCP 连接里面，上一个回应（response）发送完了，服务器才能发送下一个，现在可以多个回应一起发送。</p>\n\n<p>服务器推送（server push）是 HTTP/2 协议里面，唯一一个需要开发者自己配置的功能。其他功能都是服务器和浏览器自动实现，不需要开发者关心。</p>\n\n<p>本文详细介绍服务器推送的原理和配置方法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030501.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df660e66421f2fd66eb54d82af29698b04b4b8835\" alt=\"\" title=\"\"></p>\n\n<h2>一、传统的网页请求方式</h2>\n\n<p>下面是一个非常简单的 HTML 网页文件<code>index.html</code>。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;hello world&lt;/h1&gt;\n  &lt;img src=&quot;example.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></blockquote>\n\n<p>这个网页包含一张样式表<code>style.css</code>和一个图片文件<code>example.png</code>。为了渲染这个网页，浏览器会发出三个请求。第一个请求是<code>index.html</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nGET /index.html HTTP/1.1\n</code></pre></blockquote>\n\n<p>服务器收到这个请求，就把<code>index.html</code>发送给浏览器。浏览器发现里面包含了样式表和图片，于是再发出两个请求。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nGET /style.css HTTP/1.1\n</code></pre></blockquote>\n\n<blockquote><pre><code class=\"language-bash\">\nGET /example.png HTTP/1.1\n</code></pre></blockquote>\n\n<p>这就是传统的网页请求方式。它有两个问题，一是至少需要两轮 HTTP 通信，二是收到样式文件之前，网页都会显示一片空白，这个阶段一旦超过2秒，用户体验就会非常不好。</p>\n\n<h2>二、传统方式的改进</h2>\n\n<p>一种解决办法就是把外部资源合并在网页文件里面，减少 HTTP 请求。比如，把样式表的内容写在<code>&lt;style&gt;</code>标签之中，把图片改成 Base64 编码的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\">Data URL</a>。</p>\n\n<p>另一种方法就是资源的<a href=\"https://w3c.github.io/preload/\">预加载</a>（preload）。网页预先告诉浏览器，立即下载某些资源。比如，上例可以写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;link rel=&quot;preload&quot; href=&quot;/styles.css&quot; as=&quot;style&quot;&gt;\n&lt;link rel=&quot;preload&quot; href=&quot;/example.png&quot; as=&quot;image&quot;&gt;\n</code></pre></blockquote>\n\n<p>对于上例来说，<code>preload</code>命令并没有什么帮助。但是，如果前一个网页就使用这个命令，预加载后一个网页需要的资源，那么用户打开后一个网页时，就会感觉速度飞快。</p>\n\n<p>这两种方法都有缺点。第一种方法虽然减少了 HTTP 请求，但是把不同类型的代码合并在一个文件里，违反了分工原则。第二种方法只是提前了下载时间，并没有减少 HTTP 请求。</p>\n\n<h2>三、服务器推送的概念</h2>\n\n<p>服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。 </p>\n\n<p>比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p>\n\n<h2>四、Nginx 实现</h2>\n\n<p><a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/\">Nginx</a> 从 1.13.9 版开始，支持服务器推送。<a href=\"http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html\">前一篇教程</a>已经做好了 Nginx 容器，接着就来体验一下。</p>\n\n<p>首先，进入工作目录，把原来的首页删除。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ cd nginx-docker-demo\n$ rm html/index.html\n</code></pre></blockquote>\n\n<p>然后，新建<code>html/index.html</code>文件，写入本文第一节的网页源码。</p>\n\n<p>另外，<code>html</code>子目录下面，还要新建两个文件<code>example.png</code>和<code>style.css</code>。前者可以随便找一张 PNG 图片，后者要在里面写一些样式。</p>\n\n<blockquote><pre><code class=\"language-css\">\nh1 {\n  color: red;\n}\n</code></pre></blockquote>\n\n<p>最后，打开配置文件<code>conf/conf.d/default.conf</code>，将 443 端口的部分改成下面的样子。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2;\n    server_name  localhost;\n\n    ssl                      on;\n    ssl_certificate          /etc/nginx/certs/example.crt;\n    ssl_certificate_key      /etc/nginx/certs/example.key;\n\n    ssl_session_timeout  5m;\n\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers   on;\n\n    location / {\n      root   /usr/share/nginx/html;\n      index  index.html index.htm;\n      http2_push /style.css;\n      http2_push /example.png;\n    }\n}\n</code></pre></blockquote>\n\n<p>其实就是最后多了两行<code>http2_push</code>命令。它的意思是，如果用户请求根路径<code>/</code>，就推送<code>style.css</code>和<code>example.png</code>。</p>\n\n<p>现在可以启动容器了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  --volume &quot;$PWD/conf&quot;:/etc/nginx \n  -p 127.0.0.2:8080:80 \n  -p 127.0.0.2:8081:443 \n  -d \n  nginx\n</code></pre></blockquote>\n\n<p>打开浏览器，访问 https://127.0.0.2:8081 。浏览器会提示证书不安全，不去管它，继续访问，就能看到网页了。</p>\n\n<p>网页上看不出来服务器推送，必须打开&quot;开发者工具&quot;，切换到 Network 面板，就可以看到其实只发出了一次请求，<code>style.css</code>和<code>example.png</code>都是推送过来的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030502.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D58f89c9490c4ea83dbb71d59bcb30229be9adf4e\" alt=\"\" title=\"\"></p>\n\n<p>查看完毕，关闭容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>五、Apache 实现实现</h2>\n\n<p>Apache 也类似，可以在配置文件<code>httpd.conf</code>或者<code>.htaccess</code>里面打开服务器推送。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;FilesMatch &quot;index.html$&quot;&gt;\n    Header add Link &quot;&lt;/styles.css&gt;; rel=preload; as=style&quot;\n    Header add Link &quot;&lt;/example.png&gt;; rel=preload; as=image&quot;\n&lt;/FilesMatch&gt;\n</code></pre></blockquote>\n\n<h2>六、后端实现</h2>\n\n<p>上面的服务器推送，需要写在服务器的配置文件里面。这显然很不方便，每次修改都要重启服务，而且应用与服务器的配置不应该混在一起。</p>\n\n<p>服务器推送还有另一个实现方法，就是后端应用产生 HTTP 回应的头信息<code>Link</code>命令。服务器发现有这个头信息，就会进行服务器推送。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nLink: &lt;/styles.css&gt;; rel=preload; as=style\n</code></pre></blockquote>\n\n<p>如果要推送多个资源，就写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nLink: &lt;/styles.css&gt;; rel=preload; as=style, &lt;/example.png&gt;; rel=preload; as=image\n</code></pre></blockquote>\n\n<p>可以参考 <a href=\"https://ops.tips/blog/nginx-http2-server-push/\">Go</a>、<a href=\"https://blog.risingstack.com/node-js-http-2-push/\">Node</a>、<a href=\"https://blog.cloudflare.com/using-http-2-server-push-with-php/\">PHP</a> 的实现范例。</p>\n\n<p>这时，Nginx 的<a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/\">配置</a>改成下面这样。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2;\n\n    # ...\n\n    root /var/www/html;\n\n    location = / {\n        proxy_pass http://upstream;\n        http2_push_preload on;\n    }\n}\n</code></pre></blockquote>\n\n<p>如果服务器或者浏览器不支持 HTTP/2，那么浏览器就会按照 preload 来处理这个头信息，预加载指定的资源文件。</p>\n\n<p>事实上，这个头信息就是 preload 标准提出的，它的语法和<code>as</code>属性的值都写在了<a href=\"https://w3c.github.io/preload/#as-attribute\">标准</a>里面。</p>\n\n<h2>七、缓存问题</h2>\n\n<p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p>\n\n<p>一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2 default_server;\n\n    ssl_certificate ssl/certificate.pem;\n    ssl_certificate_key ssl/key.pem;\n\n    root /var/www/html;\n    http2_push_preload on;\n\n    location = /demo.html {\n        add_header Set-Cookie &quot;session=1&quot;;\n        add_header Link $resources;\n    }\n}\n\n\nmap $http_cookie $resources {\n    &quot;~*session=1&quot; &quot;&quot;;\n    default &quot;&lt;/style.css&gt;; as=style; rel=preload&quot;;\n}\n</code></pre></blockquote>\n\n<h2>八、性能提升</h2>\n\n<p>服务器推送可以提高性能。网上<a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/#measuring-server-push-performance\">测评</a>的结果是，打开这项功能，比不打开时的 HTTP/2 快了8%，比将资源都嵌入网页的 HTTP/1 快了5%。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030503.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D5f79946b57d439a26b76efa93af9a5c6e382ee5c\" alt=\"\" title=\"\"></p>\n\n<p>可以看到，提升程度也不是特别多，大概是几百毫秒。而且，也不建议一次推送太多资源，这样反而会拖累性能，因为浏览器不得不处理所有推送过来的资源。只推送 CSS 样式表可能是一个比较好的选择。</p>\n\n<h2>九、参考链接</h2>\n\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/\">A Comprehensive Guide To HTTP/2 Server Push</a>，by Jeremy Wagner</li>\n<li><a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/\">Introducing HTTP/2 Server Push with NGINX 1.13.9</a>, by Nginx</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030501.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df660e66421f2fd66eb54d82af29698b04b4b8835","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html","sourceType":"blog","time":"2018-03-05 07:58:27"},{"id":4,"name":"Nginx 容器教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>春节前，我看到 Nginx <a href=\"https://hg.nginx.org/nginx/rev/641306096f5b\">加入</a>了 HTTP/2 的 server push 功能，就很想试一下。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>正好这些天，我在学习 <a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">Docker</a>，就想到可以用 <a href=\"https://hub.docker.com/_/nginx/\">Nginx 容器</a>。万一哪里改乱了，直接删掉，再重启一个容器就可以了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022701.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df18f40e9cd9bbda0cbce061029feae6e9055406c\" alt=\"\" title=\"\"></p>\n\n<p>下面就是我搭建 Nginx 容器的过程，以及如何加入 SSL 证书。你会看到 Docker 用来测试软件的新功能，真的很方便，很值得学习。如果你还不会 Docker，可以先看<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">《Docker 入门教程》</a>，非常简单，半小时以内就能学会。</p>\n\n<h2>一、HTTP 服务</h2>\n\n<p>Nginx 的最大作用，就是搭建一个 Web Server。有了容器，只要一行命令，服务器就架设好了，完全不用配置。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  -p 127.0.0.2:8080:80 \n  --rm \n  --name mynginx \n  nginx\n</code></pre></blockquote>\n\n<p>上面命令下载并运行官方的 <a href=\"https://hub.docker.com/_/nginx/\">Nginx image</a>，默认是最新版本（latest），当前是 1.13.9。如果本机安装过以前的版本，请删掉重新安装，因为只有 1.13.9 才开始支持 server push。</p>\n\n<p>上面命令的各个参数含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>-d</code>：在后台运行</li>\n<li><code>-p</code> ：容器的<code>80</code>端口映射到<code>127.0.0.2:8080</code></li>\n<li><code>--rm</code>：容器停止运行后，自动删除容器文件</li>\n<li><code>--name</code>：容器的名字为<code>mynginx</code></li>\n</ul>\n</blockquote>\n\n<p>如果没有报错，就可以打开浏览器访问 127.0.0.2:8080 了。正常情况下，显示 Nginx 的欢迎页。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022703.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df79c809075159bfdbc22c3f555ef35d0f505a084\" alt=\"\" title=\"\"></p>\n\n<p>然后，把这个容器终止，由于<code>--rm</code>参数的作用，容器文件会自动删除。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>二、映射网页目录</h2>\n\n<p>网页文件都在容器里，没法直接修改，显然很不方便。下一步就是让网页文件所在的目录<code>/usr/share/nginx/html</code>映射到本地。</p>\n\n<p>首先，新建一个目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir nginx-docker-demo\n$ cd nginx-docker-demo\n</code></pre></blockquote>\n\n<p>然后，新建一个<code>html</code>子目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir html\n</code></pre></blockquote>\n\n<p>在这个子目录里面，放置一个<code>index.html</code>文件，内容如下。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;h1&gt;Hello World&lt;/h1&gt;\n</code></pre></blockquote>\n\n<p>接着，就可以把这个子目录<code>html</code>，映射到容器的网页文件目录<code>/usr/share/nginx/html</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  -p 127.0.0.2:8080:80 \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  nginx\n</code></pre></blockquote>\n\n<p>打开浏览器，访问 127.0.0.2:8080，应该就能看到 Hello World 了。</p>\n\n<h2>三、拷贝配置</h2>\n\n<p>修改网页文件还不够，还要修改 Nginx 的配置文件，否则后面没法加 SSL 支持。</p>\n\n<p>首先，把容器里面的 Nginx 配置文件拷贝到本地。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container cp mynginx:/etc/nginx .\n</code></pre></blockquote>\n\n<p>上面命令的含义是，把<code>mynginx</code>容器的<code>/etc/nginx</code>拷贝到当前目录。不要漏掉最后那个点。</p>\n\n<p>执行完成后，当前目录应该多出一个<code>nginx</code>子目录。然后，把这个子目录改名为<code>conf</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mv nginx conf\n</code></pre></blockquote>\n\n<p>现在可以把容器终止了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>四、映射配置目录</h2>\n\n<p>重新启动一个新的容器，这次不仅映射网页目录，还要映射配置目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  --volume &quot;$PWD/conf&quot;:/etc/nginx \n  -p 127.0.0.2:8080:80 \n  -d \n  nginx\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--volume &quot;$PWD/conf&quot;:/etc/nginx</code>表示把容器的配置目录<code>/etc/nginx</code>，映射到本地的<code>conf</code>子目录。</p>\n\n<p>浏览器访问 127.0.0.2:8080，如果能够看到网页，就说明本地的配置生效了。这时，可以把这个容器终止。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>五、自签名证书</h2>\n\n<p>现在要为容器加入 HTTPS 支持，第一件事就是生成私钥和证书。正式的证书需要证书当局（CA）的签名，这里是为了测试，搞一张自签名（self-signed）证书就可以了。</p>\n\n<p>下面，我参考的是 <a href=\"https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04\">DigitalOcean</a> 的教程。首先，确定你的机器安装了 <a href=\"https://www.openssl.org/source/\">OpenSSL</a>，然后执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo openssl req \n  -x509 \n  -nodes \n  -days 365 \n  -newkey rsa:2048 \n  -keyout example.key \n  -out example.crt\n</code></pre></blockquote>\n\n<p>上面命令的各个参数含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>req</code>：处理证书签署请求。</li>\n<li><code>-x509</code>：生成自签名证书。</li>\n<li><code>-nodes</code>：跳过为证书设置密码的阶段，这样 Nginx 才可以直接打开证书。</li>\n<li><code>-days 365</code>：证书有效期为一年。</li>\n<li><code>-newkey rsa:2048</code>：生成一个新的私钥，采用的算法是2048位的 RSA。</li>\n<li><code>-keyout</code>：新生成的私钥文件为当前目录下的<code>example.key</code>。</li>\n<li><code>-out</code>：新生成的证书文件为当前目录下的<code>example.crt</code>。</li>\n</ul>\n</blockquote>\n\n<p>执行后，命令行会跳出一堆问题要你回答，比如你在哪个国家、你的 Email 等等。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022702.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D357d0486fc97d74c7681eec9bf4ce3d514cedf77\" alt=\"\" title=\"\"></p>\n\n<p>其中最重要的一个问题是 Common Name，正常情况下应该填入一个域名，这里可以填 127.0.0.2。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nCommon Name (e.g. server FQDN or YOUR name) []:127.0.0.2\n</code></pre></blockquote>\n\n<p>回答完问题，当前目录应该会多出两个文件：<code>example.key</code>和<code>example.crt</code>。</p>\n\n<p><code>conf</code>目录下新建一个子目录<code>certs</code>，把这两个文件放入这个子目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir conf/certs\n$ mv example.crt example.key conf/certs\n</code></pre></blockquote>\n\n<h2>六、HTTPS 配置</h2>\n\n<p>有了私钥和证书，就可以打开 Nginx 的 HTTPS 了。</p>\n\n<p>首先，打开<code>conf/conf.d/default.conf</code>文件，在结尾添加下面的配置。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2;\n    server_name  localhost;\n\n    ssl                      on;\n    ssl_certificate          /etc/nginx/certs/example.crt;\n    ssl_certificate_key      /etc/nginx/certs/example.key;\n\n    ssl_session_timeout  5m;\n\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers   on;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n}\n</code></pre></blockquote>\n\n<p>然后，启动一个新的 Nginx 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  --volume &quot;$PWD/conf&quot;:/etc/nginx \n  -p 127.0.0.2:8080:80 \n  -p 127.0.0.2:8081:443 \n  -d \n  nginx\n</code></pre></blockquote>\n\n<p>上面命令中，不仅映射了容器的80端口，还映射了443端口，这是 HTTPS 的专用端口。</p>\n\n<p>打开浏览器，访问 https://127.0.0.2:8081/ 。因为使用了自签名证书，浏览器会提示不安全。不要去管它，选择继续访问，应该就可以看到 Hello World 了。</p>\n\n<p>至此，Nginx 容器的 HTTPS 支持就做好了。有了这个容器，下一篇文章，我就来试验 HTTP/2 的 server push 功能。</p>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://blog.docker.com/2015/04/tips-for-deploying-nginx-official-image-with-docker/\">Tips for deploying nginx(official image) with docker</a>, by Mario Ponticello</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-run-nginx-in-a-docker-container-on-ubuntu-14-04\">How To Run Nginx in a Docker Container on Ubuntu 14.04</a>, by Thomas Taege</li>\n<li><a href=\"https://docs.docker.com/samples/library/nginx/\">Official Docker Library docs</a>,  by Docker</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04\">How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 16.04</a>, by Justin Ellingwood</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022701.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df18f40e9cd9bbda0cbce061029feae6e9055406c","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html","sourceType":"blog","time":"2018-02-27 08:05:52"},{"id":5,"name":"Node 定时器详解","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>JavaScript 是单线程运行，异步操作特别重要。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。由于异步操作实在太多，JavaScript 不得不提供很多异步语法。这就好比，有些人老是受打击， 他的抗打击能力必须变得很强，否则他就完蛋了。</p>\n\n<p>Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 <a href=\"http://thlorenz.com/learnuv/book/history/history_1.html\">libuv</a> 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df2ed67d3ed4d25af420cea4f1f15629e5b30dc93\" alt=\"\" title=\"\"></p>\n\n<p>为了协调异步任务，Node 居然提供了四个定时器，让任务可以在指定的时间运行。</p>\n\n<blockquote>\n  <ul>\n<li>setTimeout()</li>\n<li>setInterval()</li>\n<li>setImmediate()</li>\n<li>process.nextTick()</li>\n</ul>\n</blockquote>\n\n<p>前两个是语言的标准，后两个是 Node 独有的。它们的写法差不多，作用也差不多，不太容易区别。</p>\n\n<p>你能说出下面代码的运行结果吗？</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// test.js\nsetTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n(() =&gt; console.log(5))();\n</code></pre></blockquote>\n\n<p>运行结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node test.js\n5\n3\n4\n1\n2\n</code></pre></blockquote>\n\n<p>如果你能一口说对，可能就不需要再看下去了。本文详细解释，Node 怎么处理各种定时器，或者更广义地说，libuv 库怎么安排异步任务在主线程上执行。</p>\n\n<h2>一、同步任务和异步任务</h2>\n\n<p>首先，同步任务总是比异步任务更早执行。</p>\n\n<p>前面的那段代码，只有最后一行是同步任务，因此最早执行。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n(() =&gt; console.log(5))();\n</code></pre></blockquote>\n\n<h2>二、本轮循环和次轮循环</h2>\n\n<p>异步任务可以分成两种。</p>\n\n<blockquote>\n  <ul>\n<li>追加在<strong>本轮循环</strong>的异步任务</li>\n<li>追加在<strong>次轮循环</strong>的异步任务</li>\n</ul>\n</blockquote>\n\n<p>所谓&quot;循环&quot;，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，后文会详细解释。这里只要理解，本轮循环一定早于次轮循环执行即可。</p>\n\n<p>Node 规定，<code>process.nextTick</code>和<code>Promise</code>的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>的回调函数，追加在次轮循环。</p>\n\n<p>这就是说，文首那段代码的第三行和第四行，一定比第一行和第二行更早执行。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// 下面两行，次轮循环执行\nsetTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\n// 下面两行，本轮循环执行\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n</code></pre></blockquote>\n\n<h2>三、process.nextTick()</h2>\n\n<p><code>process.nextTick</code>这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022302.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0ede6eb316df022c0840f7885f55e8350933ec1c\" alt=\"\" title=\"\"></p>\n\n<p>Node 执行完所有同步任务，接下来就会执行<code>process.nextTick</code>的任务队列。所以，下面这行代码是第二个输出结果。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nprocess.nextTick(() =&gt; console.log(3));\n</code></pre></blockquote>\n\n<p>基本上，如果你希望异步任务尽可能快地执行，那就使用<code>process.nextTick</code>。</p>\n\n<h2>四、微任务</h2>\n\n<p>根据语言规格，<code>Promise</code>对象的回调函数，会进入异步任务里面的&quot;微任务&quot;（microtask）队列。</p>\n\n<p>微任务队列追加在<code>process.nextTick</code>队列的后面，也属于本轮循环。所以，下面的代码总是先输出<code>3</code>，再输出<code>4</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n// 3\n// 4\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6c6447132171eeceb8f23f5284f42850b4000ce7\" alt=\"\" title=\"\"></p>\n\n<p>注意，只有前一个队列全部清空以后，才会执行下一个队列。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nprocess.nextTick(() =&gt; console.log(1));\nPromise.resolve().then(() =&gt; console.log(2));\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n// 1\n// 3\n// 2\n// 4\n</code></pre></blockquote>\n\n<p>上面代码中，全部<code>process.nextTick</code>的回调函数，执行都会早于<code>Promise</code>的。</p>\n\n<p>至此，本轮循环的执行顺序就讲完了。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>同步任务</li>\n<li>process.nextTick()</li>\n<li>微任务</li>\n</ol>\n</blockquote>\n\n<h2>五、事件循环的概念</h2>\n\n<p>下面开始介绍次轮循环的执行顺序，这就必须理解什么是事件循环（event loop）了。</p>\n\n<p>Node 的<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">官方文档</a>是这样介绍的。</p>\n\n<blockquote>\n  <p>&quot;When Node.js starts, it initializes the event loop, processes the provided input script  which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.&quot;</p>\n</blockquote>\n\n<p>这段话很重要，需要仔细读。它表达了三层意思。</p>\n\n<p>首先，有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。</p>\n\n<p>其次，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。</p>\n\n<blockquote>\n  <ul>\n<li>同步任务</li>\n<li>发出异步请求</li>\n<li>规划定时器生效的时间</li>\n<li>执行<code>process.nextTick()</code>等等</li>\n</ul>\n</blockquote>\n\n<p>最后，上面这些事情都干完了，事件循环就正式开始了。</p>\n\n<h2>六、事件循环的六个阶段</h2>\n\n<p>事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。</p>\n\n<p>每一轮的事件循环，分成六个阶段。这些阶段会依次执行。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>timers</li>\n<li>I/O callbacks</li>\n<li>idle, prepare</li>\n<li>poll</li>\n<li>check</li>\n<li>close callbacks</li>\n</ol>\n</blockquote>\n\n<p>每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022304.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6dbe6a60b316a9f24be19102638f2e77837af203\" alt=\"\" title=\"\"></p>\n\n<p>下面简单介绍一下每个阶段的含义，详细介绍可以看<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">官方文档</a>，也可以参考 libuv 的<a href=\"https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1\">源码解读</a>。</p>\n\n<p><strong>（1）timers</strong></p>\n\n<p>这个是定时器阶段，处理<code>setTimeout()</code>和<code>setInterval()</code>的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。</p>\n\n<p><strong>（2）I/O callbacks</strong></p>\n\n<p>除了以下操作的回调函数，其他的回调函数都在这个阶段执行。</p>\n\n<blockquote>\n  <ul>\n<li><code>setTimeout()</code>和<code>setInterval()</code>的回调函数</li>\n<li><code>setImmediate()</code>的回调函数</li>\n<li>用于关闭请求的回调函数，比如<code>socket.on(&apos;close&apos;, ...)</code></li>\n</ul>\n</blockquote>\n\n<p><strong>（3）idle, prepare</strong></p>\n\n<p>该阶段只供 libuv 内部调用，这里可以忽略。</p>\n\n<p><strong>（4）Poll</strong></p>\n\n<p>这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。</p>\n\n<p>这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</p>\n\n<p><strong>（5）check</strong></p>\n\n<p>该阶段执行<code>setImmediate()</code>的回调函数。</p>\n\n<p><strong>（6）close callbacks</strong></p>\n\n<p>该阶段执行关闭请求的回调函数，比如<code>socket.on(&apos;close&apos;, ...)</code>。</p>\n\n<h2>七、事件循环的示例</h2>\n\n<p>下面是来自官方文档的一个示例。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nconst fs = require(&apos;fs&apos;);\n\nconst timeoutScheduled = Date.now();\n\n// 异步任务一：100ms 后执行的定时器\nsetTimeout(() =&gt; {\n  const delay = Date.now() - timeoutScheduled;\n  console.log(`${delay}ms`);\n}, 100);\n\n// 异步任务二：文件读取后，有一个 200ms 的回调函数\nfs.readFile(&apos;test.js&apos;, () =&gt; {\n  const startCallback = Date.now();\n  while (Date.now() - startCallback &lt; 200) {\n    // 什么也不做\n  }\n});\n</code></pre></blockquote>\n\n<p>上面代码有两个异步任务，一个是 100ms 后执行的定时器，一个是文件读取，它的回调函数需要 200ms。请问运行结果是什么？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D993a43472a86017ec92380987e137dd2eeb1d47b\" alt=\"\" title=\"\"></p>\n\n<p>脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。</p>\n\n<p>第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行<code>fs.readFile</code>的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。</p>\n\n<p>第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒。</p>\n\n<h2>八、setTimeout 和 setImmediate</h2>\n\n<p>由于<code>setTimeout</code>在 timers 阶段执行，而<code>setImmediate</code>在 check 阶段执行。所以，<code>setTimeout</code>会早于<code>setImmediate</code>完成。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nsetTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\n</code></pre></blockquote>\n\n<p>上面代码应该先输出<code>1</code>，再输出<code>2</code>，但是实际执行的时候，结果却是不确定，有时还会先输出<code>2</code>，再输出<code>1</code>。</p>\n\n<p>这是因为<code>setTimeout</code>的第二个参数默认为<code>0</code>。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据<a href=\"https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args\">官方文档</a>，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，<code>setTimeout(f, 0)</code>等同于<code>setTimeout(f, 1)</code>。</p>\n\n<p>实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行<code>setImmediate</code>的回调函数。</p>\n\n<p>但是，下面的代码一定是先输出2，再输出1。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nconst fs = require(&apos;fs&apos;);\n\nfs.readFile(&apos;test.js&apos;, () =&gt; {\n  setTimeout(() =&gt; console.log(1));\n  setImmediate(() =&gt; console.log(2));\n});\n</code></pre></blockquote>\n\n<p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，<code>setImmediate</code>才会早于<code>setTimeout</code>执行。</p>\n\n<h2>九、参考链接</h2>\n\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">The Node.js Event Loop, Timers, and process.nextTick()</a>, by Node.js</li>\n<li><a href=\"https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1\">Handling IO -- NodeJS Event Loop</a>, by Deepal Jayasekara</li>\n<li><a href=\"http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/\">setImmediate() vs nextTick() vs setTimeout(fn,0) - in depth explanation</a>, by Paul Shan</li>\n<li><a href=\"http://voidcanvas.com/nodejs-event-loop/\">Node.js event loop workflow &amp; lifecycle in low level</a>, by Paul Shan</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df2ed67d3ed4d25af420cea4f1f15629e5b30dc93","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html","sourceType":"blog","time":"2018-02-23 08:43:45"},{"id":6,"name":"Docker 微服务教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>Docker 是一个容器工具，提供虚拟环境。很多人认为，它改变了我们对软件的认识。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器......Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021306.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db6840b3eb476ed6b06a9e8492cbe4c59f24d03f7\" alt=\"\" title=\"\"></p>\n\n<p>这正是微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021302.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd5c12ae6e3bc3b7229a6e48f7a571b81a10bea34\" alt=\"\" title=\"\"></p>\n\n<p>微服务很适合用 Docker 容器实现，每个容器承载一个服务。一台计算机同时运行多个容器，从而就能很轻松地模拟出复杂的微服务架构。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D234d7aeef1d5ffe029e84d48cb5956c948a0b563\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">上一篇教程</a>介绍了 Docker 的概念和基本用法，本文接着往下介绍，如何在一台计算机上实现多个服务，让它们互相配合，组合出一个应用程序。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021304.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D794f48fb90d724d01cc9baec5dfbf33b31d6edda\" alt=\"\" title=\"\"></p>\n\n<p>我选择的示例软件是 <a href=\"https://wordpress.org/\">WordPress</a>。它是一个常用软件，全世界用户据说超过几千万。同时它又非常简单，只要两个容器就够了（业务容器 + 数据库容器），很适合教学。而且，这种&quot;业务 + 数据库&quot;的容器架构，具有通用性，许多应用程序都可以复用。</p>\n\n<p>为了加深读者理解，本文采用三种方法，演示如何架设 WordPress 网站。</p>\n\n<blockquote>\n  <ul>\n<li>方法 A：自建 WordPress 容器</li>\n<li>方法 B：采用官方的 WordPress 容器</li>\n<li>方法 C：采用 Docker Compose 工具</li>\n</ul>\n</blockquote>\n\n<h2>一、预备工作：image 仓库的镜像网址</h2>\n\n<p>本教程需要从仓库下载 image 文件，但是国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。这里推荐使用官方镜像 registry.docker-cn.com 。下面是我的 Debian 系统的默认仓库修改方法，其他系统的修改方法参考<a href=\"https://www.docker-cn.com/registry-mirror\">官方文档</a>。</p>\n\n<p>打开<code>/etc/default/docker</code>文件（需要<code>sudo</code>权限），在文件的底部加上一行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nDOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;\n</code></pre></blockquote>\n\n<p>然后，重启 Docker 服务。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo service docker restart\n</code></pre></blockquote>\n\n<p>现在就会自动从镜像仓库下载 image 文件了。</p>\n\n<h2>二、方法 A：自建 WordPress 容器</h2>\n\n<p>前面说过，本文会用三种方法演示 WordPress 的安装。第一种方法就是自建 WordPress 容器。</p>\n\n<h3>2.1 官方 的 PHP image</h3>\n\n<p>首先，新建一个工作目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir docker-demo &amp;&amp; cd docker-demo\n</code></pre></blockquote>\n\n<p>然后，执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name wordpress \n  --volume &quot;$PWD/&quot;:/var/www/html \n  php:5.6-apache\n</code></pre></blockquote>\n\n<p>上面的命令基于<code>php</code>的 image 文件新建一个容器，并且运行该容器。<code>php</code>的标签是<code>5.6-apache</code>，说明装的是 PHP 5.6，并且自带 Apache 服务器。该命令的三个参数含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>--rm</code>：停止运行后，自动删除容器文件。</li>\n<li><code>--name wordpress</code>：容器的名字叫做<code>wordpress</code>。</li>\n<li><code>--volume &quot;$PWD/&quot;:/var/www/html</code>：将当前目录（<code>$PWD</code>）映射到容器的<code>/var/www/html</code>（Apache 对外访问的默认目录）。因此，当前目录的任何修改，都会反映到容器里面，进而被外部访问到。</li>\n</ul>\n</blockquote>\n\n<p>运行上面的命令以后，如果一切正常，命令行会提示容器对外的 IP 地址，请记下这个地址，我们要用它来访问容器。我分配到的 IP 地址是 172.17.0.2。</p>\n\n<p>打开浏览器，访问 172.17.0.2，你会看到下面的提示。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nForbidden\nYou don&apos;t have permission to access / on this server.\n</code></pre></blockquote>\n\n<p>这是因为容器的<code>/var/www/html</code>目录（也就是本机的<code>docker-demo</code>目录）下面什么也没有，无法提供可以访问的内容。</p>\n\n<p>请在本机的<code>docker-demo</code>目录下面，添加一个最简单的 PHP 文件<code>index.php</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n&lt;?php \nphpinfo();\n?&gt;\n</code></pre></blockquote>\n\n<p>保存以后，浏览器刷新<code>172.17.0.2</code>，应该就会看到熟悉的<code>phpinfo</code>页面了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D5de30b20608db3c72808560f4593608e65dab3eb\" alt=\"\" title=\"\"></p>\n\n<h3>2.2 拷贝 WordPress 安装包</h3>\n\n<p>既然本地的<code>docker-demo</code>目录可以映射到容器里面，那么把 WordPress 安装包拷贝到<code>docker-demo</code>目录下，不就可以通过容器访问到 WordPress 的安装界面了吗？</p>\n\n<p>首先，在<code>docker-demo</code>目录下，执行下面的命令，抓取并解压 WordPress 安装包。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ wget https://cn.wordpress.org/wordpress-4.9.4-zh_CN.tar.gz\n$ tar -xvf wordpress-4.9.4-zh_CN.tar.gz\n</code></pre></blockquote>\n\n<p>解压以后，WordPress 的安装文件会在<code>docker-demo/wordpress</code>目录下。</p>\n\n<p>这时浏览器访问<code>http://172.17.0.2/wordpress</code>，就能看到 WordPress 的安装提示了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021307.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D87c76c168cc3f5a820d8861a9d3c63d532cd4528\" alt=\"\" title=\"\"></p>\n\n<h3>2.3 官方的 MySQL 容器</h3>\n\n<p>WordPress 必须有数据库才能安装，所以必须新建 MySQL 容器。</p>\n\n<p>打开一个新的命令行窗口，执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  --rm \n  --name wordpressdb \n  --env MYSQL_ROOT_PASSWORD=123456 \n  --env MYSQL_DATABASE=wordpress \n  mysql:5.7\n</code></pre></blockquote>\n\n<p>上面的命令会基于 MySQL 的 image 文件（5.7版本）新建一个容器。该命令的五个命令行参数的含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>-d</code>：容器启动后，在后台运行。</li>\n<li><code>--rm</code>：容器终止运行后，自动删除容器文件。</li>\n<li><code>--name wordpressdb</code>：容器的名字叫做<code>wordpressdb</code></li>\n<li><code>--env MYSQL_ROOT_PASSWORD=123456</code>：向容器进程传入一个环境变量<code>MYSQL_ROOT_PASSWORD</code>，该变量会被用作 MySQL 的根密码。</li>\n<li><code>--env MYSQL_DATABASE=wordpress</code>：向容器进程传入一个环境变量<code>MYSQL_DATABASE</code>，容器里面的 MySQL 会根据该变量创建一个同名数据库（本例是<code>WordPress</code>）。</li>\n</ul>\n</blockquote>\n\n<p>运行上面的命令以后，正常情况下，命令行会显示一行字符串，这是容器的 ID，表示已经新建成功了。</p>\n\n<p>这时，使用下面的命令查看正在运行的容器，你应该看到<code>wordpress</code>和<code>wordpressdb</code>两个容器正在运行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container ls\n</code></pre></blockquote>\n\n<p>其中，<code>wordpressdb</code>是后台运行的，前台看不见它的输出，必须使用下面的命令查看。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container logs wordpressdb\n</code></pre></blockquote>\n\n<h3>2.4 定制 PHP 容器</h3>\n\n<p>现在 WordPress 容器和 MySQL 容器都已经有了。接下来，要把 WordPress 容器连接到 MySQL 容器了。但是，PHP 的官方 image 不带有<code>mysql</code>扩展，必须自己新建 image 文件。</p>\n\n<p>首先，停掉 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress\n</code></pre></blockquote>\n\n<p>停掉以后，由于<code>--rm</code>参数的作用，该容器文件会被自动删除。</p>\n\n<p>然后，在<code>docker-demo</code>目录里面，新建一个<code>Dockerfile</code>文件，写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nFROM php:5.6-apache\nRUN docker-php-ext-install mysqli\nCMD apache2-foreground\n</code></pre></blockquote>\n\n<p>上面代码的意思，就是在原来 PHP 的 image 基础上，安装<code>mysqli</code>的扩展。然后，启动 Apache。</p>\n\n<p>基于这个 Dockerfile 文件，新建一个名为<code>phpwithmysql</code>的 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker build -t phpwithmysql .\n</code></pre></blockquote>\n\n<h3>2.5 Wordpress 容器连接 MySQL</h3>\n\n<p>现在基于 phpwithmysql image，重新新建一个 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name wordpress \n  --volume &quot;$PWD/&quot;:/var/www/html \n  --link wordpressdb:mysql \n  phpwithmysql\n</code></pre></blockquote>\n\n<p>跟上一次相比，上面的命令多了一个参数<code>--link wordpressdb:mysql</code>，表示 WordPress 容器要连到<code>wordpressdb</code>容器，冒号表示该容器的别名是<code>mysql</code>。</p>\n\n<p>这时还要改一下<code>wordpress</code>目录的权限，让容器可以将配置信息写入这个目录（容器内部写入的<code>/var/www/html</code>目录，会映射到这个目录）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ chmod -R 777 wordpress\n</code></pre></blockquote>\n\n<p>接着，回到浏览器的<code>http://172.17.0.2/wordpress</code>页面，点击&quot;现在就开始！&quot;按钮，开始安装。</p>\n\n<p>WordPress 提示要输入数据库参数。输入的参数如下。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021308.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D801fd47f3a376b6421d30529032a99c9970019e3\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <ul>\n<li>数据库名：<code>wordpress</code></li>\n<li>用户名：<code>root</code></li>\n<li>密码：<code>123456</code></li>\n<li>数据库主机：<code>mysql</code></li>\n<li>表前缀：<code>wp_</code>（不变）</li>\n</ul>\n</blockquote>\n\n<p>点击&quot;下一步&quot;按钮，如果 Wordpress 连接数据库成功，就会出现下面的页面，这就表示可以安装了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021309.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De9514d0610f2d050b225189e1ba483c51be9f4cd\" alt=\"\" title=\"\"></p>\n\n<p>至此，自建 WordPress 容器的演示完毕，可以把正在运行的两个容器关闭了（容器文件会自动删除）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress wordpressdb\n</code></pre></blockquote>\n\n<h2>三、方法 B：Wordpress 官方镜像</h2>\n\n<p>上一部分的自建 WordPress 容器，还是挺麻烦的。其实不用这么麻烦，Docker 已经提供了官方 <a href=\"https://hub.docker.com/_/wordpress/\">WordPress</a> image，直接用那个就可以了。有了上一部分的基础，下面的操作就很容易理解了。</p>\n\n<h3>3.1 基本用法</h3>\n\n<p>首先，新建并启动 MySQL 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  --rm \n  --name wordpressdb \n  --env MYSQL_ROOT_PASSWORD=123456 \n  --env MYSQL_DATABASE=wordpress \n  mysql:5.7\n</code></pre></blockquote>\n\n<p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  --rm \n  --name wordpress \n  --env WORDPRESS_DB_PASSWORD=123456 \n  --link wordpressdb:mysql \n  wordpress\n</code></pre></blockquote>\n\n<p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p>\n\n<p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container inspect wordpress\n</code></pre></blockquote>\n\n<p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。 </p>\n\n<p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021310.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6e92e55675cd5b46b32338357b755d7dac07c15b\" alt=\"\" title=\"\"></p>\n\n<h3>3.2 WordPress 容器的定制</h3>\n\n<p>到了上一步，官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p>\n\n<blockquote>\n  <ul>\n<li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li>\n<li>WordPress 安装在容器里面，本地无法修改文件。</li>\n</ul>\n</blockquote>\n\n<p>解决这两个问题很容易，只要新建容器的时候，加两个命令行参数就可以了。</p>\n\n<p>先把刚才启动的 WordPress 容器终止（容器文件会自动删除）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress\n</code></pre></blockquote>\n\n<p>然后，使用下面的命令新建并启动 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n $ docker container run \n  -d \n  -p 127.0.0.2:8080:80 \n  --rm \n  --name wordpress \n  --env WORDPRESS_DB_PASSWORD=123456 \n  --link wordpressdb:mysql \n  --volume &quot;$PWD/wordpress&quot;:/var/www/html \n  wordpress\n</code></pre></blockquote>\n\n<p>上面的命令跟前面相比，命令行参数只多出了两个。</p>\n\n<blockquote>\n  <ul>\n<li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li>\n<li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li>\n</ul>\n</blockquote>\n\n<p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p>\n\n<p>最后，终止这两个容器（容器文件会自动删除）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress wordpressdb\n</code></pre></blockquote>\n\n<h2>四、方法 C：Docker Compose 工具</h2>\n\n<p>上面的方法 B 已经挺简单了，但是必须自己分别启动两个容器，启动的时候，还要在命令行提供容器之间的连接信息。因此，Docker 提供了一种更简单的方法，来管理多个容器的联动。</p>\n\n<h3>4.1 Docker Compose 简介</h3>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021311.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D73175fd1db4fcf02a6df9e8b8c3052ba42e150c3\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"https://docs.docker.com/compose/\">Compose</a> 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 <a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\">YAML</a> 格式的配置文件<code>docker-compose.yml</code>，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 启动所有服务\n$ docker-compose up\n# 关闭所有服务\n$ docker-compose stop\n</code></pre></blockquote>\n\n<h3>4.2 Docker Compose 的安装</h3>\n\n<p>Mac 和 Windows 在安装 docker 的时候，会一起安装 docker compose。Linux 系统下的安装参考<a href=\"https://docs.docker.com/compose/install/#install-compose\">官方文档</a>。 </p>\n\n<p>安装完成后，运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose --version\n</code></pre></blockquote>\n\n<h3>4.3 WordPress 示例</h3>\n\n<p>在<code>docker-demo</code>目录下，新建<code>docker-compose.yml</code>文件，写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nmysql:\n    image: mysql:5.7\n    environment:\n     - MYSQL_ROOT_PASSWORD=123456\n     - MYSQL_DATABASE=wordpress\nweb:\n    image: wordpress\n    links:\n     - mysql\n    environment:\n     - WORDPRESS_DB_PASSWORD=123456\n    ports:\n     - &quot;127.0.0.3:8080:80&quot;\n    working_dir: /var/www/html\n    volumes:\n     - wordpress:/var/www/html\n</code></pre></blockquote>\n\n<p>上面代码中，两个顶层标签表示有两个容器<code>mysql</code>和<code>web</code>。每个容器的具体设置，前面都已经讲解过了，还是挺容易理解的。</p>\n\n<p>启动两个容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose up\n</code></pre></blockquote>\n\n<p>浏览器访问 http://127.0.0.3:8080，应该就能看到 WordPress 的安装界面。</p>\n\n<p>现在关闭两个容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose stop\n</code></pre></blockquote>\n\n<p>关闭以后，这两个容器文件还是存在的，写在里面的数据不会丢失。下次启动的时候，还可以复用。下面的命令可以把这两个容器文件删除（容器必须已经停止运行）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose rm\n</code></pre></blockquote>\n\n<h2>五、参考链接</h2>\n\n<ul>\n<li><a href=\"https://www.sitepoint.com/how-to-manually-build-docker-containers-for-wordpress/\">How to Manually Build Docker Containers for WordPress</a>, by Aleksander Koko</li>\n<li><a href=\"https://www.sitepoint.com/how-to-use-the-official-docker-wordpress-image/\">How to Use the Official Docker WordPress Image</a>, by Aleksander Koko</li>\n<li><a href=\"https://www.sitepoint.com/deploying-wordpress-with-docker/\">Deploying WordPress with Docker</a>, by Aleksander Koko</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021306.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db6840b3eb476ed6b06a9e8492cbe4c59f24d03f7","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html","sourceType":"blog","time":"2018-02-13 09:31:50"},{"id":7,"name":"Docker 入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>2013年发布至今， <a href=\"https://www.docker.com/\">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018020901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612647%3B1553148647%26q-key-time%3D1521612647%3B1553148647%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3888ab38ddde6fb657f7667548c29ce0391a2247\" alt=\"\" title=\"\"></p>\n\n<h2>一、环境配置的难题</h2>\n\n<p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>\n\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>\n\n<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>\n\n<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n\n<h2>二、虚拟机</h2>\n\n<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>\n\n<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>\n\n<p><strong>（1）资源占用多</strong></p>\n\n<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>\n\n<p><strong>（2）冗余步骤多</strong></p>\n\n<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>\n\n<p><strong>（3）启动慢</strong></p>\n\n<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>\n\n<h2>三、Linux 容器</h2>\n\n<p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>\n\n<p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href=\"https://opensource.com/article/18/1/history-low-level-container-runtimes\">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>\n\n<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>\n\n<p><strong>（1）启动快</strong></p>\n\n<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>\n\n<p><strong>（2）资源占用少</strong></p>\n\n<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>\n\n<p><strong>（3）体积小</strong></p>\n\n<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>\n\n<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>\n\n<h2>四、Docker 是什么？</h2>\n\n<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>\n\n<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>\n\n<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n\n<h2>五、Docker 的用途</h2>\n\n<p>Docker 的主要用途，目前有三大类。</p>\n\n<p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>\n\n<p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>\n\n<p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>\n\n<h2>六、Docker 的安装</h2>\n\n<p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p>\n\n<p>Docker CE 的安装请参考官方文档。</p>\n\n<blockquote>\n  <ul>\n<li><a href=\"https://docs.docker.com/docker-for-mac/install/\">Mac</a></li>\n<li><a href=\"https://docs.docker.com/docker-for-windows/install/\">Windows</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\">Ubuntu</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\">Debian</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">CentOS</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/fedora/\">Fedora</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/binaries/\">其他 Linux 发行版</a></li>\n</ul>\n</blockquote>\n\n<p>安装完成后，运行下面的命令，验证是否安装成功。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker version\n# 或者\n$ docker info\n</code></pre></blockquote>\n\n<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href=\"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user\">官方文档</a>）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo usermod -aG docker $USER\n</code></pre></blockquote>\n\n<p>Docker 是服务器----客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href=\"https://docs.docker.com/config/daemon/systemd/\">官方文档</a>）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# service 命令的用法\n$ sudo service docker start\n\n# systemctl 命令的用法\n$ sudo systemctl start docker\n</code></pre></blockquote>\n\n<h2>六、image 文件</h2>\n\n<p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>\n\n<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 列出本机的所有 image 文件。\n$ docker image ls\n\n# 删除 image 文件\n$ docker image rm [imageName]\n</code></pre></blockquote>\n\n<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>\n\n<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href=\"https://hub.docker.com/\">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>\n\n<h2>七、实例：hello world</h2>\n\n<p>下面，我们通过最简单的 image 文件&quot;<a href=\"https://hub.docker.com/r/library/hello-world/\">hello world&quot;</a>，感受一下 Docker。</p>\n\n<p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p>\n\n<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image pull library/hello-world\n</code></pre></blockquote>\n\n<p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>\n\n<p>由于 Docker 官方提供的 image 文件，都放在<a href=\"https://hub.docker.com/r/library/\"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image pull hello-world\n</code></pre></blockquote>\n\n<p>抓取成功以后，就可以在本机看到这个 image 文件了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image ls\n</code></pre></blockquote>\n\n<p>现在，运行这个 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run hello-world\n</code></pre></blockquote>\n\n<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>\n\n<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>\n\n<p>如果运行成功，你会在屏幕上读到下面的输出。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\n... ...\n</code></pre></blockquote>\n\n<p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p>\n\n<p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run -it ubuntu bash\n</code></pre></blockquote>\n\n<p>对于那些不会自动终止的容器，必须使用<a href=\"https://docs.docker.com/engine/reference/commandline/container_kill/\"><code>docker container kill</code></a> 命令手动终止。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container kill [containID]\n</code></pre></blockquote>\n\n<h2>八、容器文件</h2>\n\n<p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 列出本机正在运行的容器\n$ docker container ls\n\n# 列出本机所有容器，包括终止运行的容器\n$ docker container ls --all\n</code></pre></blockquote>\n\n<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p>\n\n<p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href=\"https://docs.docker.com/engine/reference/commandline/container_rm/\"><code>docker container rm</code></a>命令删除。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container rm [containerID]\n</code></pre></blockquote>\n\n<p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p>\n\n<h2>九、Dockerfile 文件</h2>\n\n<p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p>\n\n<p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>\n\n<p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p>\n\n<h2>十、实例：制作自己的 Docker 容器</h2>\n\n<p>下面我以 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p>\n\n<p>作为准备工作，请先<a href=\"https://github.com/ruanyf/koa-demos/archive/master.zip\">下载源码</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ git clone https://github.com/ruanyf/koa-demos.git\n$ cd koa-demos\n</code></pre></blockquote>\n\n<h3>10.1 编写 Dockerfile 文件</h3>\n\n<p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href=\"https://github.com/ruanyf/koa-demos/blob/master/.dockerignore\">内容</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n.git\nnode_modules\nnpm-debug.log\n</code></pre></blockquote>\n\n<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>\n\n<p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href=\"https://github.com/ruanyf/koa-demos/blob/master/Dockerfile\">内容</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nFROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\n</code></pre></blockquote>\n\n<p>上面代码一共五行，含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>\n<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>\n<li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li>\n<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>\n<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>\n</ul>\n</blockquote>\n\n<h3>10.2 创建 image 文件</h3>\n\n<p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image build -t koa-demo .\n# 或者\n$ docker image build -t koa-demo:0.0.1 .\n</code></pre></blockquote>\n\n<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p>\n\n<p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image ls\n</code></pre></blockquote>\n\n<h3>10.3 生成容器</h3>\n\n<p><code>docker container run</code>命令会从 image 文件生成容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run -p 8000:3000 -it koa-demo /bin/bash\n# 或者\n$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash\n</code></pre></blockquote>\n\n<p>上面命令的各个参数含义如下：</p>\n\n<blockquote>\n  <ul>\n<li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li>\n<li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>\n<li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>\n<li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>\n</ul>\n</blockquote>\n\n<p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nroot@66d80f4aaf1e:/app#\n</code></pre></blockquote>\n\n<p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nroot@66d80f4aaf1e:/app# node demos/01.js\n</code></pre></blockquote>\n\n<p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found&quot;，这是因为这个 <a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/01.js\">demo</a> 没有写路由。</p>\n\n<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p>\n\n<p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 在本机的另一个终端窗口，查出容器的 ID\n$ docker container ls\n\n# 停止指定的容器运行\n$ docker container kill [containerID]\n</code></pre></blockquote>\n\n<p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 查出容器的 ID\n$ docker container ls --all\n\n# 删除指定的容器文件\n$ docker container rm [containerID]\n</code></pre></blockquote>\n\n<p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash\n</code></pre></blockquote>\n\n<h3>10.4 CMD 命令</h3>\n\n<p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nFROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\nCMD node demos/01.js\n</code></pre></blockquote>\n\n<p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p>\n\n<p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p>\n\n<p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1\n</code></pre></blockquote>\n\n<h3>10.5 发布 image 文件</h3>\n\n<p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>\n\n<p>首先，去 <a href=\"https://hub.docker.com/\">hub.docker.com</a>  或 <a href=\"https://cloud.docker.com\">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker login\n</code></pre></blockquote>\n\n<p>接着，为本地的 image 标注用户名和版本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image tag [imageName] [username]/[repository]:[tag]\n# 实例\n$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1\n</code></pre></blockquote>\n\n<p>也可以不标注用户名，重新构建一下 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image build -t [username]/[repository]:[tag] .\n</code></pre></blockquote>\n\n<p>最后，发布 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image push [username]/[repository]:[tag]\n</code></pre></blockquote>\n\n<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>\n\n<h2>十一、其他有用的命令</h2>\n\n<p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>\n\n<p><strong>（1）docker container start</strong></p>\n\n<p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container start [containerID]\n</code></pre></blockquote>\n\n<p><strong>（2）docker container stop</strong></p>\n\n<p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash container stop [containerID]\n</code></pre></blockquote>\n\n<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>\n\n<p><strong>（3）docker container logs</strong></p>\n\n<p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container logs [containerID]\n</code></pre></blockquote>\n\n<p><strong>（4）docker container exec</strong></p>\n\n<p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container exec -it [containerID] /bin/bash\n</code></pre></blockquote>\n\n<p><strong>（5）docker container cp</strong></p>\n\n<p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container cp [containID]:[/path/to/file] .\n</code></pre></blockquote>\n\n<p>非常感谢你一直读到了这里，这个系列还有<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\">下一篇</a>，介绍如何使用 Docker 搭建真正的网站，欢迎<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\">继续阅读</a>。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018020901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612647%3B1553148647%26q-key-time%3D1521612647%3B1553148647%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3888ab38ddde6fb657f7667548c29ce0391a2247","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html","sourceType":"blog","time":"2018-02-09 05:53:27"},{"id":8,"name":"汇编语言入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012204.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd78c9986281022aee9aad5383b391fc352b8280f\" alt=\"\" title=\"\"></p>\n\n<p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>\n\n<p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012202.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3b74b90c1eef5feef9e6e4c73c3d3d2ffe6097c7\" alt=\"\" title=\"\"></p>\n\n<h2>一、汇编语言是什么？</h2>\n\n<p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>\n\n<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href=\"http://www.ruanyifeng.com/blog/2014/11/compiler.html\">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>\n\n<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012203.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da4252298c1806683885e5c60b7f1cdb530dc8ebd\" alt=\"\" title=\"\"></p>\n\n<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>\n\n<h2>二、来历</h2>\n\n<p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>\n\n<p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p>\n\n<p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012205.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D015e7a31b2663c2318964e40a3d7a50aedbdbe7b\" alt=\"\" title=\"\"></p>\n\n<p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>\n\n<h2>三、寄存器</h2>\n\n<p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>\n\n<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>\n\n<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012206.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2c294f33e1e5a682751be2d7b26de481b3d5c77a\" alt=\"\" title=\"\"></p>\n\n<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>\n\n<h2>四、寄存器的种类</h2>\n\n<p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>\n\n<blockquote>\n  <ul>\n<li>EAX</li>\n<li>EBX</li>\n<li>ECX</li>\n<li>EDX</li>\n<li>EDI</li>\n<li>ESI</li>\n<li>EBP</li>\n<li>ESP</li>\n</ul>\n</blockquote>\n\n<p>上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012207.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd70aadfd9ca917fb62ecbbc83d856877eb0b99f1\" alt=\"\" title=\"\"></p>\n\n<p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p>\n\n<h2>五、内存模型：Heap</h2>\n\n<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>\n\n<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012208.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da503072300af4072fadd1f2cea73f54969a460a1\" alt=\"\" title=\"\"></p>\n\n<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012209.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D65cb8c45ddc8d4ed13bc8c172188f7adfd6c7269\" alt=\"\" title=\"\"></p>\n\n<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>\n\n<h2>六、内存模型：Stack</h2>\n\n<p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012210.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1b58548d479bbc93da61a304a201581e33d83db4\" alt=\"\" title=\"\"></p>\n\n<p>请看下面的例子。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nint main() {\n   int a = 2;\n   int b = 3;\n}\n</code></pre></blockquote>\n\n<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012211.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1239b4514aab6ae51b0eb56d383893f272cf928b\" alt=\"\" title=\"\"></p>\n\n<p>如果函数内部调用了其他函数，会发生什么情况？</p>\n\n<blockquote><pre><code class=\"language-clike\">\nint main() {\n   int a = 2;\n   int b = 3;\n   return add_a_and_b(a, b);\n}\n</code></pre></blockquote>\n\n<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012212.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D054a7a1583f55583021d6a46f4df0053f22f4c6b\" alt=\"\" title=\"\"></p>\n\n<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>\n\n<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做&quot;入栈&quot;，英文是 push；栈的回收叫做&quot;出栈&quot;，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做&quot;后进先出&quot;的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012213.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D288bf7bae34bf96273aaab451582d606d470a7de\" alt=\"\" title=\"\"></p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012214.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dde7de4aa3f5f773512ad8aa58cdaadb7d25e9c84\" alt=\"\" title=\"\"></p>\n\n<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012215.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D54cbb26a33a6a9dde358837ad5bcc905f3f28d3b\" alt=\"\" title=\"\"></p>\n\n<h2>七、CPU 指令</h2>\n\n<h3>7.1 一个实例</h3>\n\n<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nint add_a_and_b(int a, int b) {\n   return a + b;\n}\n\nint main() {\n   return add_a_and_b(2, 3);\n}\n</code></pre></blockquote>\n\n<p>gcc 将这个程序转成汇编语言。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ gcc -S example.c\n</code></pre></blockquote>\n\n<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>\n\n<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n_add_a_and_b:\n   push   %ebx\n   mov    %eax, [%esp+8] \n   mov    %ebx, [%esp+12]\n   add    %eax, %ebx \n   pop    %ebx \n   ret  \n\n_main:\n   push   3\n   push   2\n   call   _add_a_and_b \n   add    %esp, 8\n   ret\n</code></pre></blockquote>\n\n<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>\n\n<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   %ebx\n</code></pre></blockquote>\n\n<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>\n\n<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>\n\n<h3>7.2 push 指令</h3>\n\n<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>\n\n<p>然后，开始执行第一行代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   3\n</code></pre></blockquote>\n\n<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>\n\n<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   2\n</code></pre></blockquote>\n\n<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012216.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D65ed333e199ccae23510d13212a794146cba3e0c\" alt=\"\" title=\"\"></p>\n\n<h3>7.3 call 指令</h3>\n\n<p>第三行的<code>call</code>指令用来调用函数。</p>\n\n<blockquote><pre><code class=\"language-clike\">\ncall   _add_a_and_b\n</code></pre></blockquote>\n\n<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>\n\n<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   %ebx\n</code></pre></blockquote>\n\n<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>\n\n<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>\n\n<h3>7.4 mov 指令</h3>\n\n<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nmov    %eax, [%esp+8] \n</code></pre></blockquote>\n\n<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>\n\n<p>下一行代码也是干同样的事情。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nmov    %ebx, [%esp+12] \n</code></pre></blockquote>\n\n<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>\n\n<h3>7.5 add 指令</h3>\n\n<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nadd    %eax, %ebx\n</code></pre></blockquote>\n\n<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>\n\n<h3>7.6 pop 指令</h3>\n\n<p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npop    %ebx\n</code></pre></blockquote>\n\n<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>\n\n<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>\n\n<h3>7.7 ret 指令</h3>\n\n<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nret\n</code></pre></blockquote>\n\n<p>可以看到，该指令没有运算子。</p>\n\n<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nadd    %esp, 8 \n</code></pre></blockquote>\n\n<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nret\n</code></pre></blockquote>\n\n<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>\n\n<h2>八、参考链接</h2>\n\n<ul>\n<li><a href=\"http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/\">Introduction to reverse engineering and Assembly</a>, by Youness Alaoui</li>\n<li><a href=\"http://www.cs.virginia.edu/~evans/cs216/guides/x86.html\">x86 Assembly Guide</a>, by University of Virginia Computer Science</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012204.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd78c9986281022aee9aad5383b391fc352b8280f","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html","sourceType":"blog","time":"2018-01-21 18:17:48"},{"id":9,"name":"加密货币的本质","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>去年，比特币暴涨，其他币也像雨后春笋一样冒出来，已经有1000多种了。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>很多人都在问，加密货币（cryptocurrency）的时代，真的来临了吗？将来会不会人类不再使用美元、人民币，改用加密货币？那么多品种，我应该使用哪一种币？要不要现在就去投资一些？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db3f7e08de9693f72c7251e39f16c1b8504be59b9\" alt=\"\" title=\"\"></p>\n\n<p>这些问题的答案，我也想知道，就花了很多时间查阅资料、研究协议。前两周发表的<a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\">《区块链入门教程》</a>和<a href=\"http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html\">《比特币入门教程》</a>，是我的学习心得。但是，那两篇教程主要介绍基本概念、探讨协议的可行性，没回答一个根本的问题：加密货币到底是什么？</p>\n\n<p>下面就是我对这个问题的思考。阅读之前，如果你已经了解区块链和比特币，那很好；如果不了解，也没关系，本文不涉及技术，只讨论最基本的原理。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011102.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Decce88f5b0a3643f1a23db54dabd339a1bfd87d8\" alt=\"\" title=\"\"></p>\n\n<h2>一、钱是什么？</h2>\n\n<p>我们都知道，人民币是钱，美元是钱，金银财宝是钱。我问一个问题，它们为什么能成为钱？</p>\n\n<p>你可能回答，因为它们有价值，或者是价值的代表。但是，有价值的东西多了，为什么只有这些品种成为了钱？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011103.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da87be8850d5a2d6240d3e89c8179aa899aa22991\" alt=\"\" title=\"\"></p>\n\n<p>答案很容易想到，因为人们普遍相信（认同）它们的价值，其他东西的价值难以得到普通认同，无法成为钱。比如，邮票的价值就没有普遍的认同，除了集邮爱好者，其他地方都不能当钱用。一般来说，认同的人越多，这种钱的通用性就越高。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011104.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De0835a17dd937a9484268ec751770f5761b7a337\" alt=\"\" title=\"\"></p>\n\n<p>我曾经去俄罗斯旅行，当地货币是卢布。可是，一旦离开俄国，没人相信它的购买力，所以卢布离开俄国就没用了。相反，全世界人民都相信美元的价值，所以全世界都能用。我用美元付账的时候，我发现那些俄国人都很满意。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011105.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D43c0a7d2cee1b0f5a8c253db6254aea099863b4f\" alt=\"\" title=\"\"></p>\n\n<p>所以，<strong>钱的本质，或者说货币的本质，就是它的可信性。</strong>它必须使人们相信，它是有价值的，然后才能成为钱，才能被收藏和支付。</p>\n\n<h2>二、可信性</h2>\n\n<p>为什么钱必须是可信的？因为对方必须相信它的价值，否则你没法支付出去。那么，接下来的问题就是，可信的东西是否就是钱？</p>\n\n<p>我的回答是 Yes。<strong>一样东西能否成为钱，只取决于人们是否相信它的价值，至于它是不是真的有价值，根本不重要。</strong></p>\n\n<p>如果马云在一张纸条上写&quot;这张纸条价值10000元&quot;，下面签了他的名，并且附上防伪标记。你说这纸条是钱吗？我跟你保证，这就是钱，你用来支付，人们都会接受，马云等同于发行了一种新的纸币。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011106.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D060b19e7f07e7cd4c7411d99c37314770a285593\" alt=\"\" title=\"\"></p>\n\n<p>比特币也是如此，它是什么，其实不太重要。重要的是，它必须保证自己是可信的，这样才能让足够的人相信它的价值，然后才能成为钱。</p>\n\n<h2>三、比特币的可信性</h2>\n\n<p><strong>比特币要解决的核心问题，就是创造一种可信的数字凭证。</strong>由于这种凭证可信，所以能够当做货币。</p>\n\n<p>比特币的技术基础是加密学，因为只有加密学才能保证它的可信性。一旦加密被破解，它就没法当作货币了。这也是这一类数字凭证被称为&quot;加密货币&quot;的原因。</p>\n\n<p>技术人员对比特币感兴趣，还有一个重要原因。任何需要可靠的数字凭证的场合，也许都可以用到这种技术。</p>\n\n<h2>四、比特币的特点</h2>\n\n<p>比特币有三个特点，就是因为做到了这三点，所以它可信，能够当作钱。</p>\n\n<p><strong>首先，它不会被（轻易）偷走。</strong>或者反过来说，它使得你无法去偷别人，你只能花你自己的钱。因为必须要有别人的私钥，才能取出他的钱。正常情况下，你拿不到别人的私钥。</p>\n\n<p><strong>其次，它无法伪造。</strong>每一个比特币都能追溯来源，而所有比特币都来源于矿工获得的奖励。矿工只有新建区块，才能获得奖励，这是很难的事情，所以无法伪造比特币。</p>\n\n<p><strong>最后，它无法大批生成。</strong>原因跟上一条一样，比特币的发行速度是稳定的，现在每10分钟新增12.5个，然后每四年减半，最终停止增长。因此不会像纸币那样，政府滥发导致通货膨胀。</p>\n\n<h2>五、比特币有实体吗？</h2>\n\n<p>由于后面要提到的原因，比特币不可能拥有实体，没法做到&quot;从口袋里掏出一个币&quot;这种场景，交易都必须通过互联网完成。</p>\n\n<p>你可能会说，钱都有实体，怎么可能存在无形的钱呢？答案正好相反，<strong>钱就应该是无形的，那些实体的钱其实是对物质材料的浪费，由于技术不够发达，不得不做成实体。</strong></p>\n\n<p>我小时候买东西，都必须用现金，否则没法证明，自己拥有购买力。只有通过实体的钱，才能保证对方确实收到了钱。如果银行业发达，就不用现金了，可以使用银行卡。支付的时候，对方抄一下银行卡号码，查询银行&quot;这个账户有钱吗&quot;。银行回答有钱，OK，成交。</p>\n\n<p>但是，互联网使得实体的银行卡也不需要了。如果存在一个开放的中央记账系统，任何人都可以查询，你把钱划到老板的账户，老板查询一下，发现收到了，交易自动成交，整个过程都是无形的，还需要什么银行卡呢？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011108.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7852b7b8f447833e41dc9cc3e2718375714d5974\" alt=\"\" title=\"\"></p>\n\n<p>这个中央记账系统已经实现了，就叫做区块链。</p>\n\n<h2>六、区块链的作用</h2>\n\n<p><strong>区块链就是一个数据库，记载了所有的交易，用作中央记账系统。</strong></p>\n\n<p><strong>每笔交易的核心，就是一句话，比如&quot;张三向李四转移了1个比特币&quot;。</strong>为了证明这句话可信，张三为它加上了数字签名。任何人都可以用张三的公钥，证明这确实是张三本人的行为。另一方面，其他人无法伪造张三的数字签名，所以不可能伪造这笔交易。</p>\n\n<p>矿工们收到这句话，首先验证数字签名的可信性，然后验证张三确实拥有这些比特币（每一笔交易都有上一笔交易的编号，用来查询比特币的来源）。验证通过以后，就着手把这句话写入区块链了。一旦写入区块链，所有人就都可以查询到，因此这笔比特币就被认为，从张三转移到了李四。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011107.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfbe8d70bae4825e6dc573e251d61762bfd492958\" alt=\"\" title=\"\"></p>\n\n<p><strong>区块链的作用就是把这句话永久保存下来了，让任何人都可以查看，并且任何人（包括张三本人在内）都无法再修改了。</strong></p>\n\n<p><strong>货币是什么？其实就是这句话。这一句话就完成了一次支付。</strong>我们平时用人民币支付，其实只是用纸币表达这条信息。如果每个人都可以实时写入/读取中央记账系统（区块链），那么完全可以不携带货币。</p>\n\n<h2>七、双重支出</h2>\n\n<p>前面说过，交易不可能被伪造。但是，由于每一笔交易都是一串二进制信号，因此可能被复制。举例来说，&quot;张三向李四转移了1个比特币&quot;这句话，可能被其他人复制，也可能被张三自己复制，提交到区块链。</p>\n\n<p><strong>如果这句话被两次写入区块链，就意味着张三可以把同一笔钱花掉两次。</strong>但是，第二次写入的时候，查询区块链可以发现张三已经把这笔钱花掉了，从而认定这是不合法的交易，不能写入区块链。因此，复制交易是不可能的。</p>\n\n<p><strong>比较麻烦的是另一种情况，就是张三把同一笔钱付给两个人。</strong>他先向区块链提交一个交易&quot;张三向李四转移了1个比特币&quot;，然后又提交了另一个交易&quot;张三向王五转移了1个比特币&quot;。这两个交易都可能被认为是真实的交易，从而进入区块链。因此，必须有办法防止出现这种情况。</p>\n\n<p>情况一：同一个矿工收到了这两个交易。那么他会察觉到，它们不可能同时成立，因此选择其中的一笔写入区块链。</p>\n\n<p>情况二：矿工 A 收到了第一笔交易，矿工 B 收到了第二笔交易，他们各自都会认定这是合法的交易，分别把这两笔交易写入了两个区块，这时区块链就出现了分叉。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011109.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2267bbc11e5ace556c5b98f1b4ad7f6c1fbe86b1\" alt=\"\" title=\"\"></p>\n\n<p>比特币协议规定，分叉点之后最先达到6个区块的那个分支，被认定为正式的区块链，其他分支都将被放弃。由于区块的生成速度由计算能力决定，所以到底哪一笔交易最后会被写入区块链，完全由它所在的分支能吸引多少计算能力决定。<strong>隐藏的逻辑是，如果大多数人（计算能力）选择相信某一笔交易，那么它就应该是真的。</strong></p>\n\n<p>综上所述，双重支出不可能发生。因为中央记账系统总有办法发现，你把同一笔钱花了两遍。但是，这也说明了比特币的一个代价，就是交易不能实时确认，必须等待至少一个小时。</p>\n\n<h2>八、参考链接</h2>\n\n<ul>\n<li><a href=\"http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/\">How the Bitcoin protocol actually works</a>, by Michael Nielsen</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db3f7e08de9693f72c7251e39f16c1b8504be59b9","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html","sourceType":"blog","time":"2018-01-11 08:02:19"},{"id":10,"name":"比特币入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>比特币（bitcoin）诞生于2008年的一篇<a href=\"https://bitcoin.org/en/bitcoin-paper\">论文</a>。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>一个署名为中本聪的人，提出了革命性的构想：让我们创造一种不受政府或其他任何人控制的货币！这个想法堪称疯狂：一串数字，背后没有任何资产支持，也没有任何人负责，你把它当作钱付给对方，怎么会有人愿意接受？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010401.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D192d0b21725292ffcf4bae7cfcba20094e0ae926\" alt=\"\" title=\"\"></p>\n\n<p>但是，狂想居然变成了现实。随后的几年，在全世界无数爱好者的支持下，比特币网络运行起来了，越来越多的人和资本参与，星星之火，终成燎原。刚刚过去的2017年，比特币迎来了爆发式的增长，从年初的1000美元，最高涨到了2万美元，全世界都为之震动，上到政府，下到普通百姓都在关注。事实就是比特币已经并将继续改变世界。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010402.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8f84b77854fe8dcbbd4d144a68583730bac66c50\" alt=\"\" title=\"\"></p>\n\n<p>新闻媒体往往只关注它的火爆表现，忽视或者无法回答一些基本的问题。</p>\n\n<blockquote>\n  <ul>\n<li>比特币的原理是什么？</li>\n<li>为什么这个无人管理的体系可以成功运作？</li>\n<li>比特币交易的流程是怎么回事？</li>\n<li>它与区块链又是什么关系？</li>\n</ul>\n</blockquote>\n\n<p>下面，我尝试回答这些问题，希望帮助大家理解比特币。抛开技术细节，还是很容易解释的。</p>\n\n<p>有一点说明，本文只讨论技术问题，不涉及如何投资比特币，更不会预测价格走势。事实上，我也不知道，如果我知道怎么发财，可能就不会在这里写博客了。</p>\n\n<h2>一、非对称加密</h2>\n\n<p>首先，理解比特币，必须理解<a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\">非对称加密</a>。</p>\n\n<p>你可能听说过这个词，所谓非对称加密，其实很简单，就是加密和解密需要两把钥匙：一把公钥和一把私钥。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010403.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8927176033349a0ec24b064203ed285d4e79346a\" alt=\"\" title=\"\"></p>\n\n<p>公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息，然后发送给你，你用私钥解密，取出信息。反过来，你也可以用私钥加密信息，别人用你的公钥解开，从而证明这个信息确实是你发出的，且未被篡改，这叫做数字签名（更详细的介绍请看<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">《什么是数字签名》</a>）。</p>\n\n<p>现在请设想，<strong>如果公钥加密的不是普通的信息，而是加密了一笔钱，发送给你，这会怎样？</strong></p>\n\n<p>首先，你能解开加密包，取出里面的钱，因为私钥在你手里。其次，别人偷不走这笔钱，因为他们没有你的私钥。因此，支付可以成功。</p>\n\n<p>这就是比特币（以及其他数字货币）的原理：非对称加密保证了支付的可靠性。</p>\n\n<p>由于支付的钱必须通过私钥取出，所以你是谁并不重要，重要的是谁拥有私钥。只有拥有了私钥，才能取出支付给你的钱。（事实上，真实的交易流程稍有不同，私钥保证的不是取出支付给你的钱，而是保证只有你能把这些属于你的钱支付出去，详见后文。）</p>\n\n<h2>二、比特币钱包</h2>\n\n<p>对于比特币来说，钱不是支付给个人的，而是支付给某一把私钥。这就是交易匿名性的根本原因，因为没有人知道，那些私钥背后的主人是谁。</p>\n\n<p>所以，<strong>比特币交易的第一件事，就是你必须拥有自己的公钥和私钥。</strong></p>\n\n<p>你去网上那些比特币交易所开户，它们会让你首先生成一个比特币钱包（wallet）。<strong>这个钱包不是用来存放比特币，而是存放你的公钥和私钥。</strong>软件会帮你生成这两把钥匙，然后放在钱包里面。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010404.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D405957a9ba4f5aafb59b3bc31da822a42022fdd8\" alt=\"\" title=\"\"></p>\n\n<p>根据协议，公钥的长度是512位。这个长度不太方便传播，因此协议又规定，要为公钥生成一个160位的指纹。所谓指纹，就是一个比较短的、易于传播的哈希值。160位是二进制，写成十六进制，大约是26到35个字符，比如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2。这个字符串就叫做钱包的地址，它是唯一的，即每个钱包的地址肯定都是不一样的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010405.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D14aae41536ab36e5bc2b3695ec4eb1983ed9b796\" alt=\"\" title=\"\"></p>\n\n<p>你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。由于你是这个地址的拥有者，所以你会收到这笔钱。</p>\n\n<p>由于你是否拥有某个钱包地址，是由私钥证明的（具体的证明方法稍后介绍），所以一定要保护好私钥。这是极其重要的，如果你的私钥被偷了，你的比特币也就等于没了，因为他人可以冒用你的身份了，把钱包里面的钱都转走。</p>\n\n<p>同样的，你向他人支付比特币，千万不能写错他人的钱包地址，否则你的比特币就支付到了另一个不同的人了。</p>\n\n<h2>三、交易过程</h2>\n\n<p>下面，我把整个流程串起来，看看比特币如何完成一笔交易。</p>\n\n<p><strong>一笔交易就是一个地址的比特币，转移到另一个地址。</strong>由于比特币的交易记录全部都是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否拥有足够的比特币，完成这笔交易，这是可以轻易验证的。</p>\n\n<p>问题出在怎么防止其他人，冒用你的名义申报交易。举例来说，有人申报了一笔交易：地址 A 向地址 B 支付10个比特币。我怎么知道这个申报是真的，申报人就是地址 A 的主人？</p>\n\n<p>比特币协议规定，申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。</p>\n\n<blockquote>\n  <ul>\n<li>上一笔交易的 Hash（你从哪里得到这些比特币）</li>\n<li>本次交易双方的地址</li>\n<li>支付方的公钥</li>\n<li>支付方的私钥生成的数字签名</li>\n</ul>\n</blockquote>\n\n<p>验证这笔交易是否属实，需要三步。</p>\n\n<blockquote>\n  <p>第一步，找到上一笔交易，确认支付方的比特币来源。</p>\n\n<p>第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。</p>\n\n<p>第三步，使用公钥去解开数字签名，保证私钥属实。</p>\n</blockquote>\n\n<p>经过上面三步，就可以认定这笔交易是真实的。</p>\n\n<h2>四、交易确认与区块链</h2>\n\n<p>确认交易的真实性以后，交易还不算完成。<strong>交易数据必须写入数据库，才算成立，对方才能真正收到钱。</strong></p>\n\n<p>比特币使用的是一种特殊的数据库，叫做区块链（blockchain），详细的介绍请看<a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\">《区块链入门教程》</a>。本文只讨论交易如何写入区块链。</p>\n\n<p>首先，所有的交易数据都会传送到矿工那里。矿工负责把这些交易写入区块链。</p>\n\n<p>根据比特币协议，一个区块的大小最大是 1MB，而一笔交易大概是500字节左右，因此一个区块最多可以包含2000多笔交易。矿工负责把这2000多笔交易打包在一起，组成一个区块，然后计算这个区块的 Hash。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010406.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D811a702b726a25b0beaa4d38273d9652dc5be918\" alt=\"\" title=\"\"></p>\n\n<p>计算 Hash 的过程叫做采矿，这需要大量的计算。矿工之间也在竞争，谁先算出 Hash，谁就能第一个添加新区块进入区块链，从而享受这个区块的全部收益，而其他矿工将一无所获。</p>\n\n<p>一笔交易一旦写入了区块链，就无法反悔了。这里需要建立一个观念：<strong>比特币不存放在钱包或其他别的地方，而是只存在于区块链上面。</strong>区块链记载了你参与的每一笔交易，你得到过多少比特币，你又支付了多少比特币，因此可以算出来你拥有多少资产。</p>\n\n<h2>五、矿工的收益</h2>\n\n<p>交易的确认离不开矿工。为什么有人愿意做矿工呢？</p>\n\n<p>比特币协议规定，挖到新区块的矿工将获得奖励，一开始（2008年）是50个比特币，然后每4年减半，目前（2018年）是12.5个比特币。这也是比特币的供给增加机制，流通中新增的比特币都是这样诞生的。</p>\n\n<p>你可能看出来了，每4年奖励减半，那么到了2140年，矿工将得不到任何奖励，比特币的数量也将停止增加。这时，矿工的收益就完全依靠交易手续费了。</p>\n\n<p>所谓交易手续费，就是矿工可以从每笔交易抽成，具体的金额由支付方自愿决定。你完全可以一毛不拔，一分钱也不给矿工，但是那样的话，你的交易就会没人处理，迟迟无法写入区块链，得到确认。矿工们总是优先处理手续费最高的交易。</p>\n\n<p>目前由于交易数量猛增，手续费已经水涨船高，一个区块2000多笔交易的手续费总额可以达到3～10个比特币。如果你的手续费给低了，很可能过了一个星期，交易还没确认。</p>\n\n<p>一个区块的奖励金12.5个比特币，再加上手续费，收益是相当可观的。按照目前的价格，可以达到100万～200万人民币。想想看，运气好的话，几分钟就能挖到一个区块，拿到这样一大笔钱，怪不得人们对挖矿趋之若鹜。</p>\n\n<h2>六、区块的扩容</h2>\n\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\">《区块链入门教程》</a>说过，比特币协议规定，平均10分钟诞生一个区块。区块的大小只有 1MB，最多只能包含2000多笔交易。也就是说，比特币网络每10分钟，最多只能处理2000多笔交易，换算一下，就是处理速度为3～5笔/秒。</p>\n\n<p>全世界的比特币交易这么多，可是区块链每秒最多只能处理5笔，这已经成为制约比特币发展的一个瓶颈。</p>\n\n<p>很早就有人呼吁，改革比特币协议，提升处理速度。这件事在2017年8月有了一点眉目，当时区块链发生了一次分叉，诞生了一个新协议，称为 <a href=\"https://en.wikipedia.org/wiki/Bitcoin_Cash\">Bitcoin Cash</a>（简称 BCH）。这种新货币其他方面都与比特币一致，就是每个区块的大小从 1MB 增加到了 8MB，因此处理速度提升了8倍，手续费也低得多。该协议是对原有区块链的分叉，因此当时持有比特币的人，等于一人获赠了一份同样数量的 BCH。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010407.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D885f3829b8c7f2e9dec722a9047db4d3d752b058\" alt=\"\" title=\"\"></p>\n\n<p>BCH 等于创造了一种新货币，还有人提议，原始比特币的区块大小提升到 2MB，这称为 <a href=\"https://en.wikipedia.org/wiki/SegWit2x\">SegWit2x</a> 。这个建议原定于2017年11月实施，但是最后一刻由于缺乏共识，就被取消了，目前还在讨论中。</p>\n\n<h2>七、点对点网络</h2>\n\n<p>比特币是一个全世界的开放网络，只要你有服务器，就能加入这个网络，成为一个节点。每个节点都包含了整个区块链（目前大概 100多 GB），并且节点之间时刻不停地在同步信息。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010408.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D779bb8768a71d13edba53994d63b4264698144dc\" alt=\"\" title=\"\"></p>\n\n<p>当你发生了一笔支付，你所在的节点就会把这笔交易告诉另一个节点，直至传遍整个网络。矿工从网上收集各种新发生的交易，将它们打包写入区块链。一旦写入成功，\n矿工所在节点的区块链，就成为最新版本，其他节点都会来复制新增的区块，保证全网的区块链都是一致的。</p>\n\n<p>最后，你所在的节点也拿到了最新的区块链，从而得知你早先的那笔交易，已经写在里面了，至此交易确认成功。</p>\n\n<h2>八、还有一个问题</h2>\n\n<p>写到这里，我就介绍完了比特币的基本知识，希望你已经明白了比特币是怎么回事。但是还有一个根本的问题，我没有回答：比特币的本质到底是什么？</p>\n\n<p>说到底，比特币只是区块链的一条记录，是凭空生成的，为什么可以当钱用？举例来说，矿工获得12.5个比特币的奖励，其实就是区块链有一个记录：&quot;xxx地址获得12.5个比特币&quot;。正是这行记录，导致该矿工获得了大笔金钱。如果区块链突然增加了一条记录，记载你的地址获得了1000个比特币，你就真的会有1000个比特币。这到底是为什么？</p>\n\n<p>这篇文章已经够长了，这个问题就留到下次再谈，欢迎关注本系列的最后一篇文章<a href=\"http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html\">《加密货币的本质》</a>。</p>\n\n<h2>九、参考链接</h2>\n\n<ul>\n<li><a href=\"https://arstechnica.com/tech-policy/2017/12/how-bitcoin-works/\">How Bitcoin works</a> , by Timothy B. Lee</li>\n<li><a href=\"http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html\">Bitcoins the hard way: Using the raw Bitcoin protocol</a>, by Ken Shirriff</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010401.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D192d0b21725292ffcf4bae7cfcba20094e0ae926","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html","sourceType":"blog","time":"2018-01-04 08:07:10"},{"id":11,"name":"区块链入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>区块链（blockchain）是眼下的大热门，新闻媒体大量报道，宣称它将创造未来。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>可是，简单易懂的入门文章却很少。区块链到底是什么，有何特别之处，很少有解释。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc1e104bfb2b10e7bdbacdd893d9af9165a95361a\" alt=\"\" title=\"\"></p>\n\n<p>下面，我就来尝试，写一篇最好懂的区块链教程。毕竟它也不是很难的东西，核心概念非常简单，几句话就能说清楚。我希望读完本文，你不仅可以理解区块链，还会明白什么是挖矿、为什么挖矿越来越难等问题。</p>\n\n<p>需要说明的是，我并非这方面的专家。虽然很早就关注，但是仔细地了解区块链，还是从今年初开始。文中的错误和不准确的地方，欢迎大家指正。</p>\n\n<h2>一、区块链的本质</h2>\n\n<p>区块链是什么？一句话，它是一种特殊的分布式数据库。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122702.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df65fb5236238c65ebcbe1fb2af3031028e1e92c5\" alt=\"\" title=\"\"></p>\n\n<p>首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。</p>\n\n<p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p>\n\n<h2>二、区块链的最大特点</h2>\n\n<p>分布式数据库并非新发明，市场上早有此类产品。但是，区块链有一个革命性特点。</p>\n\n<p><strong>区块链没有管理员，它是彻底无中心的。</strong>其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p>\n\n<p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者就都必须听命于他们了。</p>\n\n<p>但是，没有了管理员，人人都可以往里面写入数据，怎么才能保证数据是可信的呢？被坏人改了怎么办？请接着往下读，这就是区块链奇妙的地方。</p>\n\n<h2>三、区块</h2>\n\n<p>区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122703.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da0bf9485b011e641fbef1e2af1f418e05afc8b5d\" alt=\"\" title=\"\"></p>\n\n<p>每个区块包含两个部分。</p>\n\n<blockquote>\n  <ul>\n<li>区块头（Head）：记录当前区块的特征值</li>\n<li>区块体（Body）：实际数据</li>\n</ul>\n</blockquote>\n\n<p>区块头包含了当前区块的多项特征值。</p>\n\n<blockquote>\n  <ul>\n<li>生成时间</li>\n<li>实际数据（即区块体）的哈希</li>\n<li>上一个区块的哈希</li>\n<li>...</li>\n</ul>\n</blockquote>\n\n<p>这里，你需要理解什么叫<a href=\"https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%80%BC\">哈希</a>（hash），这是理解区块链必需的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122704.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df7d6b0bfaba52e2f8f05883e12fa9cf008a1dff3\" alt=\"\" title=\"\"></p>\n\n<p>所谓&quot;哈希&quot;就是计算机可以对任意内容，计算出一个长度相同的特征值。区块链的 哈希长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的哈希一定是不同的。</p>\n\n<p>举例来说，字符串<code>123</code>的哈希是<code>a8fdc205a9f19cc1c7507a60c4f01b13d11d7fd0</code>（十六进制），转成二进制就是256位，而且只有<code>123</code>能得到这个哈希。（理论上，其他字符串也有可能得到这个哈希，但是概率极低，可以近似认为不可能发生。）</p>\n\n<p>因此，就有两个重要的推论。</p>\n\n<blockquote>\n  <ul>\n<li>推论1：每个区块的哈希都是不一样的，可以通过哈希标识区块。</li>\n<li>推论2：如果区块的内容变了，它的哈希一定会改变。</li>\n</ul>\n</blockquote>\n\n<h2>四、 Hash 的不可修改性</h2>\n\n<p>区块与哈希是一一对应的，每个区块的哈希都是针对&quot;区块头&quot;（Head）计算的。也就是说，把区块头的各项特征值，按照顺序连接在一起，组成一个很长的字符串，再对这个字符串计算哈希。</p>\n\n<blockquote>\n  <p>Hash = SHA256( 区块头 )</p>\n</blockquote>\n\n<p>上面就是区块哈希的计算公式，<code>SHA256</code>是区块链的哈希算法。注意，这个公式里面只包含区块头，不包含区块体，也就是说，哈希由区块头唯一决定，</p>\n\n<p>前面说过，区块头包含很多内容，其中有当前区块体的哈希，还有上一个区块的哈希。这意味着，如果当前区块体的内容变了，或者上一个区块的哈希变了，一定会引起当前区块的哈希改变。</p>\n\n<p>这一点对区块链有重大意义。如果有人修改了一个区块，该区块的哈希就变了。为了让后面的区块还能连到它（因为下一个区块包含上一个区块的哈希），该人必须依次修改后面所有的区块，否则被改掉的区块就脱离区块链了。由于后面要提到的原因，哈希的计算很耗时，短时间内修改多个区块几乎不可能发生，除非有人掌握了全网51%以上的计算能力。</p>\n\n<p>正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。这就像历史一样，发生了就是发生了，从此再无法改变。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122705.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D88458354bb8275ce3ef84a5861799bc1bbfddad6\" alt=\"\" title=\"\"></p>\n\n<p>每个区块都连着上一个区块，这也是&quot;区块链&quot;这个名字的由来。</p>\n\n<h2>五、采矿</h2>\n\n<p>由于必须保证节点之间的同步，所以新区块的添加速度不能太快。试想一下，你刚刚同步了一个区块，准备基于它生成下一个区块，但这时别的节点又有新区块生成，你不得不放弃做了一半的计算，再次去同步。因为每个区块的后面，只能跟着一个区块，你永远只能在最新区块的后面，生成下一个区块。所以，你别无选择，一听到信号，就必须立刻同步。</p>\n\n<p>所以，区块链的发明者中本聪（这是假名，真实身份至今未知）故意让添加新区块，变得很困难。他的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。</p>\n\n<p>这种产出速度不是通过命令达成的，而是故意设置了海量的计算。也就是说，只有通过极其大量的计算，才能得到当前区块的有效哈希，从而把新区块添加到区块链。由于计算量太大，所以快不起来。</p>\n\n<p>这个过程就叫做采矿（mining），因为计算有效哈希的难度，好比在全世界的沙子里面，找到一粒符合条件的沙子。计算哈希的机器就叫做矿机，操作矿机的人就叫做矿工。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122706.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6c8963a82f91110599ca8b4296caed74b9875901\" alt=\"\" title=\"\"></p>\n\n<h2>六、难度系数</h2>\n\n<p>读到这里，你可能会有一个疑问，人们都说采矿很难，可是采矿不就是用计算机算出一个哈希吗，这正是计算机的强项啊，怎么会变得很难，迟迟算不出来呢？</p>\n\n<p>原来不是任意一个哈希都可以，只有满足条件的哈希才会被区块链接受。这个条件特别苛刻，使得绝大部分哈希都不满足要求，必须重算。</p>\n\n<p>原来，区块头包含一个<a href=\"http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html\">难度系数</a>（difficulty），这个值决定了计算哈希的难度。举例来说，<a href=\"https://blockexplorer.com/block/000000000003ba27aa200b1cecaad478d2b00432346c3f1f3986da1afd33e506\">第100000个区块</a>的难度系数是 14484.16236122。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122707.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2d58d66d88c7fe1b998b2246b8fec6761424b12c\" alt=\"\" title=\"\"></p>\n\n<p>区块链协议规定，使用一个常量除以难度系数，可以得到目标值（target）。显然，难度系数越大，目标值就越小。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122708.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dbebfecfbee1e5245a7c29e04f9f026d1db5f5b6d\" alt=\"\" title=\"\"></p>\n\n<p>哈希的有效性跟目标值密切相关，只有小于目标值的哈希才是有效的，否则哈希无效，必须重算。由于目标值非常小，哈希小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。</p>\n\n<p>前面说过，当前区块的哈希由区块头唯一决定。如果要对同一个区块反复计算哈希，就意味着，区块头必须不停地变化，否则不可能算出不一样的哈希。区块头里面所有的特征值都是固定的，为了让区块头产生变化，中本聪故意增加了一个随机项，叫做 Nonce。</p>\n\n<p>Nonce 是一个随机值，矿工的作用其实就是猜出 Nonce 的值，使得区块头的哈希可以小于目标值，从而能够写入区块链。Nonce 是非常难猜的，目前只能通过穷举法一个个试错。根据协议，Nonce 是一个32位的二进制值，即最大可以到21.47亿。第 100000 个区块的 Nonce 值是<code>274148111</code>，可以理解成，矿工从0开始，一直计算了 2.74 亿次，才得到了一个有效的 Nonce 值，使得算出的哈希能够满足条件。</p>\n\n<p>运气好的话，也许一会就找到了 Nonce。运气不好的话，可能算完了21.47亿次，都没有发现 Nonce，即当前区块体不可能算出满足条件的哈希。这时，协议允许矿工改变区块体，开始新的计算。</p>\n\n<h2>七、难度系数的动态调节</h2>\n\n<p>正如上一节所说，采矿具有随机性，没法保证正好十分钟产出一个区块，有时一分钟就算出来了，有时几个小时可能也没结果。总体来看，随着硬件设备的提升，以及矿机的数量增长，计算速度一定会越来越快。</p>\n\n<p>为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此接下来的难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此接下来的难度系数就要调低10%。</p>\n\n<p>难度系数越调越高（目标值越来越小），导致了采矿越来越难。</p>\n\n<h2>八、区块链的分叉</h2>\n\n<p>即使区块链是可靠的，现在还有一个问题没有解决：如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122709.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D93f40ae9d8077b30613e58144316514ac3274181\" alt=\"\" title=\"\"></p>\n\n<p>现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为&quot;六次确认&quot;）。按照10分钟一个区块计算，一小时就可以确认。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122710.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df63a5c4f1fea9db6c176a8f75d5d457b7cf54a2e\" alt=\"\" title=\"\"></p>\n\n<p>由于新区块的生成速度由计算能力决定，所以这条规则就是说，拥有大多数计算能力的那条分支，就是正宗的区块链。</p>\n\n<h2>九、总结</h2>\n\n<p>区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。</p>\n\n<p>但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。</p>\n\n<p>因此，区块链的适用场景，其实非常有限。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>不存在所有成员都信任的管理当局</li>\n<li>写入的数据不要求实时使用</li>\n<li>挖矿的收益能够弥补本身的成本</li>\n</ol>\n</blockquote>\n\n<p>如果无法满足上述的条件，那么传统的数据库是更好的解决方案。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122711.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D50a5f43fbd501fc5bc77ebb35a63cb56b143b8c8\" alt=\"\" title=\"\"></p>\n\n<p>目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币。下一篇文章，我将会介绍<a href=\"http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html\">比特币的入门知识</a>。</p>\n\n<h2>十、参考链接</h2>\n\n<ul>\n<li><a href=\"https://medium.freecodecamp.org/how-does-blockchain-really-work-i-built-an-app-to-show-you-6b70cd4caf7d\">How does blockchain really work?</a>, by Sean Han</li>\n<li><a href=\"http://www.righto.com/2014/02/bitcoin-mining-hard-way-algorithms.html\">Bitcoin mining the hard way: the algorithms, protocols, and bytes</a>, by Ken Shirriff</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017122701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc1e104bfb2b10e7bdbacdd893d9af9165a95361a","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html","sourceType":"blog","time":"2017-12-26 20:40:00"},{"id":12,"name":"持续集成服务 Travis CI 教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>编写代码只是软件开发的一小部分，更多的时间往往花在构建（build）和测试（test）。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>为了提高软件开发的效率，构建和测试的自动化工具层出不穷。<a href=\"https://travis-ci.org/\">Travis CI</a> 就是这类工具之中，<a href=\"https://github.com/blog/2463-github-welcomes-all-ci-tools\">市场份额</a>最大的一个。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Deaf67829e2ad65f46a1dff6ae42ea1bcaae0f0ec\" alt=\"\" title=\"\"></p>\n\n<p>本文介绍 Travis CI 的基本用法。用好这个工具不仅可以提高效率，还能使开发流程更可靠和专业化，从而提高软件的价值。而且，它对于开源项目是免费的，不花一分钱，就能帮你做掉很多事情。</p>\n\n<h2>一、什么是持续集成？</h2>\n\n<p>Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。</p>\n\n<p>持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码&quot;集成&quot;到主干。</p>\n\n<p>持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p>\n\n<h2>二、使用准备</h2>\n\n<p>Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。</p>\n\n<blockquote>\n  <ul>\n<li>拥有 GitHub 帐号</li>\n<li>该帐号下面有一个项目</li>\n<li>该项目里面有可运行的代码</li>\n<li>该项目还包含构建或测试脚本</li>\n</ul>\n</blockquote>\n\n<p>如果这些条件都没问题，就可以开始使用 Travis CI 了。</p>\n\n<p>首先，访问官方网站 <a href=\"https://travis-ci.org/\">travis-ci.org</a>，点击右上角的个人头像，使用 Github 账户登入 Travis CI。</p>\n\n<p>Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121902.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D31dca175941d6e73d59d4dd150b458d75935c183\" alt=\"\" title=\"\"></p>\n\n<h2>三、.travis.yml</h2>\n\n<p>Travis 要求项目的根目录下面，必须有一个<code>.travis.yml</code>文件。这是配置文件，指定了 Travis 的行为。该文件必须保存在 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。</p>\n\n<p>这个文件采用 <a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\">YAML</a> 格式。下面是一个最简单的 Python 项目的<code>.travis.yml</code>文件。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nlanguage: python\nscript: true\n</code></pre></blockquote>\n\n<p>上面代码中，设置了两个字段。<code>language</code>字段指定了默认运行环境，这里设定使用 Python 环境。<code>script</code>字段指定要运行的脚本，<code>script: true</code>表示不执行任何脚本，状态直接设为成功。</p>\n\n<p>Travis 默认提供的运行环境，请参考<a href=\"https://docs.travis-ci.com/user/languages\">官方文档</a> 。目前一共支持31种语言，以后还会不断增加。</p>\n\n<p>下面是一个稍微复杂一点的<code>.travis.yml</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nlanguage: python\nsudo: required\nbefore_install: sudo pip install foo\nscript: py.test\n</code></pre></blockquote>\n\n<p>上面代码中，设置了四个字段：运行环境是 Python，需要<code>sudo</code>权限，在安装依赖之前需要安装<code>foo</code>模块，然后执行脚本<code>py.test</code>。</p>\n\n<h2>四、运行流程</h2>\n\n<p>Travis 的运行流程很简单，任何项目都会经过两个阶段。</p>\n\n<blockquote>\n  <ul>\n<li>install 阶段：安装依赖</li>\n<li>script 阶段：运行脚本</li>\n</ul>\n</blockquote>\n\n<h3>4.1 install 字段</h3>\n\n<p><code>install</code>字段用来指定安装脚本。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\ninstall: ./install-dependencies.sh\n</code></pre></blockquote>\n\n<p>如果有多个脚本，可以写成下面的形式。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\ninstall:\n  - command1\n  - command2\n</code></pre></blockquote>\n\n<p>上面代码中，如果<code>command1</code>失败了，整个构建就会停下来，不再往下进行。</p>\n\n<p>如果不需要安装，即跳过安装阶段，就直接设为<code>true</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\ninstall: true\n</code></pre></blockquote>\n\n<h3>4.2、script 字段</h3>\n\n<p><code>script</code>字段用来指定构建或测试脚本。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nscript: bundle exec thor build\n</code></pre></blockquote>\n\n<p>如果有多个脚本，可以写成下面的形式。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nscript:\n  - command1\n  - command2\n</code></pre></blockquote>\n\n<p>注意，<code>script</code>与<code>install</code>不一样，如果<code>command1</code>失败，<code>command2</code>会继续执行。但是，整个构建阶段的状态是失败。</p>\n\n<p>如果<code>command2</code>只有在<code>command1</code>成功后才能执行，就要写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nscript: command1 &amp;&amp; command2\n</code></pre></blockquote>\n\n<h3>4.3 实例：Node 项目</h3>\n\n<p>Node 项目的环境需要写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nlanguage: node_js\nnode_js:\n  - &quot;8&quot;\n</code></pre></blockquote>\n\n<p>上面代码中，<code>node_js</code>字段用来指定 Node 版本。</p>\n\n<p>Node 项目的<code>install</code>和<code>script</code>阶段都有默认脚本，可以省略。</p>\n\n<blockquote>\n  <ul>\n<li><code>install</code>默认值：npm install</li>\n<li><code>script</code>默认值：npm test</li>\n</ul>\n</blockquote>\n\n<p>更多设置请看<a href=\"https://docs.travis-ci.com/user/languages/javascript-with-nodejs/\">官方文档</a>。</p>\n\n<h3>4.4 部署</h3>\n\n<p><code>script</code>阶段结束以后，还可以设置<a href=\"https://docs.travis-ci.com/user/notifications/\">通知步骤</a>（notification）和<a href=\"https://docs.travis-ci.com/user/deployment/\">部署步骤</a>（deployment），它们不是必须的。</p>\n\n<p>部署的脚本可以在<code>script</code>阶段执行，也可以使用 Travis 为几十种常见服务提供的快捷部署功能。比如，要部署到 <a href=\"https://docs.travis-ci.com/user/deployment/pages/\">Github Pages</a>，可以写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\ndeploy:\n  provider: pages\n  skip_cleanup: true\n  github_token: $GITHUB_TOKEN # Set in travis-ci.org dashboard\n  on:\n    branch: master\n</code></pre></blockquote>\n\n<p>其他部署方式，请看<a href=\"https://docs.travis-ci.com/user/deployment/\">官方文档</a>。</p>\n\n<h3>4.5 钩子方法</h3>\n\n<p>Travis 为上面这些阶段提供了7个钩子。</p>\n\n<blockquote>\n  <ul>\n<li>before_install：install 阶段之前执行</li>\n<li>before_script：script 阶段之前执行</li>\n<li>after_failure：script 阶段失败时执行</li>\n<li>after_success：script 阶段成功时执行</li>\n<li>before_deploy：deploy 步骤之前执行</li>\n<li>after_deploy：deploy 步骤之后执行</li>\n<li>after_script：script 阶段之后执行</li>\n</ul>\n</blockquote>\n\n<p>完整的生命周期，从开始到结束是下面的流程。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>before_install</li>\n<li>install</li>\n<li>before_script</li>\n<li>script</li>\n<li>after<em>success or after</em>failure</li>\n<li>[OPTIONAL] before_deploy</li>\n<li>[OPTIONAL] deploy</li>\n<li>[OPTIONAL] after_deploy</li>\n<li>after_script</li>\n</ol>\n</blockquote>\n\n<p>下面是一个<code>before_install</code>钩子的例子。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nbefore_install:\n  - sudo apt-get -qq update\n  - sudo apt-get install -y libxml2-dev\n</code></pre></blockquote>\n\n<p>上面代码表示<code>before_install</code>阶段要做两件事，第一件事是要更新依赖，第二件事是安装<code>libxml2-dev</code>。用到的几个参数的含义如下：<code>-qq</code>表示减少中间步骤的输出，<code>-y</code>表示如果需要用户输入，总是输入<code>yes</code>。</p>\n\n<h3>4.6 运行状态</h3>\n\n<p>最后，Travis 每次运行，可能会返回四种状态。</p>\n\n<blockquote>\n  <ul>\n<li>passed：运行成功，所有步骤的退出码都是<code>0</code></li>\n<li>canceled：用户取消执行</li>\n<li>errored：<code>before_install</code>、<code>install</code>、<code>before_script</code>有非零退出码，运行会立即停止</li>\n<li>failed ：<code>script</code>有非零状态码 ，会继续运行</li>\n</ul>\n</blockquote>\n\n<h2>五、使用技巧</h2>\n\n<h3>5.1 环境变量</h3>\n\n<p><code>.travis.yml</code>的<code>env</code>字段可以定义环境变量。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nenv:\n  - DB=postgres\n  - SH=bash\n  - PACKAGE_VERSION=&quot;1.0.*&quot;\n</code></pre></blockquote>\n\n<p>然后，脚本内部就使用这些变量了。</p>\n\n<p>有些环境变量（比如用户名和密码）不能公开，这时可以通过 Travis 网站，写在每个仓库的设置页里面，Travis 会自动把它们加入环境变量。这样一来，脚本内部依然可以使用这些环境变量，但是只有管理员才能看到变量的值。具体操作请看<a href=\"https://docs.travis-ci.com/user/environment-variables\">官方文档</a>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121903.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2f774b6e7ebe934a77ea1c6e4b15de5f37236bf4\" alt=\"\" title=\"\"></p>\n\n<h3>5.2 加密信息</h3>\n\n<p>如果不放心保密信息明文存在 Travis 的网站，可以使用 Travis 提供的加密功能。</p>\n\n<p>首先，安装 Ruby 的包<code>travis</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ gem install travis\n</code></pre></blockquote>\n\n<p>然后，就可以用<code>travis encrypt</code>命令加密信息。</p>\n\n<p>在项目的根目录下，执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ travis encrypt SOMEVAR=secretvalue\n</code></pre></blockquote>\n\n<p>上面命令中，<code>SOMEVAR</code>是要加密的变量名，<code>secretvalue</code>是要加密的变量值。执行以后，屏幕上会输出如下信息。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nsecure: &quot;.... encrypted data ....&quot;\n</code></pre></blockquote>\n\n<p>现在，就可以把这一行加入<code>.travis.yml</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nenv:\n  global:\n    - secure: &quot;.... encrypted data ....&quot;\n</code></pre></blockquote>\n\n<p>然后，脚本里面就可以使用环境变量<code>$SOMEVAR</code>了，Travis 会在运行时自动对它解密。</p>\n\n<p><code>travis encrypt</code>命令的<code>--add</code>参数会把输出自动写入<code>.travis.yml</code>，省掉了修改<code>env</code>字段的步骤。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ travis encrypt SOMEVAR=secretvalue --add\n</code></pre></blockquote>\n\n<p>详细信息请看<a href=\"https://docs.travis-ci.com/user/encryption-keys/\">官方文档</a>。</p>\n\n<h3>5.3 加密文件</h3>\n\n<p>如果要加密的是文件（比如私钥），Travis 提供了加密文件功能。</p>\n\n<p>安装命令行客户端以后，使用下面的命令登入 Travis CI。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ travis login \n</code></pre></blockquote>\n\n<p>然后，进入项目的根目录，使用<code>travis encrypt-file</code>命令加密那些想要加密的文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ travis encrypt-file bacon.txt\n\nencrypting bacon.txt for rkh/travis-encrypt-file-example\nstoring result as bacon.txt.enc\nstoring secure env variables for decryption\n\nPlease add the following to your build script (before_install stage in your .travis.yml, for instance):\n\n    openssl aes-256-cbc -K $encrypted_0a6446eb3ae3_key -iv $encrypted_0a6446eb3ae3_key -in bacon.txt.enc -out bacon.txt -d\n\nPro Tip: You can add it automatically by running with --add.\n\nMake sure to add bacon.txt.enc to the git repository.\nMake sure not to add bacon.txt to the git repository.\nCommit all changes to your .travis.yml.\n</code></pre></blockquote>\n\n<p>上面的代码对文件<code>bacon.txt</code>进行加密，加密后会生成<code>bacon.txt.enc</code>，该文件需要提交到代码库。此外，该命令还会生成一个环境变量<code>$encrypted_0a6446eb3ae3_key</code>，保存密钥，储存在 Travis CI，文件解密时需要这个环境变量。你需要把解密所需的<code>openssl</code>命令，写在<code>.travis.yml</code>的<code>before_install</code>字段里面。这些都写在上面的命令行提示里面。</p>\n\n<p><code>--add</code>参数可以自动把环境变量写入<code>.travis.yml</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ travis encrypt-file bacon.txt --add\n\nencrypting bacon.txt for rkh/travis-encrypt-file-example\nstoring result as bacon.txt.enc\nstoring secure env variables for decryption\n\nMake sure to add bacon.txt.enc to the git repository.\nMake sure not to add bacon.txt to the git repository.\nCommit all changes to your .travis.yml.\n</code></pre></blockquote>\n\n<p>详细信息请看<a href=\"https://docs.travis-ci.com/user/encrypting-files/\">官方文档</a>，实际的例子可以参考下面两篇文章。</p>\n\n<blockquote>\n  <ul>\n<li><a href=\"https://gist.github.com/domenic/ec8b0fc8ab45f39403dd\">Auto-deploying built products to gh-pages with Travis</a></li>\n<li><a href=\"https://oncletom.io/2016/travis-ssh-deploy/\">SSH deploys with Travis CI</a></li>\n</ul>\n</blockquote>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Deaf67829e2ad65f46a1dff6ae42ea1bcaae0f0ec","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html","sourceType":"blog","time":"2017-12-19 20:09:02"},{"id":13,"name":"图像与滤波","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>我对图像处理一直很感兴趣，曾经写过好几篇博客（<a href=\"http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html\">1</a>，<a href=\"http://www.ruanyifeng.com/blog/2013/03/similar_image_search_part_ii.html\">2</a>，<a href=\"http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html\">3</a>，<a href=\"http://www.ruanyifeng.com/blog/2016/07/edge-recognition.html\">4</a>）。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>前几天读到一篇<a href=\"https://medium.com/statuscode/filtering-images-using-web-audio-api-276555cca6ad\">文章</a>，它提到<strong>图像其实是一种波，可以用波的算法处理图像</strong>。我顿时有一种醍醐灌顶的感觉，从没想到这两个领域是相关的，图像还可以这样玩！下面我就来详细介绍这篇文章。</p>\n\n<h2>一、为什么图像是波？</h2>\n\n<p>我们知道，图像由像素组成。下图是一张 400 x 400 的图片，一共包含了 16 万个像素点。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Ddf152b98ee5b9d2a3743306a24ab6c69ec5a60a2\" alt=\"\" title=\"\"></p>\n\n<p>每个像素的颜色，可以用红、绿、蓝、透明度四个值描述，大小范围都是<code>0 ～ 255</code>，比如黑色是<code>[0, 0, 0, 255]</code>，白色是<code>[255, 255, 255, 255]</code>。通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas\">Canvas API</a> 就可以拿到这些值。</p>\n\n<p>如果把每一行所有像素（上例是400个）的红、绿、蓝的值，依次画成三条曲线，就得到了下面的图形。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121302.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7144dc06a360372b1dbca6d881a3f2968495e05d\" alt=\"\" title=\"\"></p>\n\n<p>可以看到，每条曲线都在不停的上下波动。有些区域的波动比较小，有些区域突然出现了大幅波动（比如 54 和 324 这两点）。</p>\n\n<p>对比一下图像就能发现，曲线波动较大的地方，也是图像出现突变的地方。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D58d8e1a509bc326c23836649d598e84c6bafaa74\" alt=\"\" title=\"\"></p>\n\n<p>这说明波动与图像是紧密关联的。<strong>图像本质上就是各种色彩波的叠加。</strong></p>\n\n<h2>二、频率</h2>\n\n<p>综上所述，图像就是色彩的波动：波动大，就是色彩急剧变化；波动小，就是色彩平滑过渡。因此，波的各种指标可以用来描述图像。</p>\n\n<p>频率（frequency）是波动快慢的指标，单位时间内波动次数越多，频率越高，反之越低。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D67be0bf1f1530f400f35acccd1b4a73d0bdce0f1\" alt=\"\" title=\"\"></p>\n\n<p>上图是函数<code>sin(Θ)</code>的图形，在<code>2π</code>的周期内完成了一次波动，频率就是1。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121304.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1eb6a9044c7b64a6d1f4d9ecc33528f0d66e8909\" alt=\"\" title=\"\"></p>\n\n<p>上图是函数<code>sin(2Θ)</code>的图形，在<code>2π</code>的周期内完成了两次波动，频率就是2。</p>\n\n<p>所以，<strong>色彩剧烈变化的地方，就是图像的高频区域；色彩稳定平滑的地方，就是低频区域。</strong></p>\n\n<h2>三、滤波器</h2>\n\n<p>物理学对波的研究已经非常深入，提出了很多处理波的方法，其中就有滤波器（filter）：过滤掉某些波，保留另一些波。</p>\n\n<p>下面是两种常见的滤波器 。</p>\n\n<blockquote>\n  <ul>\n<li><a href=\"https://baike.baidu.com/item/%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2\">低通滤波器</a>（lowpass）：减弱或阻隔高频信号，保留低频信号</li>\n<li><a href=\"https://baike.baidu.com/item/%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2\">高通滤波器</a>（highpass）：减弱或阻隔低频信号，保留高频信号</li>\n</ul>\n</blockquote>\n\n<p>下面是低通滤波的例子。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121306.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4edc87460c5a331d2b40306cc129bab1a3c45635\" alt=\"\" title=\"\"></p>\n\n<p>上图中，蓝线是原始的波形，绿线是低通滤波<code>lowpass</code>后的波形。可以看到，绿线的波动比蓝线小很多，非常平滑。</p>\n\n<p>下面是高通滤波的例子。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121307.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Daa67e8e856186da82153b2314fbc85bd7be542dc\" alt=\"\" title=\"\"></p>\n\n<p>上图中，黄线是原始的波形，蓝线是高通滤波<code>highpass</code>后的波形。可以看到，黄线的三个波峰和两个波谷（低频波动），在蓝线上都消失了，而黄线上那些密集的小幅波动（高频波动），则是全部被蓝线保留。</p>\n\n<p>再看一个<a href=\"https://stackoverflow.com/questions/7105962/how-do-i-run-a-high-pass-or-low-pass-filter-on-data-points-in-r\">例子</a>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121308.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dcc767cd2f3621d05caa5492139ab5707975075cc\" alt=\"\" title=\"\"></p>\n\n<p>上图有三根曲线，黄线是高频波动，红线是低频波动。它们可以合成为一根曲线，就是绿线。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121309.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfc895a000df78dd55e490a50914fd7c19c977259\" alt=\"\" title=\"\"></p>\n\n<p>上图中，绿线进行低通滤波和高通滤波后，得到两根黑色的曲线，它们的波形跟原始的黄线和红线是完全一致的。</p>\n\n<h2>四、图像的滤波</h2>\n\n<p>浏览器实际上包含了滤波器的实现，因为 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API\">Web Audio API</a> 里面定义了<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/type\">声波的滤波</a>。这意味着可以通过浏览器，将<code>lowpass</code>和<code>highpass</code>运用于图像。</p>\n\n<p><code>lowpass</code>使得图像的高频区域变成低频，即色彩变化剧烈的区域变得平滑，也就是出现模糊效果。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121310.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dcdb2a845f3d3278cf1bb2be8e56dac3ef51716be\" alt=\"\" title=\"\"></p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121311.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D784f4d260fd12326c4dca6a2c3b1170fce33745b\" alt=\"\" title=\"\"></p>\n\n<p>上图中，红线是原始的色彩曲线，蓝线是低通滤波后的曲线。</p>\n\n<p><code>highpass</code>正好相反，过滤了低频，只保留那些变化最快速最剧烈的区域，也就是图像里面的物体边缘，所以常用于边缘识别。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121312.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df4bd00a155ee229aa30794d61c733a483f60d718\" alt=\"\" title=\"\"></p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121313.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec1bf9840a088035d93f9980430aa853efcf9b8d\" alt=\"\" title=\"\"></p>\n\n<p>上图中，红线是原始的色彩曲线，蓝线是高通滤波后的曲线。</p>\n\n<p>下面这个<a href=\"http://fellipe.com/demos/lena-js/\">网址</a>，可以将滤波器拖到图像上，产生过滤后的效果。</p>\n\n<p><a href=\"http://fellipe.com/demos/lena-js/\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121314.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De9bd4d16c7ea72306410392759114332ef33bbfd\" alt=\"\" title=\"\"></a></p>\n\n<p>浏览器实现滤波的范例代码，可以看这个<a href=\"https://github.com/rssilva/web-audio-image-filtering\">仓库</a>。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017121301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Ddf152b98ee5b9d2a3743306a24ab6c69ec5a60a2","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/12/image-and-wave-filters.html","sourceType":"blog","time":"2017-12-13 08:16:08"},{"id":14,"name":"北方的空地","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>最近有一部电影<a href=\"https://movie.douban.com/subject/26426026/\">《77天》</a>，讲述一个探险者在荒原独自旅行的故事。 </p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120201.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da640a9277bbf359d00cd48e7a4e3474c2c4405ef\" alt=\"\" title=\"\"></p>\n\n<p>我以为电影是虚构的，没想到改编自真人真事。2010年，一个名叫<a href=\"https://baike.baidu.com/item/%E6%9D%A8%E6%9F%B3%E6%9D%BE/7055298\">杨柳松</a>的青年，徒步穿越羌塘，1400公里的无人区，平均海拔5000米，走了77天。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120202.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D5c4ebeae7ccac2aed44bf4d81858388617d33171\" alt=\"\" title=\"\"></p>\n\n<p>他把这段经历，写成了一本书<a href=\"https://baike.baidu.com/item/%E5%8C%97%E6%96%B9%E7%9A%84%E7%A9%BA%E5%9C%B0\">《北方的空地》</a>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120203.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfc1eb0e8501125333b39229e31c4b93ba802ae53\" alt=\"\" title=\"\"></p>\n\n<p>我读了，越读越佩服。这完全不是普通的冒险，跟川藏线的骑行是两个概念。不仅仅需要勇气和意志，还需要广博的知识，以及准确的现场判断，一个决定错误可能就会送命了。我惊叹，杨柳松是什么人啊，怎么知道这么多？！</p>\n\n<p>电影《77天》挺一般的，可以不看。但是，热爱旅行和大自然的朋友都应该读一下这本书。它的雏形是杨柳松发在8624论坛的一个<a href=\"http://bbs.8264.com/thread-512349-1-1.html\">长篇连载</a>，现在还能读到。</p>\n\n<h2>一、羌塘</h2>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120204.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8eadbcfb697f8b62ab1d03815f1625d05ad88321\" alt=\"\" title=\"\"></p>\n\n<p>杨柳松穿越的羌塘位于西藏的北部，藏语的意思是&quot;北方的未知之地&quot;。它的北面是昆仑山脉和可可西里山脉，南面是冈底斯山脉和念青唐古拉山脉，属于高山之间的一块高原盆地。</p>\n\n<blockquote>\n  <p>......南北最宽760公里，东西长约1200公里。面积59.70万平方公里，占青藏高原总面积的1/4。 行政上属西藏自治区的那曲与阿里两地区管辖。</p>\n</blockquote>\n\n<p>羌塘高原日照强烈，天气变化无常，风力强劲，十一级大风是家常便饭。冬季极寒缺水，雨季沼泽遍布，是地球上最大的无人区之一。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120205.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D236d6b85b5c020d822cc5ba5a6cef73720747ae1\" alt=\"\" title=\"\"></p>\n\n<p>（图片说明：杨柳松的实际路线）</p>\n\n<p>没有后援，没有补给，与外界断绝联系，几十天不遇人，一个人徒步横穿羌塘，谈何容易。此前，还没有人完成过。</p>\n\n<blockquote>\n  <p>最大困惑有三个方面。一是食物补给，在如此长的天数里完全靠自给确无先例，我到底能承受怎样的饥饿状态？二是体能，在海拔五千米的恶劣环境中超负重推行能坚持多久？三是心理状态，孤身荒原中，面对周而复始的困顿何以应对？</p>\n</blockquote>\n\n<p>由于太多天没有消息，杨柳松的朋友都以为他遇难了。2014年，<a href=\"http://www.doyouhike.net/forum/safety/2372479,0,0,0.html\">另一个网友</a>沿着这条路线进入羌塘，就失踪了，没有走出来。</p>\n\n<h2>二、物资准备</h2>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120212.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D586044121d1992ef07630c07f0a8b11b12907cbb\" alt=\"\" title=\"\"></p>\n\n<p>1400公里的路程，预计80天左右完成，平均每天推进20公里左右。</p>\n\n<blockquote>\n  <p>我必须达到均速二十公里才有可能完成计划中的旅行。二十公里是理想值，比较安全。但算上大雪封路、地貌巨糟、无端生病、洪水卷地、偷懒睡觉、外星人突访等事件，所以每天行距必须超过二十公里才稳妥。十八公里是危险值，最低均速，底线，咬咬牙能接受。低于十八公里，马克思会很想念我。回顾，在遇人救助前的七十五天独行中，每天均速差那么一点到十八公里，悬而又悬的速度。</p>\n</blockquote>\n\n<p>20公里看上去并不快，但不要忘记这是在5000米的高原。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120231.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D53f31a242662cc36b3fd057d7377f79e63722efd\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>有过高原经历的人就知道，每天近二十公里的速度是怎么来的。除了极少的路可小骑过个瘾，其余路况很少能一次推百米不停下喘口气的。硬草地一般推个五十米喘口气，寒漠土二十米喘口气，沙土路十米喘口气，重沙地三五米喘口气，陡坡半个轮圈喘口气。这羌塘就是这么一口口气喘过来的。</p>\n</blockquote>\n\n<p>既然预计80天，那么就需要准备足够的食物。</p>\n\n<blockquote>\n  <p>此行，食物约有一百斤，其中主食七十七斤，包括五十斤糌粑、二十五斤压缩饼干、二斤麦片，实际使用七十五斤，前期糟蹋了二斤主食。辅食二十五斤，大蒜、酥油、花生米三样就占了一半。其余是少量的盐、紫菜、辣椒粉、茶叶等，以及一点打牙祭的奶粉和白糖。全程无肉，吃过一次蔬菜，微量元素靠金施尔康药片。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120224.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db4d4dbd81e28550434bbb506c2cabec9b57d323d\" alt=\"\" title=\"\"></p>\n\n<p>这些食物根本不够提供足够的热量和营养，但也没法带更多了。</p>\n\n<blockquote>\n  <p>前四十五天日均摄取热量在一千四百大卡左右，大致四两多糌粑和二点五两压缩饼干，一些汤料为辅。热量摄取水平属于联合国认定的中度饥饿状态，下午四点以后基本就无力了。</p>\n</blockquote>\n\n<p>为了加热食物和取暖，还需要携带汽油。</p>\n\n<blockquote>\n  <p>此行带了8.6升93号汽油，两个锅，1.5升的大锅主要用于烧水。经过几天实测，烧水需时如下：液体水，早晨要用十六分钟左右烧开，晚上则快些；化冰三十五至四十分钟；化雪耗时最长，四十五至五十分钟。为了节省汽油，所以在雪和轻度盐碱水同存的情况下，我多数会选择后者作为饮用水。汽油同样计划八十天用量，理论上是够了，但实际环境中无法准确计算，它包括化冰雪的次数、高原缺氧对汽油燃烧效率的影响，低温下的散温系数、炉头积碳导致的热量损耗等等。唯一有利因素就是低压环境中水的沸点低，只有80℃左右。因此，汽油使用非常节约，每天就是烧两锅水，早晚各一锅，便是所有生活所需了。</p>\n</blockquote>\n\n<p>除了这些，其他的物品还有许多。</p>\n\n<blockquote>\n  <p>就拿此行束缚类装备来说，就有六毫米登山辅力绳、四毫米登山辅力绳、一点五毫米魔术贴捆扎带、一米魔术贴捆扎带、二十厘米魔术贴捆扎带、硅胶弹力带、普通松紧绳、红头风筝绳、凯夫拉鱼线、两色缝补线、五号铁丝、二号铁丝、大号长尾夹、小号长尾夹、橡皮筋、别针、小快扣、主锁......所有装备乱七八糟地加起来，到底有多少，我现在也没法记清了。</p>\n</blockquote>\n\n<h2>三、自行车</h2>\n\n<p>所有行李一共200斤，背是背不动的，必须带上自行车。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120226.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2f2e22981647f1324b3397980a5da16a809b99ce\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>从徒步角度看，推行速度确实太低了，一半都达不到。选择自行车作为穿越工具并非为骑，它只是一个驮货工具。四个驮包分别置于前后轮两侧，相机包挂在车头，一个二十五升的骑行包随身背着。后货架上还有一个六十升防水驮包，用弹性松紧绳捆绑，其间夹塞着防潮垫、水袋、拖鞋等。驮包总容量一百八十五升左右，不包括外置的盛水容器、闲杂物品等，所有装备总重二百斤左右。试想，推着一辆二百斤的自行车在海拔五千米的沙地里推行，实在是一件令人沮丧的事情。</p>\n</blockquote>\n\n<p>大部分路段，自行车没法骑，只能推着走。为了提速，杨柳松用伞做了一个帆，利用风力推动自行车。可惜风太大了，只用了两天，伞就被吹坏了。</p>\n\n<p>为了解决用电问题，他带了太阳能电池。</p>\n\n<blockquote>\n  <p>由于单独采用了一块轻薄的太阳能板给GPS供电，使得GPS高耗电成为历史，七十多天里只因故障换过一次电池，节省了需携带的大量干电池。同时备了一块功率5.4瓦的太阳能板，给7.4伏的相机、DV及其他数码设备供电，路上没缺过电只缺过水。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120215.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3fdc587b6666c9948c3291ecb74eb7aa95d478b7\" alt=\"\" title=\"\"></p>\n\n<h2>四、出发</h2>\n\n<p>原定4月1日进入荒原。这个日期是精心选择的。</p>\n\n<blockquote>\n  <p>太早过于寒冷与干旱，人扛不住，水的问题也没法解决。太晚会推迟进入东羌塘的时间，雨季来临，冻土消融，几乎没有通过的可能性。所以四月初进入荒原是个最折中选择，可以使我吃一个半月的西风和冻土路面，剩下时间则在雨季变得强势前迅速撤离。</p>\n</blockquote>\n\n<p>但是遇到了许多意外，比如在江孜县丢了一个包，不得不重回拉萨采购装备，导致比预定日期推迟了20天，注定后期遭遇雨季，几乎困死于沼泽。</p>\n\n<p>2010年4月20日，他进入羌塘。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120214.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dcd340a0b081cec9260aca597c1e91227e83e3080\" alt=\"\" title=\"\"></p>\n\n<h2>五、无人区</h2>\n\n<p>羌塘是无人区，地理和气候都不适合人类生存。首先，高海拔对生理产生巨大影响。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120229.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8c77fdda8e4ce60151017fe3c790bed8200f2eb0\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>在海拔五千米荒原行路，相当于在平原地区背负十五公斤物品。高海拔对身体的伤害，首先是视力衰退，所以把狼看成外星人，不仅只是端不稳望远镜。其次是听力，海拔越高影响越大，不仅听力急剧减弱，连声音方位也难辨别，这也是高海拔登山容易发生事故的原因之一。高海拔对大脑的伤害尤为大，记忆力会明显下降，譬如，刚向你借钱就忘了，真不是我想赖账。甚者，导致严重的思维障碍。</p>\n</blockquote>\n\n<p>然后，终日大风，风声足以致聋。</p>\n\n<blockquote>\n  <p>风大到只敢以屁股相对。风，也是羌塘唯一的声音。时常一整天，耳畔都是巨大的轰鸣声，即便饿狼贴着后脑勺，大声喊&quot;我想你&quot;，也决然感觉不到半点危机。曾经有位边防战士，独自巡逻两天，被荒原大风吹得失聪。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120209.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8b55f3f5e2044d592a0a10b99d7dfebc245ead5e\" alt=\"\" title=\"\"></p>\n\n<p>遇到暴风雪，只能躲在自行车后面。</p>\n\n<blockquote>\n  <p>我猥琐地蜷缩在自行车后面，躲避着狂风冰雹。这是标准姿势，面对恶劣天气，将自行车横风倒下，整个人团成个肉球，趴在隆起的驮包后面。远处看，则脑袋不见，屁股半撅，有如鸵鸟。</p>\n\n<p>......狂风大作，沙尘滚滚，眼前一片昏黄，视野近无。测量，瞬间最高风速达到了27.8m/s，接近十一级。蜷缩在自行车后面，用一个防雨罩把脑袋完全包住，蓦然，不知什么东西击中了屁股，被人踢了一脚似的。理智思量，不会有人路过，并这么无聊地踢我屁股吧。过了一会儿，屁股又被踢了一下，又一下......后背有点发凉，决定用手摸摸，到底何物。摸到屁股位置有根带子，噼里啪啦地风中乱抽。胡思乱想，难不成恶人不是用脚，而是用鞭子抽我屁股？顺着摸，是车首包的背带。</p>\n</blockquote>\n\n<p>气候极度寒冷，有时帐篷搭得慢一点就没命了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120225.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd8bc95852456cce7254b30bd283d8c0b33bbeec1\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>搭好帐篷去打水，溪流表面已结了薄冰，破之取水。格外酷寒，水杯捞起转瞬间，杯壁上便结了冰。手冷得不行，几秒钟就冻僵。......羌塘冻死，唯雨季风险最大，因为来不及防范，就可能在一场猛烈的冻雨湿雪中失尽体温。</p>\n</blockquote>\n\n<p>长时间野外行走，手指和脚趾都会冻伤。</p>\n\n<blockquote>\n  <p>一只手握在车座下的竖管上，使劲地往前拉，这也是手指关节处裂口长达几十天不愈的原因。有几次拉车，感觉不到手指，以为被拉断了。脱下手套看看，还在，继续拉。</p>\n</blockquote>\n\n<p>遇到大雪，甚至会不知不觉窒息而死。</p>\n\n<blockquote>\n  <p>昨夜，睡得很不踏实，中途迷迷糊糊闷醒多次，胸口如压巨石，喘不过气来。再次被闷醒时，见天亮了，但帐篷上明下黑，难道陷到沼泽里了？用手一推才知被大雪埋了。这是此行遭遇的最大一场雪，深度四十厘米左右，最深处一米。后怕，帐篷被大雪完全封死，内部只有一个小透气窗，半掩着，且冰雪又封了一些。简单计算，夜里帐内氧气含量比珠峰峰顶还低，这还不算体内呼出的二氧化碳的致命影响。半夜闷醒多次，居然浑然不觉大难临头。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120235.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db5448f33312e709adbc90576898bca68fee1729b\" alt=\"\" title=\"\"></p>\n\n<h2>六、野生动物</h2>\n\n<p>荒原里面有很多危险的野生动物，遇到狼是家常便饭。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120228.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db61b6e1bf12da2d887201d6fba614701db08ac8c\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>此次遇狼七次，其中五次是直面。这是指看清脸的，幽魂般闪烁的不配我记录在案。</p>\n\n<p>......先是一只狼从前方沿着土埂小跑，又觉得眼花，土埂后有一黑物闪烁，果然也是只狼，便盯着隐狼看它去向。隐狼完全现身一会儿后又不见了，再看前狼朝我直奔而来。先是放倒车子，故意和车保持一点距离，是想传达我可不是一个人孤军奋战。这招貌似不管用，如果自行车能弯弯车把，向狼打个招呼就好了。我又扶起车子，用身体靠住，万一时刻还能充当下防弹衣。</p>\n</blockquote>\n\n<p>有时早上起床，发现帐篷外面都是狼的脚印。</p>\n\n<blockquote>\n  <p>帐篷周边发现了一些兽迹，应该是狼的。脚印从戈壁深处来，围了帐篷一圈，在头部位置零散纷乱，估计在判断我的气息，然后脚印沿着湖岸远去。</p>\n</blockquote>\n\n<p>其他比较危险的，主要是棕熊和野牦牛。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120217.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D133ee84981c0948d84e4058ad6d5e09295178e67\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>此次旅行遇熊五次，同样，那些小脸都不让我看清的不配记录在案。</p>\n\n<p>有两次刻骨地与野牦牛对峙的经历，距离之近，仿若能看见牛眼里的红血丝，我脊背上的寒气也足以给一间客厅降温避暑了。</p>\n</blockquote>\n\n<p>再怎么防备，都难以保证百分之百的安全。</p>\n\n<blockquote>\n  <p>晚上宿营没有过任何防范，觉得实在没有必要，睡在哪里不是睡在黑夜里？白天遇野兽连贴身小刀也没摸过，徒步探路时基本无防范。羌塘真的很大，有什么东西早发现了。如果棕熊、野牦牛之类的真攻击你，恐怕带枪也不行，所以说心态最重要，学会相处比学会打架管用。 </p>\n</blockquote>\n\n<p>比野生动物更危险的，其实是人。荒原遇到人，比遇狼还令人担心。</p>\n\n<blockquote>\n  <p>凡是能进入荒原的人，大半我都惹不起，譬如杀人灭口的盗猎者，见财起意的淘金人，恪尽职守的巡山队......</p>\n</blockquote>\n\n<h2>七、断水</h2>\n\n<p>二分之一的路段都缺水，即使有水，也是盐碱水，不喝渴死，喝了毒死。</p>\n\n<blockquote>\n  <p>晚上，唯一的水就是前日为以防万一、灌在保温杯里的碱水。一打开盖子，恶臭扑鼻，捂了几天，水质更恶化了。喝是不喝，是个问题。</p>\n</blockquote>\n\n<p>整个旅程最危险的时候是第40天，已经连续三天断水，滴水不存。必须在一天内找到水。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120232.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dcb551429c006c1b730076943dfc11e32b4a3e0dc\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>找水有几个方向，一是附近可能有水的地方，二是回到两天前的营地，三是标准求生方式----挖坑蒸水。先排除最后一点，挖坑蒸水对地貌要求极高，我周遭环境至少挖坑半米才能见到湿土。假使挖坑还没把我累死，假使一整天都是艳阳高照，我所得到的水够不够我继续挖下一个坑的力气都不好说。回到两天前的地方，往返八十公里寻水太纠结了，且以当下身体状态，这不是一件靠意志力就能胜任的工作，远水解不了近渴。</p>\n</blockquote>\n\n<p>他不得不停止行程，专程找水，依然一无所获，只能用尿液解渴。</p>\n\n<blockquote>\n  <p>用尿液伴着饼干，勉强吃了一点，明天还得要有体力继续找水。</p>\n</blockquote>\n\n<p>眼看即将渴死在这个极旱的盐碱地，所幸第41天早上下雪了。</p>\n\n<blockquote>\n  <p>听见打在帐篷上的沙沙声，以为又是风沙作祟，一整夜都是这样。微明，掀开帐篷一角，地上散落着小雪籽，再看了眼天际，灰云铺顶。不喜不悲，白天下雪很难积蓄，雪落无痕。心中也并无打算今天如何找水，身体透支太多，再难强打精神。也无祈祷，该怎样怎样。再次醒来，掀开帐门，雪越下越大，才清醒些，认为是生机。随后，三两分钟掀帐查看一下雪情，生怕老天赏赐的大礼会长脚溜走。待雪稍有积淀，便赶紧用纸片掠雪盛在锅里，沾上的沙土也舍不得丢弃。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120221.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1d478e8d4c681f5f00cc91de0531bae1a05a1654\" alt=\"\" title=\"\"></p>\n\n<h2>八、雨季</h2>\n\n<p>六月以后，雨季到来，雪水融化，冻土变成沼泽和湖泊。对于旅行者来说，这时才是真正的噩梦开始。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120211.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc1b7750f482c38b8835ca62f140aebe733871165\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>鞋子早就破了，虽然尽量控制不要灌水，但依然是最煎熬的体感。试想，脚上套着两坨沉重的冰行路是何等苦楚，而这种苦楚将一直伴随我走出荒原。</p>\n</blockquote>\n\n<p>第57天 原定的南下路线被雪水汇成的大河阻断，走不过去了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120236.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3772a5a4118d29ba3fa83478f6c635f930a61045\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>晚上考量许久，何去何从？两天来只推行了十多公里，这沼泽路没法走。眼前又是条大河阻挡，豁命也不是没有过去的可能，但过去之后呢？至少还要横切汇入多格错仁强错的三条大河以及大片湖盆沼泽。</p>\n</blockquote>\n\n<p>最后决定走回头路，掉头北上，穿越阿尔金无人区求生，因为那里的地势高，不易积水。但是，粮食是肯定不够了，只能寄望于路上遇到人。</p>\n\n<blockquote>\n  <p>从阿尔金出去，这是最后一个选择，没法拒绝。从地理上分析，或许北上是条出路，因为要翻越数道山脉，属山地貌，沼泽大河会少很多。北上的最大障碍是线路太长，食物肯定是不够了，且又是&quot;未知&quot;区域。我的打算是尽量赶到鲸鱼湖，传说，那里有获得补给的可能。</p>\n</blockquote>\n\n<h2>九、弹尽粮绝</h2>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120207.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6342432b0b6b0a1fa914c20fdb73efddc7955fd7\" alt=\"\" title=\"\"></p>\n\n<p>第55天，蔬菜只剩下最后四瓣大蒜，吃光。</p>\n\n<p>第59天，盐和粮食所剩无几</p>\n\n<p>第64天，吃光了最后一包压缩饼干。</p>\n\n<blockquote>\n  <p>再次清点粮食，只剩下五斤左右糌粑，比乒乓球大小还少的盐，一点茶叶，三两左右酥油，再无其他了。</p>\n</blockquote>\n\n<p>后面的路，都是冻土融化的沼泽地带。</p>\n\n<blockquote>\n  <p>一陷到膝盖，立马倒地匍匐爬出来。不能往前倒，而是后仰，往前倒，如果沼泽过稠，速度过快会折断小腿，如果沼泽过稀，会一下子把脸给埋住，无法呼吸，错失转身时机。后仰的好处是安全，抽腿也容易。</p>\n</blockquote>\n\n<p>自行车也惨遭灭顶。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120227.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd01a47e980b08501510f83e1cad674a51f6f716d\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>自行车再度陷入沼泽，一脚陷脚踝，二脚陷半小腿，三脚弃车跑人。黏性太大了，再不撤来不及了。随后试着拖车，地越踩越烂，地下水都踩了出来，最后连自行车的边都摸不上了。都考虑弃车了，但装备总得要弄出来。用那十块钱的救生膜和两个防雨罩铺在烂泥上，人趴在上面，一番折腾，好歹把驮包给弄了出来。再看垫脚物早没影了，光救生膜铺开可就两平方米。再一会儿，放驮包的地方也无法立足了。也就是说，即便很硬实的地，多踩上几脚，也变成了沼泽嘴脸。转移驮包后，思量着怎么把自行车弄出来，现在弃车毕竟很不理智。用铁丝套上绳子圈在自行车上，拉拽，车子勉强移动一点，再用力，居然把后轮生生地拽掉了，最终和沼泽打了个平手。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120237.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7875e631e55761c70d2754cf7b07a640ba96656e\" alt=\"\" title=\"\"></p>\n\n<p>第73天，丢弃自行车，徒步逃生。为了减轻负重，把望远镜和水袋也扔了。</p>\n\n<p>第75天，只剩最后一口粮食。幸运的是，在这一天遇见了探矿者。</p>\n\n<p>第77天，走出荒原。</p>\n\n<h2>十、动机</h2>\n\n<p>很多人都有这样的问题：他究竟为什么要进入荒原，如此危险，难道只是为了探险吗？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120220.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D5cb75eb360e65806fc73815a30419e94d01607c8\" alt=\"\" title=\"\"></p>\n\n<p>杨柳松这样解释，对于城市生活，他始终不太适应。</p>\n\n<blockquote>\n  <p>身体每天都被什么东西紧紧束缚似的，那种感觉就像每天衣服都小一号，每天都必须换上大一号衣服，身体才会舒畅。</p>\n</blockquote>\n\n<p>每年春天，只要在西藏，他都要去雅鲁藏布江大峡谷看桃花。最喜欢的是下面这样的景色。</p>\n\n<blockquote>\n  <p>最喜孤立的某处，一树粉红桃花与世无争地怒放。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120206.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D60e026b0fa8bf709f719b532034459db5809b2b6\" alt=\"\" title=\"\"></p>\n\n<p>三年前，他第一次见到荒原，就下决心要深入这片土地。这个刹那的闪念，让他长久酝酿，一定要付诸行动。荒原更适合那一颗自由自在的心。</p>\n\n<blockquote>\n  <p>始终没有逃离荒原的心，这样一片神奇土地，怎舍得轻易离去。只要不是毫无生机的绝境，在我的意识里，荒原彼端将是没有尽头的远方。远方，依然是那永远也到达不了的地方。</p>\n</blockquote>\n\n<p>旅途中，每一次艰难时刻，选择继续前进还是放弃，他都选择前进，始终没有放弃。</p>\n\n<blockquote>\n  <p>事实上，选择北上的真正原因，是自己还没玩够。如果，世界上再无有意思的事，为之无条件追求的事，那活着多没趣。如果真得撑不住了，我就南下徒步逃命去了，三四天时间就可找到牧民，终结这痛苦的旅程。甚至，过河办法都想好了，就是抱着那空油桶，漂啊漂过河，像八仙成员之一似的。</p>\n</blockquote>\n\n<p>那是一种从骨头里，对喧嚣的平庸生活的厌倦。</p>\n\n<blockquote>\n  <p>这是一个浮躁的时代，很拥挤，很冷漠，不管你愿不愿意，都必须随流而动，因此旅行成了一部分人变相的逃离，而非遵循内心的渴望。就我而言，为何旅行，同样没有一个靠谱的答案，热爱是最接近的答案，去追寻荒野的旷寂。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120219.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc3533638a474f6c42eeca43c643a0e2410fa5c2d\" alt=\"\" title=\"\"></p>\n\n<p>人生就像没有尽头的荒原，如果不找到一点乐趣，如何坚持着走完？</p>\n\n<blockquote>\n  <p>人生就是一场漫无目的的旅行，之所以茫然，是因生与死限定了旅行的终与结。有些人乐此不疲地怀揣梦想继续前行，没有目标，没有问题，只是收获一路感受。</p>\n</blockquote>\n\n<p>他写道，自己很享受在荒野中看云。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120233.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Ded7becf2b3857b7ffc5c6d5819baabb282be6611\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>困守的唯一好处，就是有足够时间凝视一朵云的万般变化，生成，绚烂，湮灭。</p>\n</blockquote>\n\n<p>人生难道不是这样吗？我们都是飘荡在天空中的云，匆匆涌起，转眼消散得无影无踪，那么为什么不索性飘荡得远一点呢？</p>\n\n<h2>十一、未来</h2>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120218.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D21e4bb61601560b43f1a1c552cb78e6f13faf7ac\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>许多友人问，走出荒原是什么感觉？</p>\n\n<p>事实上，走出荒原没有想象的幸福感，或是什么成就感，甚至是一种轻度的抑郁和迷茫。巨大的幸福并未如期而至，偶尔的幸福也是短暂。生命是一条贯通的河流，一切皆是没有开始的复始。我们所期望的终点并不存在。</p>\n\n<p>如果我拥有足够的热情，如果这片荒原对我有足够的诱惑，那我就继续往前。如果激情退却，诱惑不再，我就哪来哪回。如果激情与诱惑从未真实存在，所有问题也就不是问题了。暮色中，面对荒原，我必须做出抉择，明日之路是前行，还是后退。这个抉择其实从未存在，只是一个矫情的过程，从心底深处再次认识到自己究竟在做些什么。</p>\n\n<p>虽然，路的尽头什么也没有，但不能因此停止步履，因为你就是路本身。</p>\n\n<p>-- 摘自杨柳松的公众号《逆流之河》（ID： s7s7s777）</p>\n</blockquote>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017120201.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612650%3B1553148650%26q-key-time%3D1521612650%3B1553148650%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da640a9277bbf359d00cd48e7a4e3474c2c4405ef","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/12/qiang-tang.html","sourceType":"blog","time":"2017-12-05 20:29:12"},{"id":15,"name":"博客文集《前方的路》发布","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>年初，我定了一个目标：今年要完成三本书。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>第一本书是 <strong>《ES6 标准入门（第三版）》</strong>（<a href=\"http://es6.ruanyifeng.com/\">官网</a>，<a href=\"https://github.com/ruanyf/es6tutorial/\">源码</a>），今年9月已经<a href=\"http://www.ruanyifeng.com/blog/2017/09/es6_primer_3rd_edition.html\">出版</a>。</p>\n\n<p><a href=\"http://es6.ruanyifeng.com/\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612651%3B1553148651%26q-key-time%3D1521612651%3B1553148651%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd3b84e057d455c60922a5d8afbf33320e15f19df\" alt=\"\" title=\"\"></a></p>\n\n<p>第二本书是 <strong>《未来世界的幸存者》</strong>（<a href=\"http://survivor.ruanyifeng.com/\">官网</a>，<a href=\"https://github.com/ruanyf/survivor\">源码</a>），两周前<a href=\"http://www.ruanyifeng.com/blog/2017/11/technology-training.html\">写完</a>。它是我对于未来的看法。</p>\n\n<p><a href=\"http://survivor.ruanyifeng.com/\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612651%3B1553148651%26q-key-time%3D1521612651%3B1553148651%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D759a45784030d27bafc546cbefa20f1b48b2c484\" alt=\"\" title=\"\"></a></p>\n\n<p>第三本书是 <strong>《前方的路》</strong>（<a href=\"http://road.ruanyifeng.com/\">官网</a>，<a href=\"https://github.com/ruanyf/road\">源码</a>），昨天完成，总结了我走过的人生道路。</p>\n\n<p><a href=\"http://road.ruanyifeng.com/\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017112301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612651%3B1553148651%26q-key-time%3D1521612651%3B1553148651%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Def7422dab8bbb12e3a8e8c1b6c4ec18d3c6bd9cd\" alt=\"\" title=\"\"></a></p>\n\n<p>我写博客十多年了，从一个愤青 + 文青的学生，变成如今沉默寡言的中年人。一路上，随手写下的文字，累积有1000多篇。我早想整理出书，一方面为了纪念，另一方面现在的博客网站不易用，老文章很难找，迫切需要一个便于查找和阅读的精华版。</p>\n\n<p>三年前，我整理过一次，也出版了，书名是《如何变得有思想》。那本书的可读性很差，文章按主题分类（人物篇、历史篇、科技篇......）。我后来醒悟，这样做是不对的。我要给读者看的是<strong>一个</strong>故事，就是我的故事，而不是一篇篇零散的文章。</p>\n\n<p>今年，我投入很多时间，把过去的文章按照时间排序，重新编成一本书。书名改成《前方的路》，出自黑塞的小说《德米安》，意为寻找人生的出路。</p>\n\n<blockquote>\n  <p>&quot;每个人的生活都是一条通向自身的道路。每个人的真正职责只有一个：找到自我。然后在心中坚守一生，全心全意，永不停息。</p>\n\n<p>所有其它的路都是不完整的，是人的逃避方式，是对社会角色的懦弱伪装，是随波逐流，是对内心的恐惧。&quot;</p>\n</blockquote>\n\n<p>明年，<a href=\"http://road.ruanyifeng.com/\">这本书</a>会和<a href=\"http://survivor.ruanyifeng.com/\">《未来世界的幸存者》</a>一起出版。我跟出版社建议，可以做成一套两卷本的《阮一峰文集》。</p>\n\n<p>古人说，人生要立功、立德、立言。完成了这两本书，我就&quot;立言&quot;了。想说的话都说了，以后会少说多做，专心搞技术，完成几个真正有用的技术项目。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612651%3B1553148651%26q-key-time%3D1521612651%3B1553148651%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd3b84e057d455c60922a5d8afbf33320e15f19df","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/11/road-ahead.html","sourceType":"blog","time":"2017-11-23 08:19:12"},{"id":16,"name":"Bash 脚本 set 命令教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>服务器的开发和管理离不开 Bash 脚本，掌握它需要学习大量的细节。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017111501.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612651%3B1553148651%26q-key-time%3D1521612651%3B1553148651%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dff23ee3bde07d2d7107504aed0acbcbebc43a7c1\" alt=\"\" title=\"\"></p>\n\n<p><code>set</code>命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本文介绍它的基本用法，让你可以更安心地使用 Bash 脚本。</p>\n\n<h2>一、简介</h2>\n\n<p>我们知道，Bash 执行脚本的时候，会创建一个新的 Shell。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\n</code></pre></blockquote>\n\n<p>上面代码中，<code>script.sh</code>是在一个新的 Shell 里面执行。这个 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>\n\n<p><code>set</code>命令用来修改 Shell 环境的运行参数，也就是可以定制环境。一共有十几个参数可以定制，<a href=\"https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html\">官方手册</a>有完整清单，本文介绍其中最常用的四个。</p>\n\n<p>顺便提一下，如果命令行下不带任何参数，直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ set\n</code></pre></blockquote>\n\n<h2>二、set -u</h2>\n\n<p>执行脚本的时候，如果遇到不存在的变量，Bash 默认忽略它。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\n\necho $a\necho bar\n</code></pre></blockquote>\n\n<p>上面代码中，<code>$a</code>是一个不存在的变量。执行结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\n\nbar\n</code></pre></blockquote>\n\n<p>可以看到，<code>echo $a</code>输出了一个空行，Bash 忽略了不存在的<code>$a</code>，然后继续执行<code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>\n\n<p><code>set -u</code>就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\nset -u\n\necho $a\necho bar\n</code></pre></blockquote>\n\n<p>运行结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\nbash: script.sh:行4: a: 未绑定的变量\n</code></pre></blockquote>\n\n<p>可以看到，脚本报错了，并且不再执行后面的语句。</p>\n\n<p><code>-u</code>还有另一种写法<code>-o nounset</code>，两者是等价的。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nset -o nounset\n</code></pre></blockquote>\n\n<h2>三、set -x</h2>\n\n<p>默认情况下，脚本执行后，屏幕只显示运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>\n\n<p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\nset -x\n\necho bar\n</code></pre></blockquote>\n\n<p>执行上面的脚本，结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\n+ echo bar\nbar\n</code></pre></blockquote>\n\n<p>可以看到，执行<code>echo bar</code>之前，该命令会先打印出来，行首以<code>+</code>表示。这对于调试复杂的脚本是很有用的。</p>\n\n<p><code>-x</code>还有另一种写法<code>-o xtrace</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nset -o xtrace\n</code></pre></blockquote>\n\n<h2>四、Bash 的错误处理</h2>\n\n<p>如果脚本里面有运行失败的命令（返回值非0），Bash 默认会继续执行后面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\n\nfoo\necho bar\n</code></pre></blockquote>\n\n<p>上面脚本中，<code>foo</code>是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\nscript.sh:行3: foo: 未找到命令\nbar\n</code></pre></blockquote>\n\n<p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>\n\n<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\ncommand || exit 1\n</code></pre></blockquote>\n\n<p>上面的写法表示只要<code>command</code>有非零返回值，脚本就会停止执行。</p>\n\n<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 写法一\ncommand || { echo &quot;command failed&quot;; exit 1; }\n\n# 写法二\nif ! command; then echo &quot;command failed&quot;; exit 1; fi\n\n# 写法三\ncommand\nif [ &quot;$?&quot; -ne 0 ]; then echo &quot;command failed&quot;; exit 1; fi\n</code></pre></blockquote>\n\n<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\ncommand1 &amp;&amp; command2\n</code></pre></blockquote>\n\n<h2>五、 set -e</h2>\n\n<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\nset -e\n\nfoo\necho bar\n</code></pre></blockquote>\n\n<p>执行结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\nscript.sh:行4: foo: 未找到命令\n</code></pre></blockquote>\n\n<p>可以看到，第4行执行失败以后，脚本就终止执行了。</p>\n\n<p><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nset +e\ncommand1\ncommand2\nset -e\n</code></pre></blockquote>\n\n<p>上面代码中，<code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。</p>\n\n<p>还有一种方法是使用<code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/bin/bash\nset -e\n\nfoo || true\necho bar\n</code></pre></blockquote>\n\n<p>上面代码中，<code>true</code>使得这一行语句总是会执行成功，后面的<code>echo bar</code>会执行。</p>\n\n<p><code>-e</code>还有另一种写法<code>-o errexit</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nset -o errexit\n</code></pre></blockquote>\n\n<h2>六、set -o pipefail</h2>\n\n<p><code>set -e</code>有一个例外情况，就是不适用于管道命令。</p>\n\n<p>所谓管道命令，就是多个子命令通过管道运算符（<code>|</code>）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。</p>\n\n<p>请看下面这个例子。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\nset -e\n\nfoo | echo a\necho bar\n</code></pre></blockquote>\n\n<p>执行结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\na\nscript.sh:行4: foo: 未找到命令\nbar\n</code></pre></blockquote>\n\n<p>上面代码中，<code>foo</code>是一个不存在的命令，但是<code>foo | echo a</code>这个管道命令会执行成功，导致后面的<code>echo bar</code>会继续执行。</p>\n\n<p><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n#!/usr/bin/env bash\nset -eo pipefail\n\nfoo | echo a\necho bar\n</code></pre></blockquote>\n\n<p>运行后，结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash script.sh\na\nscript.sh:行4: foo: 未找到命令\n</code></pre></blockquote>\n\n<p>可以看到，<code>echo bar</code>没有执行。</p>\n\n<h2>七、总结</h2>\n\n<p><code>set</code>命令的上面这四个参数，一般都放在一起使用。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 写法一\nset -euxo pipefail\n\n# 写法二\nset -eux\nset -o pipefail\n</code></pre></blockquote>\n\n<p>这两种写法建议放在所有 Bash 脚本的头部。</p>\n\n<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash -euxo pipefail script.sh\n</code></pre></blockquote>\n\n<h2>八、参考链接</h2>\n\n<ul>\n<li><a href=\"https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html\">The Set Builtin</a></li>\n<li><a href=\"https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/\">Safer bash scripts with &apos;set -euxo pipefail&apos;</a></li>\n<li><a href=\"http://www.davidpashley.com/articles/writing-robust-shell-scripts/\">Writing Robust Bash Shell Scripts</a></li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017111501.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612651%3B1553148651%26q-key-time%3D1521612651%3B1553148651%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dff23ee3bde07d2d7107504aed0acbcbebc43a7c1","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/11/bash-set.html","sourceType":"blog","time":"2017-11-15 08:19:18"},{"id":17,"name":"技术教育的兴起","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>如果你经常看这个博客，可能知道我正在写一本书<a href=\"http://survivor.ruanyifeng.com/index.html\">《未来世界的幸存者》</a>。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><a href=\"http://survivor.ruanyifeng.com/index.html\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd51b79b484312f6249baf0f4b51d5f240c7f12b6\" alt=\"\" title=\"\"></a></p>\n\n<p>最近两年，我对未来的看法大变，感到很悲观。这本书就是我想解释给大家听，<a href=\"http://www.ruanyifeng.com/blog/2017/07/working-poor.html\">为什么未来你没有机会</a>。</p>\n\n<blockquote>\n  <p>&quot;总的来看，下一代青年不太可能像上一代有那么多机会。经济增长已经开始放缓，还将继续放缓；人口增长高峰已经过去；除了高科技，几乎所有行业都不会有以前那么高的增长率。 </p>\n\n<p>现在是穷人，未来极大可能还是穷人，能翻身的只能是少数，而且难度越来越大。&quot;</p>\n</blockquote>\n\n<p>这本书写了两年，包含了20多篇文章，差不多每个月写一篇。这个月终于写完了，下面就是最后写完的章节《技术教育的兴起》。接着，就要去找出版社了。</p>\n\n<p>今天文章的主题，关于培训行业。文后还有一则<a href=\"#support\">培训消息</a>，跟我一直合作的<a href=\"[http://apeclass.cn/?utm_source=ruanyifeng](http://apeclass.cn/?utm_source=ruanyifeng\">海棠学院</a>，又推出了新课程<a href=\"http://apeclass.cn/lesson/nodejs.html?utm_source=ruanyifeng\">《前端全栈高阶实战开发》</a>。</p>\n\n<p>=====================</p>\n\n<p>1、</p>\n\n<p>有一年，我在台湾环岛旅行。</p>\n\n<p>花莲的海边，我遇到一对台湾青年夫妻，带着女儿在海滩上玩。我们聊了起来。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110702.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dac506f68560d3a2a18f7491faf7d382df0d8e8d9\" alt=\"\" title=\"\"></p>\n\n<p>当时，我还在高校当老师。他们问我，是否觉得台湾的孩子很幸福。我说为什么？爸爸指着女儿说：&quot;这些小孩没有升学压力啊。&quot;</p>\n\n<p>这倒是事实。台湾有<a href=\"http://tieba.baidu.com/p/1425716563\">100多所</a>高校，可是生育率不断萎缩，导致很多大学<a href=\"http://www.thepaper.cn/newsDetail_forward_1755431\">招不到学生</a>。有一篇<a href=\"http://news.sina.com.cn/c/gat/2017-08-18/doc-ifykcypp8816368.shtml\">报道</a>说：</p>\n\n<blockquote>\n  <p>2006年，台湾考生每科只需考到15分就可以上大学，2007年这个纪录被打破，4科加起来只需18分，2008年更夸张，总分7分就能当大学生了。7分就能上大学，因此成为年度笑话。有人调侃：&quot;即使什么都不会，选择题全部猜 C 都能上不错的学校吧！&quot;</p>\n</blockquote>\n\n<p>但是，这不能解释一个现象。我想了一会，对那位爸爸道出我的疑惑：&quot;如果考大学如此容易，为什么台湾有那么多补习班呢？&quot;</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110703.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D63535dec17a38016db48bc515f58b1af6e9ff36d\" alt=\"\" title=\"\"></p>\n\n<p>没到过台湾的人，想象不到补习班可以做成一个这么大的产业：台湾最热闹的商业街上，都是补习班的霓虹广告；补习班老师是高收入行业，名师就是富豪，也是全社会的知名人物。我不明白，为什么补习班有那么多学生，明明没有升学压力啊？</p>\n\n<p>爸爸答不出来，想了半天，只说&quot;父母都希望孩子出人头地啊&quot;。</p>\n\n<p>2、</p>\n\n<p>旅行回来后，我发现大陆的补习班行业也蓬勃兴起了，比台湾有过之而无不及。</p>\n\n<p>每个居住小区的周围，都有好几家补习班公司，招生对象从两三岁的娃娃到十几岁的中学生，全部通吃。补习科目无所不包，从语数外到艺术和体育，寒暑假还提供美日欧的游学项目，供家长选择。每到夜晚，灯火通明，门口都是接送孩子的家长。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110704.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dabd1afef7c54afb9c899a612fc58a6440166b737\" alt=\"\" title=\"\"></p>\n\n<p>我们的补习班公司，还上市了。从最早的新东方，到后来的达内科技、正保教育、学而思、51Talk都是绩优公司，在纽约交易所上市，受到投资者追捧。后面还有一大批培训类创业公司，排队等着上市。这在全世界恐怕也是绝无仅有。</p>\n\n<p>3、</p>\n\n<p>历史最悠久、市场需求最大的培训项目，就是外语培训。</p>\n\n<p>我读中学时，同学里面流行上《新概念英语》和口语补习班。到了大学，流行的是托福和 GRE 补习班。大家认定，英语好，人生才有出路。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110705.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D379137bd59ea488043f04c0c2863135b1a429445\" alt=\"\" title=\"\"></p>\n\n<p>那时，外企的收入高，比国企要高好几倍，还有出国的机会。如果能拿到美国大学的奖学金，那就是&quot;鱼跃龙门，过而为龙&quot;了。大家都想走这条路。马克思的名言&quot;外语是人生斗争的武器&quot;，是大家的座右铭。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110706.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D9d7b13dc0681b9ed48eb03eb647a95561b273e51\" alt=\"\" title=\"\"></p>\n\n<p>外语改变了很多中国人的人生。马云说，他小时候整天就在西湖边，跟外国人搭讪练习口语，因此<a href=\"http://finance.sina.com.cn/china/gncj/2017-02-04/doc-ifyaexzn8839706.shtml\">认识</a>了澳大利亚的一家人，受邀出国去澳大利亚待了一个月。他大学读的是英语系，第一个创业项目是翻译社，1995年第一次去美国，在西雅图见到了互联网，觉得这玩意有前途，开始互联网创业。也是因为英语，结识了雅虎的创始人杨致远，得到了一笔对于阿里巴巴最为关键的投资。</p>\n\n<p>4、</p>\n\n<p>中国人对于英语的学习热情，造就了新东方这样的补习班巨头。但是，20年过去了，我渐渐发现，英语学习没有以前那么重要了。</p>\n\n<p>一方面，国内的机会和收入越来越多，不比国外少。更重要的是，技术的快速发展，使得语言的壁垒越来越低，甚至消失。</p>\n\n<p>最早的时候是词典软件，只要鼠标一指，就有中文解释，省得查字典了。后来有了翻译软件，都不需要鼠标指来指去了，直接把全文翻译成中文。到了现在，机器翻译已经很可靠了，语法规则的文献，机器翻译的质量接近人工翻译。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110707.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1ee9ff872d39bc388991b96cbeb90bd1542daec8\" alt=\"\" title=\"\"></p>\n\n<p>最新的技术成果是，谷歌公司推出了一款<a href=\"http://tech.qq.com/a/20171005/020705.htm\">实时翻译耳机 Buds</a>，已经上市了。你把耳机戴上，对方说英语，你会实时听到翻译后的中文；你用中文回答，对方会听到英文！有了这个东西，未来还有必要去上口语补习班吗？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110708.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D20ced927bed37337b2c416f0a6b4d83edb03a83b\" alt=\"\" title=\"\"></p>\n\n<p>我曾经一个人在摩洛哥旅行两周。当地的官方语言是阿拉伯语，上层人士说法语，底层民众说柏柏语，我就会一点英语，大多数时候都无法进行语言交流。但是居然没遇到一点困难，顺利地把这个非洲国家玩了一圈，还在撒哈拉沙漠住了两个晚上。这要感谢两样东西，一是遍及摩洛哥全国的3G网络（华为的功劳），可以随时查交通和酒店的信息，二是准确的地图软件，使我不用问路。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110709.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da779b535d518f09ba9d368043e458096d053e28d\" alt=\"\" title=\"\"></p>\n\n<p>（图片说明：我在撒哈拉沙漠住的营地）</p>\n\n<p>技术使得学好外语，不再那么重要了。对于多数人，这不啻于一个福音，因为外语学习非常耗费生命。</p>\n\n<p>2004年，新加坡领导人李光耀<a href=\"http://www.bilibili.com/video/av9983386/\">承认</a>了一个错误。独立之初，他决定所有新加坡人不管智商如何，都要学习两门语言，一门是英语，另一门是该人的母语（马来语或汉语）。后来，他发现这个决定有大问题，熟练掌握两门语言，对于人民的要求实在太高了。大多数人根本做不到双语，哪怕学习多年英语，一开口还是结结巴巴，词不达意。强迫所有人学英语，实在是浪费国民的生命。于是，这一年新加坡政府改变规定，只要求人民学习一门语言即可。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110710.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D80e1a9a7a840853da05481c52d4b637911301637\" alt=\"\" title=\"\"></p>\n\n<p>5、</p>\n\n<p>随着外语培训的重要性下降，我认为，培训的重头将转为技术培训。以前大家排队去上外语补习班，将来会排队去上技术补习班。 </p>\n\n<p>原因就是技术正变得比语言更重要。回到20年前，掌握流利的英语，你会比别人有更多的机会；如今，轮到了技术。谁掌握了技术，谁就有大把的机会。许多家长已经意识到了这一点，小朋友从小不仅要教 ABC，还要教一点编程。</p>\n\n<p>未来的形势远比我们想象的严峻，技术会取代越来越多的人工。展望未来，大部分人，甚至90%以上的人，终其一生只是在社会的底层挣扎，拿着小康或比温饱线略高的工资。</p>\n\n<p>只有技术，才有可能让你翻身。比特币就是一个例子，过去几年中，价格上涨了几百万倍。我知道的许多技术人都通过比特币发了财，而这只是技术带来的财富浪潮之中的一个突出案例。如果你了解技术，你就会看到有这样的机会。现在看上去，只有技术才能提供这样的从底层快速上升的机会。</p>\n\n<p>我有一种悲观的预感。未来只有两种途径可以改变人生，一种是学习技术，另一种是购买彩票。</p>\n\n<p>（正文完）</p>\n\n<p>===================================</p>\n\n<p><a id=\"support\"></a></p>\n\n<p><a href=\"http://apeclass.cn/?utm_source=ruanyifeng\">海棠学院</a>是一家前端开发的在线教育平台，位于北京，跟我有过多次合作。</p>\n\n<p>他们的<a href=\"http://apeclass.cn/lesson/index.html?utm_source=ruanyifeng\">《全栈工程师基础课程》</a>已经开班了10期，从零开始教起，培训了近千名学员，其中近百人就业后的年薪可以达到20W。</p>\n\n<p><a href=\"http://apeclass.cn/lesson/nodejs.html?utm_source=ruanyifeng\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110713.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db801d01002708728d6c27bae57f6e1971fb9fa93\" alt=\"\" title=\"\"></a></p>\n\n<p>现在，在前期培训的基础上，海棠学院精心准备，推出了进阶课程<a href=\"http://apeclass.cn/lesson/nodejs.html?utm_source=ruanyifeng\">《前端全栈高阶实战开发》</a>，面向有1～3年前端开发经验的学员，帮助他们提升技术，挑战更高的薪资。</p>\n\n<p>课程内容包括 Node、Express、MongoDB、React、BootStrap 等主题（<a href=\"http://apeclass.cn/lesson/nodejs.html#syllabus?utm_source=ruanyifeng\">完整的授课内容</a>），重点讲解 Node 应用和微信公众号开发，实战导向，注重动手练习加深理解。</p>\n\n<p>该课程的核心内容一共37讲，为期2~3个月，全部直播。价格是 2999 元，双十一优惠卷可以抵扣 500 元。主讲人是海棠学院的技术合伙人 Rocky 老师。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110712.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7e06c527fa58bec238209d904bf8511d344682d1\" alt=\"\" title=\"\"></p>\n\n<p>开课时间是11月下旬，感兴趣的朋友，请<a href=\"http://apeclass.cn/lesson/nodejs.html?utm_source=ruanyifeng\">点击这里</a>了解详情。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd51b79b484312f6249baf0f4b51d5f240c7f12b6","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/11/technology-training.html","sourceType":"blog","time":"2017-11-07 07:54:08"},{"id":18,"name":"双因素认证（2FA）教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>所谓认证（authentication）就是确认用户的身份，是网站登录必不可少的步骤。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>密码是最常见的认证方法，但是不安全，容易泄露和冒充。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dba5d53d73b635e59342fdab1f3a79ca7de82dfda\" alt=\"\" title=\"\"></p>\n\n<p>越来越多的地方，要求启用双因素认证（Two-factor authentication，简称 2FA）。本文介绍它的概念和实现方法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110102.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dbdf21d0b9eaa3a51a454f2da183c008358b6f3ce\" alt=\"\" title=\"\"></p>\n\n<p>文章结尾有一则<a href=\"#support\">活动消息</a>，<a href=\"http://cn.udacity.com/1111/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\">优达学城</a>（Udacity）的&quot;双十一优惠&quot;，课程最高减免1111元。</p>\n\n<h2>一、双因素认证的概念</h2>\n\n<p>一般来说，三种不同类型的证据，可以证明一个人的身份。</p>\n\n<blockquote>\n  <ul>\n<li><strong>秘密信息</strong>：只有该用户知道、其他人不知道的某种信息，比如密码。</li>\n<li><strong>个人物品</strong>：该用户的私人物品，比如身份证、钥匙。 </li>\n<li><strong>生理特征</strong>：该用户的遗传特征，比如指纹、相貌、虹膜等等。</li>\n</ul>\n</blockquote>\n\n<p>这些证据就称为三种&quot;因素&quot;（factor）。因素越多，证明力就越强，身份就越可靠。</p>\n\n<p>双因素认证就是指，通过认证同时需要两个因素的证据。</p>\n\n<p>银行卡就是最常见的双因素认证。用户必须同时提供银行卡和密码，才能取到现金。</p>\n\n<h2>二、双因素认证方案</h2>\n\n<p>常用的双因素组合是密码 + 某种个人物品，比如网上银行的 U 盾。用户插上 U 盾，再输入密码，才能登录网上银行。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110103.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da8eaa5fb59717fc0694fb849f01f854df252fd3c\" alt=\"\" title=\"\"></p>\n\n<p>但是，用户不可能随时携带 U 盾，手机才是最好的替代品。密码 + 手机就成了最佳的双因素认证方案。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110104.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8a874e72587952fcb49f7763b17d01a7a736a9c5\" alt=\"\" title=\"\"></p>\n\n<p>国内的很多网站要求，用户输入密码时，还要提供短消息发送的验证码，以证明用户确实拥有该手机。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110105.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3f7433a00e509d132441240f239034b9802523f4\" alt=\"\" title=\"\"></p>\n\n<p>但是，短消息是不安全的，容易被拦截和伪造，SIM 卡也可以克隆。已经有<a href=\"http://media.people.com.cn/n/2014/0227/c40606-24477072.html\">案例</a>，先伪造身份证，再申请一模一样的手机号码，把钱转走。</p>\n\n<p>因此，安全的双因素认证不是密码 + 短消息，而是下面要介绍的 <a href=\"https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm\">TOTP</a>。</p>\n\n<h2>三、TOTP 的概念</h2>\n\n<p>TOTP 的全称是&quot;基于时间的一次性密码&quot;（Time-based One-time Password）。它是公认的可靠解决方案，已经写入国际标准 <a href=\"https://tools.ietf.org/html/rfc6238\">RFC6238</a>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110106.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd8b423a91e51b2a9a48be145781d773cb8c7d5f6\" alt=\"\" title=\"\"></p>\n\n<p>它的步骤如下。</p>\n\n<p>第一步，用户开启双因素认证后，服务器生成一个密钥。</p>\n\n<p>第二步：服务器提示用户扫描二维码（或者使用其他方式），把密钥保存到用户的手机。也就是说，服务器和用户的手机，现在都有了同一把密钥。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110107.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D80f3081d00f1039eee15026a7a69b666cb97f2e6\" alt=\"\" title=\"\"></p>\n\n<p>注意，密钥必须跟手机绑定。一旦用户更换手机，就必须生成全新的密钥。</p>\n\n<p>第三步，用户登录时，手机客户端使用这个密钥和当前时间戳，生成一个哈希，有效期默认为30秒。用户在有效期内，把这个哈希提交给服务器。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110108.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1ae6eeb172ee16850ae6db0d269b2e6e07b62d27\" alt=\"\" title=\"\"></p>\n\n<p>第四步，服务器也使用密钥和当前时间戳，生成一个哈希，跟用户提交的哈希比对。只要两者不一致，就拒绝登录。</p>\n\n<h2>五、TOTP 的算法</h2>\n\n<p>仔细看上面的步骤，你可能会有一个问题：手机客户端和服务器，如何保证30秒期间都得到同一个哈希呢？</p>\n\n<p>答案就是下面的公式。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nTC = floor((unixtime(now) − unixtime(T0)) / TS)\n</code></pre></blockquote>\n\n<p>上面的公式中，TC 表示一个时间计数器，<code>unixtime(now)</code>是当前 Unix 时间戳，<code>unixtime(T0)</code>是约定的起始时间点的时间戳，默认是<code>0</code>，也就是1970年1月1日。TS 则是哈希有效期的时间长度，默认是30秒。因此，上面的公式就变成下面的形式。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nTC = floor(unixtime(now) / 30)\n</code></pre></blockquote>\n\n<p>所以，只要在 30 秒以内，TC 的值都是一样的。前提是服务器和手机的时间必须同步。</p>\n\n<p>接下来，就可以算出哈希了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nTOTP = HASH(SecretKey, TC)\n</code></pre></blockquote>\n\n<p>上面代码中，<code>HASH</code>就是约定的哈希函数，默认是 SHA-1。</p>\n\n<p>TOTP 有硬件生成器和软件生成器之分，都是采用上面的算法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110109.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D732d312db720c4080844d058a9b30ec96a4e24de\" alt=\"\" title=\"\"></p>\n\n<p>（说明：TOTP 硬件生成器）</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110109.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da6c84eb8a788ab11ee5d1ba47cfa2e2193e3bd64\" alt=\"\" title=\"\"></p>\n\n<p>（说明：Google Authenticator 是一个生成 TOTP 的手机 App）</p>\n\n<h2>五、TOTP 的实现</h2>\n\n<p>TOTP 很容易写，各个语言都有实现。下面我用 JavaScript 实现<a href=\"https://github.com/simontabor/2fa\"><code>2fa</code></a>来演示一下真实代码。</p>\n\n<p>首先，安装这个模块。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ npm install --save 2fa\n</code></pre></blockquote>\n\n<p>然后，生成一个32位字符的密钥。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nvar tfa = require(&apos;2fa&apos;);\n\ntfa.generateKey(32, function(err, key) {\n  console.log(key);\n});\n// b5jjo0cz87d66mhwa9azplhxiao18zlx\n</code></pre></blockquote>\n\n<p>现在就可以生成哈希了。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nvar tc = Math.floor(Date.now() / 1000 / 30);\nvar totp = tfa.generateCode(key, tc);\nconsole.log(totp); // 683464\n</code></pre></blockquote>\n\n<h2>六、总结</h2>\n\n<p>双因素认证的优点在于，比单纯的密码登录安全得多。就算密码泄露，只要手机还在，账户就是安全的。各种密码破解方法，都对双因素认证无效。</p>\n\n<p>缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。</p>\n\n<p>双因素认证还有一个最大的问题，那就是帐户的恢复。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110111.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7e6b9d25269d1e1337ada349af9e5a960de35691\" alt=\"\" title=\"\"></p>\n\n<p>一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。</p>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Multi-factor_authentication\">Multi-factor authentication</a>, by Wikipedia</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm\">Time-based One-time Password Algorithm</a>, by Wikipedia</li>\n<li><a href=\"https://techblog.bozho.net/enabling-two-factor-authentication-web-application/\">Enabling Two-Factor Authentication For Your Web Application</a>, by Bozhidar Bozhanov</li>\n<li><a href=\"https://github.com/simontabor/2fa\">simontabor/2fa</a>, by Simon Tabor</li>\n</ul>\n\n<p>（正文完）</p>\n\n<p>====================================</p>\n\n<p><a id=\"support\"></a>   </p>\n\n<p>从业两三年后，程序员往往遇到职业瓶颈，80%的人都把时间耗费在熬夜加班、修 Bug，只有少数人选择业余时间精进技术，提升自己的潜力，突破薪资天花板。</p>\n\n<p><a href=\"http://cn.udacity.com/1111/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110121.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D424d20484a0aaab725cf935ea3a3b3f54274c7e8\" alt=\"\" title=\"\"></a></p>\n\n<p><a href=\"http://cn.udacity.com/1111/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\">优达学城</a>（Udacity）作为来自硅谷的前沿技术学习平台，帮你掌握前沿技术。</p>\n\n<p>它的课程和项目，来自Google、Facebook等硅谷名企，并提供人工审阅、一对一在线答疑等服务，拒绝浪费时间走弯路。</p>\n\n<p>今年双十一，与其囤积一年都用不完的便宜货，不如来优达学城投资未来提升自我。11月1日～11月11日，课程全场最高减￥1111，让你轻松享有硅谷学习资源！</p>\n\n<p><a href=\"https://cn.udacity.com/fend/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110123.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D33d2675a9efbeb170f6faed87b19641387351a1a\" alt=\"\" title=\"\"></a><a href=\"https://cn.udacity.com/course/react-nanodegree--nd019-cn/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110122.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1842730b5d9ea2ed1b9312f5ec5982263b0af2e1\" alt=\"\" title=\"\"></a><a href=\"https://cn.udacity.com/course/full-stack-web-developer-nanodegree--nd004-cn/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110124.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D9f3718bb21e68d2a4f547bf6d6cf4603377a8bb5\" alt=\"\" title=\"\"></a></p>\n\n<p>优惠席位有限，先到先得，点击<a href=\"http://cn.udacity.com/1111/?utm_source=ruanyf&amp;utm_medium=banner&amp;utm_campaign=1111_2017\">这里</a>了解详情。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017110101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612652%3B1553148652%26q-key-time%3D1521612652%3B1553148652%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dba5d53d73b635e59342fdab1f3a79ca7de82dfda","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html","sourceType":"blog","time":"2017-11-02 08:06:33"},{"id":19,"name":"CSS 框架 Bulma 教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>网页样式需要大量时间开发，最省事的方法就是使用 CSS 框架。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><a href=\"http://getbootstrap.com/\">Bootstrap</a> 是最著名的 CSS 框架，但是今天我想推荐另一个更轻量化、更易用的框架----<a href=\"https://bulma.io\">Bulma</a>。有了它，即使完全不懂 CSS，也可以轻而易举做出美观的网页。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102301.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec651989515d398bad4167946a18e49bef38a2ce\" alt=\"\" title=\"\"></p>\n\n<p>我要感谢 <a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 对我提供赞助。<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 是国内第一流的人力资源网站，本文结尾有他们的<a href=\"#100offer\">简介</a>，最近想换工作的朋友可以看一下。</p>\n\n<h2>一、简介</h2>\n\n<p>Bulma 框架最大的特点，就是简单好用。所有样式都基于<code>class</code>，只需为 HTML 元素指定<code>class</code>，样式立刻生效。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;a class=&quot;button is-primary is-large&quot;&gt;Login&lt;/a&gt;\n</code></pre></blockquote>\n\n<p>上面代码中，a 元素只需加上几个<code>class</code>，就会出现一个主色调（<code>is-primary</code>）的大（<code>is-large</code>）按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102302.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2400a18449f371026998b55763716d60fb77ee4a\" alt=\"\" title=\"\"></p>\n\n<p>Bulma 是一个手机优先的框架，提供五个宽度断点，具有良好的自适应特性，可以随心所欲为不同设备设置不同样式。</p>\n\n<blockquote>\n  <ul>\n<li>mobile：小于等于768px</li>\n<li>tablet：大于等于769px</li>\n<li>desktop：大于等于1024px</li>\n<li>widescreen：大于等于1216px</li>\n<li>fullhd：大于等于1408px</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df6e8b9ffab144dc01a114d13e168bb1ad9e55b51\" alt=\"\" title=\"\"></p>\n\n<p>它提供二十多种常用组件，比如<a href=\"https://bulma.io/documentation/form/general/\">表单</a> 、<a href=\"https://bulma.io/documentation/elements/table/\">表格</a>、<a href=\"https://bulma.io/documentation/elements/icon/\">图标</a>、<a href=\"https://bulma.io/documentation/components/breadcrumb/\">面包屑</a>、<a href=\"https://bulma.io/documentation/components/menu/\">菜单</a>、<a href=\"https://bulma.io/documentation/components/navbar/\">导航</a>、<a href=\"https://bulma.io/documentation/components/modal/\">Modal 窗口</a>等等。简单的网站，可以不用写任何 CSS 代码。</p>\n\n<h2>二、基本用法</h2>\n\n<p>Bulma 的安装只需一步，把<a href=\"https://github.com/jgthms/bulma/blob/master/css/bulma.css\">样式表</a>插入网页即可。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bulma.min.css&quot;/&gt;\n</code></pre></blockquote>\n\n<p>使用更简单，就是为 HTML 元素加上<code>class</code>。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;a class=&quot;button&quot;&gt;Button&lt;/a&gt;\n</code></pre></blockquote>\n\n<p>上面的代码为 a 元素加上<code>button</code>类，这个链接就会被渲染成按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102304.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dca60ad86cd86cda8be4308599c3817764af650ac\" alt=\"\" title=\"\"></p>\n\n<p>Bulma 提供大量的修饰类，用来改变基类的样式。它们都是以<code>is-</code>或<code>has-</code>开头。比如，要改变 Button 的大小，就可以使用下面的修饰类。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;a class=&quot;button is-small&quot;&gt;Small&lt;/a&gt;\n&lt;a class=&quot;button&quot;&gt;Normal&lt;/a&gt;\n&lt;a class=&quot;button is-medium&quot;&gt;Medium&lt;/a&gt;\n&lt;a class=&quot;button is-large&quot;&gt;Large&lt;/a&gt;\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102306.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7dce22f699d71ac96e9c887f9ebed8bd35a83a15\" alt=\"\" title=\"\"></p>\n\n<p>Bulma 默认提供6种颜色。</p>\n\n<blockquote>\n  <ul>\n<li>is-primary</li>\n<li>is-link</li>\n<li>is-info</li>\n<li>is-success</li>\n<li>is-warning</li>\n<li>is-danger</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102305.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da1bc0d40d62584d0fddd4b99fa43742393901c01\" alt=\"\" title=\"\"></p>\n\n<p>按钮状态的修饰类如下。</p>\n\n<blockquote>\n  <ul>\n<li>is-hovered</li>\n<li>is-focused</li>\n<li>is-active</li>\n<li>is-loading</li>\n</ul>\n</blockquote>\n\n<p>完整的修饰类清单请看<a href=\"https://bulma.io/documentation/elements/button/\">官方文档</a>。</p>\n\n<h2>三、网格体系</h2>\n\n<p>Bulma 的网格体系基于 <a href=\"http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\">Flex 布局</a>，写起来非常容易。最简单的用法就是使用<code>columns</code>指定容器，使用<code>column</code>指定项目。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102307.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4a7259f84b16c549cfe0d0681e3ba786a69bd58a\" alt=\"\" title=\"\"></p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;div class=&quot;columns&quot;&gt;\n  &lt;div class=&quot;column&quot;&gt;First column&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;Second column&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;Third column&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;Fourth&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></blockquote>\n\n<p>屏幕宽度大于 768px 时，所有项目平铺，平分容器的宽度；宽度小于等于 768px 时，所有项目变成垂直堆叠。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102311.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D41a49307303fa811d563f79f300c58e08f604294\" alt=\"\" title=\"\"></p>\n\n<p>以下的修饰类用来指定项目的宽度。</p>\n\n<blockquote>\n  <ul>\n<li>四分之三：is-three-quarters</li>\n<li>四分之一： is-one-quarter</li>\n<li>三分之二：is-two-thirds</li>\n<li>三分之一：is-one-third</li>\n<li>二分之一：is-half</li>\n<li>五分之四：is-four-fifths</li>\n<li>五分之三：is-three-fifths</li>\n<li>五分之二：is-two-fifths</li>\n<li>五分之一：is-one-fifth</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102309.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D67553bdff031e5f235a4cb487937ff1da52ab991\" alt=\"\" title=\"\"></p>\n\n<p>此外，还有一些修饰类也非常有用。</p>\n\n<blockquote>\n  <ul>\n<li>is-narrow：网格的宽度由内容的宽度决定</li>\n<li>is-centered：网格内容居中对齐</li>\n<li>is-gapless：网格之间没有间距</li>\n</ul>\n</blockquote>\n\n<p>Bulma 也支持12网格体系。</p>\n\n<blockquote>\n  <ul>\n<li>is-2</li>\n<li>is-3</li>\n<li>is-4</li>\n<li>is-5</li>\n<li>is-6</li>\n<li>is-7</li>\n<li>is-8</li>\n<li>is-9</li>\n<li>is-10</li>\n<li>is-11</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102310.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7a4099a312a9e5399eb3d5e4fc3c799e0c8f5415\" alt=\"\" title=\"\"></p>\n\n<p>如果要指定某个网格偏移，可以用<code>is-offset-</code>修饰类。</p>\n\n<blockquote>\n  <ul>\n<li>is-offset-one-quarter</li>\n<li>is-offset-one-fifth</li>\n<li>is-offset-8</li>\n<li>is-offset-1</li>\n</ul>\n</blockquote>\n\n<h2>四、响应式布局</h2>\n\n<p>前面说过，Bulma 有五个宽度断点，分别是 mobile（手机）、tablet（平板）、desktop（桌面）、widescreen（宽屏）、fullHD（高清）。</p>\n\n<p><code>columns</code>布局默认是在手机上垂直堆叠，其他宽度都是平铺。如果希望手机也保持平铺，可以加上<code>is-mobile</code>修饰类。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;div class=&quot;columns is-mobile&quot;&gt;\n  &lt;div class=&quot;column&quot;&gt;1&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;2&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;3&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;4&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></blockquote>\n\n<p>如果希望手机和平板是垂直堆叠，其他宽度平铺，可以使用<code>is-desktop</code>修饰类。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;div class=&quot;columns is-desktop&quot;&gt;\n  &lt;div class=&quot;column&quot;&gt;1&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;2&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;3&lt;/div&gt;\n  &lt;div class=&quot;column&quot;&gt;4&lt;/div&gt;\n&lt;/div&gt;\n</code></pre></blockquote>\n\n<p>如果希望在不同设备，网格占据不同的宽度，可以像下面这样写。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;div class=&quot;\n  column\n  is-half-mobile\n  is-one-third-tablet\n  is-one-quarter-desktop\n&quot;&gt;\n&lt;/div&gt;\n</code></pre></blockquote>\n\n<p>上面代码中，这个网格在手机上占据二分之一宽度，平板三分之一宽度，桌面四分之一宽度，宽屏和高清则是平铺。</p>\n\n<p>Bulma 允许为不同设备指定不同的布局。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;div class=&quot;\n  column\n  is-flex-mobile\n  is-inline-tablet\n  is-block-desktop\n&quot;&gt;\n&lt;/div&gt;\n</code></pre></blockquote>\n\n<p>上面代码中，手机是 flex 布局，平板是 inline 布局，其他宽度是 block 布局。</p>\n\n<p>下面是隐藏某个项目的修饰类。</p>\n\n<blockquote>\n  <ul>\n<li>is-hidden-mobile：只在手机隐藏   </li>\n<li>is-hidden-tablet-only：只在平板隐藏  </li>\n<li>is-hidden-desktop-only  ：只在桌面隐藏</li>\n<li>is-hidden-touch：手机和平板隐藏，其他宽度显示</li>\n</ul>\n</blockquote>\n\n<p>完整的清单请看<a href=\"https://bulma.io/documentation/modifiers/responsive-helpers/#hide\">官方文档</a>。</p>\n\n<h2>五、文字</h2>\n\n<p>Bulma 提供7个修饰指定文字大小。</p>\n\n<blockquote>\n  <ul>\n<li>is-size-1： 3rem</li>\n<li>is-size-2： 2.5rem</li>\n<li>is-size-3： 2rem</li>\n<li>is-size-4： 1.5rem</li>\n<li>is-size-5： 1.25rem</li>\n<li>is-size-6： 1rem</li>\n<li>is-size-7： 0.75rem</li>\n</ul>\n</blockquote>\n\n<p>可以为不同设备指定不同的文字大小。</p>\n\n<blockquote>\n  <ul>\n<li>is-size-1-mobile：手机是 size-1 </li>\n<li>is-size-1-tablet：平板是 size-1 </li>\n<li>is-size-1-touch：手机和平板是 size-1</li>\n<li>is-size-1-desktop：桌面、宽屏和高清是 size-1  </li>\n<li>is-size-1-widescreen：宽屏和高清是 size-1</li>\n<li>is-size-1-fullhd：高清是 size-1</li>\n</ul>\n</blockquote>\n\n<p>此外，还有字体<a href=\"https://bulma.io/documentation/modifiers/typography-helpers/#colors\">颜色</a>、<a href=\"https://bulma.io/documentation/modifiers/typography-helpers/#alignment\">对齐</a>、<a href=\"https://bulma.io/documentation/modifiers/typography-helpers/#text-weight\">轻重</a>的修饰类。</p>\n\n<h2>六、定制</h2>\n\n<p>最后这个部分是高级内容，讲解如何定制 Bulma，也就是修改默认样式。Bulma 采用 Sass 语法（注意，不是 Scss 语法），所以定制的样式也必须使用 <a href=\"http://www.ruanyifeng.com/blog/2012/06/sass.html\">SASS</a>。</p>\n\n<p>首先，克隆或<a href=\"https://github.com/jgthms/bulma/archive/master.zip\">下载</a>源码。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ git clone https://github.com/jgthms/bulma.git\n</code></pre></blockquote>\n\n<p>然后，安装依赖。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ cd bulma\n$ npm install\n</code></pre></blockquote>\n\n<p>接着，在源码的根目录里面，新建一个<code>app.sass</code>文件，定制的代码都写在这个文件。在它里面，先引入 Bulma <a href=\"https://github.com/jgthms/bulma/blob/master/sass/utilities/initial-variables.sass\">基础变量</a>。如果需要的话，可以改掉。</p>\n\n<blockquote><pre><code class=\"language-css\">\n@import &quot;./sass/utilities/initial-variables&quot;\n\n$blue: #72d0eb\n$pink: #ffb3b3\n$family-serif: &quot;Merriweather&quot;, &quot;Georgia&quot;, serif\n</code></pre></blockquote>\n\n<p>上面代码中，预设的<code>blue</code>、<code>pink</code>和<code>family-serif</code>变量被改掉。</p>\n\n<p>有一些 Bulma 变量是从基础变量衍生的，需要的话也可以改掉。</p>\n\n<blockquote><pre><code class=\"language-css\">\n$primary: $pink\n</code></pre></blockquote>\n\n<p>上面代码中，主色调改成了<code>pink</code>变量。</p>\n\n<p>接着，在这个文件里面加载 Bulma 的<a href=\"https://github.com/jgthms/bulma/blob/master/bulma.sass\">入口脚本</a>。</p>\n\n<blockquote><pre><code class=\"language-css\">\n@import &quot;./bulma&quot;\n</code></pre></blockquote>\n\n<p>这一行的下面，你就可以写自己的样式了，比如为所有标题加一个下划线。</p>\n\n<blockquote><pre><code class=\"language-css\">\n.title {\n  text-decoration: underline;\n}\n</code></pre></blockquote>\n\n<p>最后，打开<code>package.json</code>，找到下面这一行。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n&quot;build-sass&quot;: &quot;node-sass --output-style expanded --source-map true bulma.sass css/bulma.css&quot;,\n</code></pre></blockquote>\n\n<p>把里面的<code>bulma.sass</code>改成<code>app.sass</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n&quot;build-sass&quot;: &quot;node-sass --output-style expanded --source-map true app.sass css/bulma.css&quot;,\n</code></pre></blockquote>\n\n<p>以后每次修改完样式，运行一下<code>npm run build</code>，就会生成自己的样式表<code>css/bulma.css</code>了。</p>\n\n<p>（全文完）</p>\n\n<p>================================</p>\n\n<p><a id=\"100offer\"></a></p>\n\n<p>优秀的人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力，从海量机会中找到最适合的那个。</p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 让您可以向数百家互联网企业，匿名展示简历和职业期望，省下查找职位和投递简历的时间。通过这种方式，对您感兴趣的企业，主动邀请您参加面试。</p>\n\n<p><a href=\"https://cn.100offer.com/blog/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102402.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D01a21db7ddb2dfe84fb9653ade47503a0169454c\" alt=\"\" title=\"\"></a></p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 的用户之中，既有厌倦了大公司螺丝钉般的重复工作，转而进入创业公司的前 BAT 员工；也有在小公司工作多年，一心想进入大公司的互联网人；还有向往国外的工作与生活，成功肉身翻墙新加坡的工程师。</p>\n\n<p>准备好用不一样的方式迎接更好的职业机会了吗？现在就<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">提交申请</a>吧！</p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102401.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da2b9634a2f49f8330ee8aca9c3d180bfe6389607\" alt=\"\" title=\"\"></a></p>\n\n<p>另外，10月24日是程序员节。作为一名敲代码为生的程序员，你是不是被旁人贴过太多不属于你的标签----死板、呆萌、宅、不解人意？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102403.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D15451ce3359767b0e68dd63941cd923ae49ceb7f\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20171024&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 给你一个撕掉标签的机会：关注 100offer 微信号，发送一段话／一张图／一段视频／一条语音...展示你除了敲代码以外的神技能，还有最高价值1024元的&quot;程序员兴趣基金&quot;等你拿！</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017102301.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec651989515d398bad4167946a18e49bef38a2ce","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/10/bulma.html","sourceType":"blog","time":"2017-10-24 07:48:16"},{"id":20,"name":"换头术","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>1、</p>\n\n<p>我读过一本医学畅销书<a href=\"http://www.ruanyifeng.com/blog/2016/03/death.html\">《最好的告别》</a>，作者是美国医生葛文德。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>他的一个观点，令我印象深刻。他说，医学的进步改变了人们对于死亡的看法。<strong>人们不再把死亡当作不可避免的自然结果，而是归因于某种技术失败。</strong>某个治疗步骤出错了，或者技术还不够好，所以病人死了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101201.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1fc1e307d18d24c9a5bdb2c6d09cecd1cfe1978a\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>越来越多的人相信，死亡的原因是技术缺陷，而不是预料之中的事。死亡证明书的诊断结论，不会写死于老年，总是写着某种最终的近似原因----例如呼吸衰竭，或者心搏停止。</p>\n</blockquote>\n\n<p>既然死亡是技术失败，而技术问题总可以用更好的技术解决，所以人们逐渐形成一种观念：衰老和死亡只有在反常的情况下才会发生，正常情况下是可以治疗和延迟的。</p>\n\n<blockquote>\n  <p>新闻媒体经常炫耀某个97岁的老人跑马拉松的故事，仿佛类似事例不是生物学奇迹，而是对所有人的合理期待。然后呢？当我们的身体不能满足这种幻觉时，我们就觉得好像需要为此感到惭愧 。</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101202.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6cb3509ef5e31c71e201c71802ce1aad098f59a4\" alt=\"\" title=\"\"></p>\n\n<p>2、</p>\n\n<p>我一直无法忘怀这个观点，技术是否可以阻止死亡？<strong>如果技术变得无比先进，人类是否真能将死亡推迟得足够久，活到200岁呢？</strong></p>\n\n<p>我越来越觉得，这是很有可能的。未来人类的寿命也许非常长，远超过自然的生理极限。</p>\n\n<p>延长寿命的关键是什么？我认为主要就是一点：克服器官老化和衰竭，方法就是器官移植。目前，器官移植的成功率正变得越来越高，越来越多的器官可以移植。肺癌就换肺，肝癌就换肝，冠心病就换心，都有办法救回来。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2013110412.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D887cb87fe58b5186eb881ea1b8145749ad475d4d\" alt=\"\" title=\"\"></p>\n\n<p>台北市长柯文哲曾经是台大医院的外科权威，在一次<a href=\"http://www.ruanyifeng.com/blog/2013/11/ko_wen-je.html\">演讲</a>中，讲过两个他亲手处理的病例。一个女孩九天没有心跳，全靠体外循环维持生命，最后还是撑到心脏移植，活了过来；另一个病例更厉害，心脏由于严重的细菌感染都烂了，只好拿掉，没心脏撑了16天，心脏移植以后也活了下来。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2013110409.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd69ae03a6fbe1a976924095230964722c5a6ee3c\" alt=\"\" title=\"\"></p>\n\n<p>随着手术技术的成熟、抗排异药物的完善、人造器官的出现，可以想象，未来的器官移植终将像拔牙那样简单易行、安全可靠。</p>\n\n<p>3、</p>\n\n<p>目前为止，只有一个器官，从来没有人尝试过移植，那就是脑袋。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101203.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D731c08b8678d13786f3b4141faa32b9a8adcced4\" alt=\"\" title=\"\"></p>\n\n<p>医学上，死亡的定义就是脑死亡。也就是说，如果大脑死了，就算身体的其他部分还活着（心脏还在跳动），这个人也是死了。反过来说，如果其他部分坏死了，但是大脑还有意识，那么这个人就是还活着。</p>\n\n<p>大部分人死的时候，大脑的功能其实都是好的，思维依然敏捷，就是身体的其他部分不行了，导致大脑养分供不上，于是先陷入昏迷，然后再死亡。</p>\n\n<p>如果头部移植可以成功，那么人的寿命就会有本质的提高。躯干不行了，脑袋就移植到另一个躯干上，于是就可以接着活。</p>\n\n<p>4、</p>\n\n<p>头部移植的难度无疑是极高的，血管和神经都要正确连接。一个人的大脑如何指挥另一具身体，没有人知道能不能实现。但是，技术是那么地不可思议，我觉得没有理由怀疑可能性，未来是一定可以做到头部移植。</p>\n\n<p>事实上，1970年就有人尝试，一只猴子的脑袋移植到另一只猴子身上。手术后猴子活了三天，被认为实验成功。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101204.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Deced1d6a3bdd2752009bc00971ad32598a1e4fe6\" alt=\"\" title=\"\"></p>\n\n<p>迄今为止，人的大脑移植还从来没有实验过。有一位意大利神经科医生 Sergio Canavero <a href=\"http://www.sohu.com/a/194647074_114760\">宣称</a>2017年底前，就要完成第一例头部移植手术。他还宣称，已经在一条狗身上实验成功，将脊髓神经跟大脑连接起来，让这条瘫痪的狗重新恢复了行动能力。</p>\n\n<p>他还找到了一位俄国志愿者，此人患有退化性疾病，不能行走，不能照料自己，类似英国物理学家霍金的情况，因此愿意割下自己的脑袋，让医生安装在另一具躯体上。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101205.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc0034be8abf79e0784ca9545edf004f731e29e05\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <p>Canavero 医生声称，手术的第一步将是冰冻大脑和身体，阻止脑细胞死亡。然后切开脖子，将关键的动脉和静脉将连接到管子上。在进行移植之前将切断患者的脊椎。当肌肉和血液供给成功连接之后，病人将昏迷一个月时间来限制新移植头颅的活动，同时将通过电刺激让脊椎新连接得到强化。这位野心勃勃的医生相信，物理疗法将让接受头部移植手术的病人在一年内下床走路。</p>\n</blockquote>\n\n<p>医学界普遍<a href=\"http://www.sohu.com/a/137293169_354973\">不相信</a>这个实验，认为这不过是另一场伪科学的闹剧。但是，没有一个科学家说，头部移植是绝对不可能的。</p>\n\n<p>5、</p>\n\n<p>展望未来，几乎可以肯定，人类将不再是纯自然的产物，很可能一部分器官和肢体是自然的，另一部分是人工合成材料。这既是为了替换坏掉的器官，也可能是为了追求更强的功能，比如安装电动的碳纤维假肢，老年人就可以健步如飞，登高山如履平地。</p>\n\n<p>美国发明家、《奇点迫近》的作者、谷歌公司工程总监<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%B7%E8%92%99%E5%BE%B7%C2%B7%E5%BA%93%E8%8C%A8%E9%AD%8F%E5%B0%94\">雷蒙德·库兹维尔</a>（Raymond Kurzweil）说过一句著名的话。</p>\n\n<blockquote>\n  <p>&quot;虽然我像别人一样热爱自己的身体，但是如果我能依靠硅基材料活上200岁，我会毫不犹豫地放弃肉体。&quot;</p>\n</blockquote>\n\n<p>未来，器官移植和换头术一旦成熟，人的寿命可能会翻倍增加。那时，只要保住脑袋就可以了，其他部分就不太重要了，因为可以换。动画《Futurama》里面，人甚至连躯体都不需要了，就是一个头安装在底座上那样活着。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101206.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db2c334b7655925a282b81c4e77b7923f2e6b1457\" alt=\"\" title=\"\"></p>\n\n<p>到了那个地步，人与机器就将合为一体：机器给了人更长的寿命，人给了机器灵魂。</p>\n\n<p>（说明：本文选自我正在写的新书《未来世界的幸存者》，点击<a href=\"http://survivor.ruanyifeng.com/\">这里</a>免费阅读全书。）</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101201.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612653%3B1553148653%26q-key-time%3D1521612653%3B1553148653%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1fc1e307d18d24c9a5bdb2c6d09cecd1cfe1978a","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/10/head-transplant.html","sourceType":"blog","time":"2017-10-17 07:56:00"},{"id":21,"name":"开源许可证教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>作为一个开发者，如果你打算开源自己的代码，千万不要忘记，选择一种开源许可证（license）。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>许多开发者对开源许可证了解很少，不清楚有哪些许可证，应该怎么选择。本文介绍开源许可证的基本知识，主要参考了 OpenSource.com （<a href=\"https://opensource.com/article/17/9/9-open-source-software-rules-startups\">1</a>，<a href=\"https://opensource.com/article/17/9/open-source-licensing\">2</a>）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D401ed14ec9c4f470098de815a7bf0d10a9443f83\" alt=\"\" title=\"\"></p>\n\n<h2>一、什么是开源许可证</h2>\n\n<p>开源许可证是一种法律许可。通过它，版权拥有人明确允许，用户可以免费地使用、修改、共享版权软件。</p>\n\n<p>版权法默认禁止共享，也就是说，没有许可证的软件，就等同于保留版权，虽然开源了，用户只能看看源码，不能用，一用就会侵犯版权。所以软件开源的话，必须明确地授予用户开源许可证。</p>\n\n<h2>二、开源许可证的种类</h2>\n\n<p>目前，国际公认的开源许可证共有<a href=\"https://opensource.org/licenses/alphabetical\">80多种</a>。它们的共同特征是，都允许用户免费地使用、修改、共享源码，但是都有各自的使用条件。</p>\n\n<p>如果一种开源许可证没有任何使用条件，连保留作者信息都不需要，那么就等同于放弃版权了。这时，软件可以直接声明进入&quot;公共领域&quot;（public domain）。</p>\n\n<p>根据使用条件的不同，开源许可证分成两大类。</p>\n\n<blockquote>\n  <ul>\n<li>宽松式（permissive）许可证</li>\n<li>Copyleft 许可证</li>\n</ul>\n</blockquote>\n\n<h2>三、宽松式许可证</h2>\n\n<h3>3.1 特点</h3>\n\n<p>宽松式许可证（permissive license）是最基本的类型，对用户几乎没有限制。用户可以修改代码后闭源。</p>\n\n<p>它有三个基本特点。</p>\n\n<p><strong>（1）没有使用限制</strong></p>\n\n<p>用户可以使用代码，做任何想做的事情。</p>\n\n<p><strong>（2）没有担保</strong></p>\n\n<p>不保证代码质量，用户自担风险。</p>\n\n<p><strong>（3）披露要求（notice requirement）</strong></p>\n\n<p>用户必须披露原始作者。</p>\n\n<h3>3.2 常见许可证</h3>\n\n<p>常见的宽松式许可证有四种。它们都允许用户任意使用代码，区别在于要求用户遵守的条件不同。</p>\n\n<p><strong>（1）BSD（二条款版）</strong></p>\n\n<p>分发软件时，必须保留原始的许可证声明。</p>\n\n<p><strong>（2） BSD（三条款版）</strong></p>\n\n<p>分发软件时，必须保留原始的许可证声明。不得使用原始作者的名字为软件促销。</p>\n\n<p><strong>（3）MIT</strong></p>\n\n<p>分发软件时，必须保留原始的许可证声明，与 BSD（二条款版）基本一致。</p>\n\n<p><strong>（4）Apache 2</strong></p>\n\n<p>分发软件时，必须保留原始的许可证声明。凡是修改过的文件，必须向用户说明该文件修改过；没有修改过的文件，必须保持许可证不变。</p>\n\n<h2>四、Copyleft 许可证</h2>\n\n<h3>4.1 Copyleft 的含义</h3>\n\n<p>Copyleft 是<a href=\"http://www.ruanyifeng.com/blog/2005/03/post_112.html\">理查德·斯托曼</a>发明的一个词，作为 Copyright （版权）的反义词。</p>\n\n<p>Copyright 直译是&quot;复制权&quot;，这是版权制度的核心，意为不经许可，用户无权复制。作为反义词，Copyleft 的含义是不经许可，用户可以随意复制。</p>\n\n<p>但是，它带有前提条件，比宽松式许可证的限制要多。</p>\n\n<blockquote>\n  <ul>\n<li>如果分发二进制格式，必须提供源码</li>\n<li>修改后的源码，必须与修改前保持许可证一致</li>\n<li>不得在原始许可证以外，附加其他限制</li>\n</ul>\n</blockquote>\n\n<p>上面三个条件的核心就是：修改后的 Copyleft 代码不得闭源。 </p>\n\n<h3>4.2 常见许可证</h3>\n\n<p>常见的 Copyleft 许可证也有四种（对用户的限制从最强到最弱排序）。</p>\n\n<p><strong>（1）Affero GPL (AGPL)</strong></p>\n\n<p>如果云服务（即 SAAS）用到的代码是该许可证，那么云服务的代码也必须开源。</p>\n\n<p><strong>（2）GPL</strong></p>\n\n<p>如果项目包含了 GPL 许可证的代码，那么整个项目都必须使用 GPL 许可证。</p>\n\n<p><strong>（3）LGPL</strong></p>\n\n<p>如果项目采用动态链接调用该许可证的库，项目可以不用开源。</p>\n\n<p><strong>（4）Mozilla（MPL）</strong></p>\n\n<p>只要该许可证的代码在单独的文件中，新增的其他文件可以不用开源。</p>\n\n<h2>五、常见问题</h2>\n\n<p>本节回答一些开源许可证的常见问题。</p>\n\n<h3>5.1 什么叫分发（distribution）？</h3>\n\n<p>除了 Affero GPL (AGPL) ，其他许可证都规定只有在&quot;分发&quot;时，才需要遵守许可证。换言之，如果不&quot;分发&quot;，就不需要遵守。</p>\n\n<p>简单说，分发就是指将版权作品从一个人转移到另一个人。这意味着，如果你是自己使用，不提供给他人，就没有分发。另外，这里的&quot;人&quot;也指&quot;法人&quot;，因此如果使用方是公司，且只在公司内部使用，也不需要遵守许可证。</p>\n\n<p>云服务（SaaS）是否构成&quot;分发&quot;呢？答案是不构成。所以你使用开源软件提供云服务，不必提供源码。但是，Affero GPL (AGPL) 许可证除外，它规定云服务也必须提供源码。</p>\n\n<h3>5.2 开源软件的专利如何处理？</h3>\n\n<p>某些许可证（Apache 2 和 GPL v3）包含明确的条款，授予用户许可，使用软件所包含的所有专利。</p>\n\n<p>另一些许可证（BSD、MIT 和 GPL v2）根本没提到专利。但是一般认为，它们默认给予用户专利许可，不构成侵犯专利。</p>\n\n<p>总得来说，除非有明确的&quot;保留专利&quot;的条款，使用开源软件都不会构成侵犯专利。</p>\n\n<h3>5.3 什么是披露要求？</h3>\n\n<p>所有的开源许可证都带有&quot;披露要求&quot;（notice requirement），即要求软件的分发者必须向用户披露，软件里面有开源代码。</p>\n\n<p>一般来说，你只要在软件里面提供完整的原始许可证文本，并且披露原始作者，就满足了&quot;披露要求&quot;。</p>\n\n<h3>5.4  GPL 病毒是真的吗？</h3>\n\n<p>GPL 许可证规定，只要你的项目包含了 GPL 代码，整个项目就都变成了 GPL。有人把这种传染性比喻成&quot;GPL 病毒&quot;。</p>\n\n<p>很多公司希望避开这个条款，既使用 GPL 软件，又不把自己的专有代码开源。理论上，这是做不到的。因为 GPL 的设计目的，就是为了防止出现这种情况。</p>\n\n<p>但是实际上，不遵守 GPL，最坏情况就是被起诉。如果你向法院表示无法履行 GPL 的条件，法官只会判决你停止使用 GPL 代码（法律上叫做&quot;停止侵害&quot;），而不会强制要求你将源码开源，因为《版权法》里面的&quot;违约救济&quot;没有提到违约者必须开源，只提到可以停止侵害和赔偿损失。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017101101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D401ed14ec9c4f470098de815a7bf0d10a9443f83","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/10/open-source-license-tutorial.html","sourceType":"blog","time":"2017-10-11 20:30:17"},{"id":22,"name":"如何读懂火焰图？","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>软件的性能分析，往往需要查看 CPU 耗时，了解瓶颈在哪里。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><a href=\"http://www.brendangregg.com/flamegraphs.html\">火焰图</a>（flame graph）是性能分析的利器。本文介绍它的基本用法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092502.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da3a898222a15eef3b656a17f6d118352f48a66be\" alt=\"\" title=\"\"></p>\n\n<h2>一、perf 命令</h2>\n\n<p>让我们从 perf 命令（performance 的缩写）讲起，它是 Linux 系统原生提供的性能分析工具，会返回 CPU 正在执行的函数名以及调用栈（stack）。</p>\n\n<p>通常，它的执行频率是 99Hz（每秒99次），如果99次都返回同一个函数名，那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo perf record -F 99 -p 13204 -g -- sleep 30\n</code></pre></blockquote>\n\n<p>上面的代码中，<code>perf record</code>表示记录，<code>-F 99</code>表示每秒99次，<code>-p 13204</code>是进程号，即对哪个进程进行分析，<code>-g</code>表示记录调用栈，<code>sleep 30</code>则是持续30秒。</p>\n\n<p>运行后会产生一个庞大的文本文件。如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。</p>\n\n<p>为了便于阅读，<code>perf record</code>命令可以统计每个调用栈出现的百分比，然后从高到低排列。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo perf report -n --stdio\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092501.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Ddc79a27bd722799ad81e7895b01664bc488f8d4a\" alt=\"\" title=\"\"></p>\n\n<p>这个结果还是不易读，所以才有了火焰图。</p>\n\n<h2>二、火焰图的含义</h2>\n\n<p>火焰图是基于 perf 结果产生的 <a href=\"http://queue.acm.org/downloads/2016/Gregg4.svg\">SVG 图片</a>，用来展示 CPU 的调用栈。</p>\n\n<p><a href=\"http://queue.acm.org/downloads/2016/Gregg4.svg\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092502.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da3a898222a15eef3b656a17f6d118352f48a66be\" alt=\"\" title=\"\"></a></p>\n\n<p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p>\n\n<p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p>\n\n<p><strong>火焰图就是看顶层的哪个函数占据的宽度最大。只要有&quot;平顶&quot;（plateaus），就表示该函数可能存在性能问题。</strong></p>\n\n<p>颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p>\n\n<h2>三、互动性</h2>\n\n<p>火焰图是 <a href=\"http://queue.acm.org/downloads/2016/Gregg4.svg\">SVG 图片</a>，可以与用户互动。</p>\n\n<p><strong>（1）鼠标悬浮</strong></p>\n\n<p>火焰的每一层都会标注函数名，鼠标悬浮时会显示完整的函数名、抽样抽中的次数、占据总抽样次数的百分比。下面是一个例子。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nmysqld&apos;JOIN::exec (272,959 samples, 78.34 percent)\n</code></pre></blockquote>\n\n<p><strong>（2）点击放大</strong></p>\n\n<p>在某一层点击，火焰图会水平放大，该层会占据所有宽度，显示详细信息。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092503.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De860fa4552849f790fa22c5590163284bd866aaa\" alt=\"\" title=\"\"></p>\n\n<p>左上角会同时显示&quot;Reset Zoom&quot;，点击该链接，图片就会恢复原样。</p>\n\n<p><strong>（3）搜索</strong></p>\n\n<p>按下 Ctrl + F 会显示一个搜索框，用户可以输入关键词或正则表达式，所有符合条件的函数名会高亮显示。</p>\n\n<h2>四、火焰图示例</h2>\n\n<p>下面是一个简化的火焰图例子。</p>\n\n<p>首先，CPU 抽样得到了三个调用栈。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nfunc_c \nfunc_b \nfunc_a \nstart_thread \n\nfunc_d \nfunc_a \nstart_thread \n\nfunc_d \nfunc_a \nstart_thread\n</code></pre></blockquote>\n\n<p>上面代码中，<code>start_thread</code>是启动线程，调用了<code>func_a</code>。后者又调用了<code>func_b</code>和<code>func_d</code>，而<code>func_b</code>又调用了<code>func_c</code>。</p>\n\n<p>经过合并处理后，得到了下面的结果，即存在两个调用栈，第一个调用栈抽中1次，第二个抽中2次。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nstart_thread;func_a;func_b;func_c 1 \nstart_thread;func_a;func_d 2\n</code></pre></blockquote>\n\n<p>有了这个调用栈统计，<a href=\"https://github.com/brendangregg/FlameGraph\">火焰图工具</a>就能生成 SVG 图片。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092504.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D79aa7aa95d5429258755ac177f909fd189ab0744\" alt=\"\" title=\"\"></p>\n\n<p>上面图片中，最顶层的函数<code>g()</code>占用 CPU 时间最多。<code>d()</code>的宽度最大，但是它直接耗用 CPU 的部分很少。<code>b()</code>和<code>c()</code>没有直接消耗 CPU。因此，如果要调查性能问题，首先应该调查<code>g()</code>，其次是<code>i()</code>。</p>\n\n<p>另外，从图中可知<code>a()</code>有两个分支<code>b()</code>和<code>h()</code>，这表明<code>a()</code>里面可能有一个条件语句，而<code>b()</code>分支消耗的 CPU 大大高于<code>h()</code>。</p>\n\n<h2>五、局限</h2>\n\n<p>两种情况下，无法画出火焰图，需要修正系统行为。</p>\n\n<p><strong>（1）调用栈不完整</strong></p>\n\n<p>当调用栈过深时，某些系统只返回前面的一部分（比如前10层）。</p>\n\n<p><strong>（2）函数名缺失</strong></p>\n\n<p>有些函数没有名字，编译器只用内存地址来表示（比如匿名函数）。</p>\n\n<h2>六、Node 应用的火焰图</h2>\n\n<p>Node 应用的火焰图就是对 Node 进程进行性能抽样，与其他应用的操作是一样的。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ perf record -F 99 -p `pgrep -n node` -g -- sleep 30\n</code></pre></blockquote>\n\n<p>详细的操作可以看<a href=\"http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html\">这篇文章</a>。</p>\n\n<h2>七、浏览器的火焰图</h2>\n\n<p>Chrome 浏览器可以生成页面脚本的火焰图，用来进行 CPU 分析。</p>\n\n<p>打开开发者工具，切换到 Performance 面板。然后，点击&quot;录制&quot;按钮，开始记录数据。这时，可以在页面进行各种操作，然后停止&quot;录制&quot;。</p>\n\n<p>这时，开发者工具会显示一个时间轴。它的下方就是火焰图。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092505.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D089a0b7cf06f26d872db5c66e332344c67f8aa59\" alt=\"\" title=\"\"></p>\n\n<p>浏览器的火焰图与标准火焰图有两点差异：它是倒置的（即调用栈最顶端的函数在最下方）；x 轴是时间轴，而不是抽样次数。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092506.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D064f7d72036cae3f1759e171e19c623d3248c2af\" alt=\"\" title=\"\"></p>\n\n<h2>八、参考链接</h2>\n\n<ul>\n<li><a href=\"http://queue.acm.org/detail.cfm?id=2927301\">火焰图的介绍论文</a></li>\n<li><a href=\"http://www.brendangregg.com/flamegraphs.html\">火焰图官方主页</a></li>\n<li><a href=\"https://github.com/brendangregg/FlameGraph\">火焰图生成工具</a></li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017092502.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612654%3B1553148654%26q-key-time%3D1521612654%3B1553148654%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da3a898222a15eef3b656a17f6d118352f48a66be","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/09/flame-graph.html","sourceType":"blog","time":"2017-09-26 07:48:13"},{"id":23,"name":"《ES6 标准入门（第3版）》上市了！","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>2017年6月，TC39 委员会正式发布了<a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">《ES2017 标准》</a>。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>相比两年前，JavaScript 语法有了很大的升级，主要是引入了 <a href=\"http://es6.ruanyifeng.com/#docs/async\">async 函数</a>和 <a href=\"http://es6.ruanyifeng.com/#docs/decorator\">decorator</a>。这让我觉得，<a href=\"http://es6.ruanyifeng.com/\">《ES6 标准入门》</a>必须要出新版，否则就跟不上形势了。</p>\n\n<p><a href=\"http://es6.ruanyifeng.com/images/cover-3rd.jpg\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De6ae8c18f63474c75821f466a3b1b804748bda23\" alt=\"\" title=\"\"></a></p>\n\n<p>电子工业出版社的张春雨编辑很支持我的想法，最快时间投入出版社的资源；孙奇俏编辑连续几周都忙于校对排版。7月初我交稿，8月底送印刷厂，9月中旬《ES6 标准入门（第3版）》就全面上市了。</p>\n\n<blockquote>\n  <ul>\n<li><a href=\"https://s.taobao.com/search?q=ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8+%E7%AC%AC3%E7%89%88\">淘宝</a></li>\n<li><a href=\"https://search.jd.com/Search?keyword=ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%20%E7%AC%AC3%E7%89%88&amp;enc=utf-8&amp;wq=ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8%20%E7%AC%AC3%E7%89%88\">京东</a></li>\n<li><a href=\"https://www.amazon.cn/ES6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/dp/B0755547ZZ\">亚马逊</a></li>\n<li><a href=\"http://product.dangdang.com/25156888.html\">当当</a></li>\n<li><a href=\"http://product.china-pub.com/6504650\">China-pub</a></li>\n</ul>\n</blockquote>\n\n<p>新版本的背后是，四年不间断的修改增订，1000多次提交，100多位网友的补丁。我对它的质量很有信心，这本书已经有了8000颗 star，官网每天有上万次的页面请求。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091804.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df21e473f848de39771ec96cbae37f9773b97bc4f\" alt=\"\" title=\"\"></p>\n\n<p>第三版比第二版厚了许多，547页 vs. 317页。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091802.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da6ae125f40c68f1c81d31f7241dde3233fe5aa43\" alt=\"\" title=\"\"></p>\n\n<p>价格当然也贵了不少。不过，这是一本开源教材，你随时可以去<a href=\"http://es6.ruanyifeng.com/\">官网</a>，免费阅读所有内容。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091805.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dbb2b5fc13e519863ef1432f9089deb942d604854\" alt=\"\" title=\"\"></p>\n\n<p>如果读完线上版本，觉得这件事值得支持，欢迎购买实体书。如果能够再为<a href=\"https://github.com/ruanyf/es6tutorial\">源码仓库</a>加一颗 star，那就更好了。</p>\n\n<p>（正文完）</p>\n\n<p>================================</p>\n\n<h2>《ECMAScript 6 标准入门》第三版前言</h2>\n\n<p>四年前，我开始写这本书的时候，ECMAScript 5.1 版刚刚普及，最流行的框架还是 jQuery。ES6 看上去就像一个遥远的蓝图，无人知道何时会实现。</p>\n\n<p>仅仅四年后，ES6 已经经历了 ES2015、ES2016、ES2017 三个版本的迭代，各种实现的支持度超过90%，不仅可以编写网页，还可以编写服务器脚本、手机 App 和桌面应用。程序员们完全接受了这个标准，甚至大量使用尚未标准化的新语法。JavaScript 语言就像一列高铁，以令人眩晕的速度向前猛冲。</p>\n\n<p>互联网行业的蓬勃兴旺，造就了 ES6 的成功，也使得这本教程不断更新，越写越厚。第二版问世十八月之后，就不得不推出第三版。</p>\n\n<p>第三版新增了三分之一的内容，完全覆盖了 ES2017 标准（上一版只做到覆盖 ES2015 标准），并且对所有章节都进行了修订，文字表达更准确易懂，示例更丰富。对读者来说，这个版本更容易学习，更有参考价值。</p>\n\n<p>这四年来，我对 ES6 的理解和所有的学习笔记，都浓缩在这本教程里面。那些我自己感到最困难的地方，都做了详细讲解，给出了细致的示例，我相信这也是其他国内学习者需要的。</p>\n\n<p>这本教程当然也包含了我的局限，以及细致检查之后仍然漏网的各种错误。一旦发现，我会第一时间更正。读者可以到官方仓库 <a href=\"https://github.com/ruanyf/es6tutorial\">github.com/ruanyf/es6tutorial</a> 查看勘误。</p>\n\n<p>我在微博上曾经<a href=\"http://www.weibo.com/1400854834/F0AIlfAJr\">说过</a>一段话，就把它放在这里作为结束。</p>\n\n<blockquote>\n  <p>&quot;我水平其实不高，只是好奇心重，从没想到这么多人会关注。希望不要让大家失望，未来做一块垫脚石，为需要的朋友提供帮助，为技术的推广和发展做出力所能及的贡献。&quot;</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091806.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8550b6c8237820f464ba75788f9d09399e1c90ce\" alt=\"\" title=\"\"></p>\n\n<p>阮一峰 <br>\n2017年8月1日，写于杭州</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017091801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De6ae8c18f63474c75821f466a3b1b804748bda23","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/09/es6_primer_3rd_edition.html","sourceType":"blog","time":"2017-09-19 07:06:48"},{"id":24,"name":"卡辛斯基的警告","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>1、</p>\n\n<p>1978年5月25日，美国西北大学的工程教授巴克利·克利斯（Buckley Crist），收到了邮政局退回的一个包裹。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>这个包裹寄往芝加哥大学，但是收件人&quot;查无此人&quot;。克利斯教授不记得寄过它，可是发件人却写着自己的名字。他叫来了学校的保安。保安打开了包裹，里面是一颗炸弹，立刻爆炸了。保安身受重伤。</p>\n\n<p>此后的18年，这样的案件一再发生。凶手一共寄出了16枚邮件炸弹，共炸死3人，炸伤23人。袭击对象主要是大学的理工科教授，所以凶手被称为&quot;大学炸弹客&quot;（Unabomber）。</p>\n\n<p>FBI 想尽办法要抓住凶手。十几年的调查中，动用了500名特工，误抓了200多名嫌疑犯，查访上万民众，接了2万多通检举电话，花费500万美元，但是一无所获。凶手非常小心，没有留下任何线索。这个案件成了 FBI 历史上最昂贵的调查之一。</p>\n\n<p>2、</p>\n\n<p>1995年4月，凶手又一次作案，一次性寄出了四样东西：两个邮件炸弹，炸死了加州林业协会的总裁吉卜特·莫里，炸断了耶鲁大学计算机科学教授大卫·加勒特的几根手指；一封警告信，警告1993年诺贝尔奖获得者遗传学家理查·罗伯特和菲利普·夏普，要求他们立刻停止基因研究；一篇发给《纽约时报》的长达3.5万字的文章，承诺如果美国主流媒体一字不改地全文刊登，他就将永久停止炸弹袭击。</p>\n\n<p>FBI 局长和美国司法部长最终同意刊登这篇文章。1995年9月19日，它发表在当天的《纽约时报》和《华盛顿邮报》上，题目叫做《论工业社会及其未来》（Industrial Society and Its Future）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090903.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd339de1c7eacf3acd7b22abef3b7ed2450efc649\" alt=\"\" title=\"\"></p>\n\n<p>读者惊讶地发现，这居然是一篇充满思辨的哲学论文，作者明显受过学术训练。论文声称，工业革命带来的是人类的灾难，技术使人类丧失自由，最终将导致社会的动荡甚至毁灭，人们应该摧毁现代工业体系。这就是凶手为什么袭击大学教授的原因，因为他们推动了技术的发展。</p>\n\n<p>更让人吃惊的是，这篇论文很有说服力。许多人开始认真思考作者的观点，主流的知识分子杂志（比如《大西洋》、《纽约人》）专文讨论它。那位被炸断手指的耶鲁大学教授大卫·加勒特承认，文章的推断不无道理，工业文明时代，人类的未来，也许真的险恶重重。Java 语言的发明人计算机学家 Bill Joy 则说，他对文章预言的未来深感困扰。艺术家更是深受影响， 后来的许多小说和电影（比如《黑客帝国》），都能看到这篇论文的影子。</p>\n\n<p>3、</p>\n\n<p>论文发表以后，FBI 收到一条线索：有人举报，该文的写作风格和论点，很像出自他的弟弟泰德·卡辛斯基（Ted Kaczynski）之手。</p>\n\n<p>1996年4月3日，卡辛斯基在蒙大拿州被逮捕，他住在远离人群的荒野之中，自己搭建了一个小木屋，里面堆满了炸弹原料。至此，邮包炸弹案宣告破案。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090904.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D59e0f91d4d1fe08a80bce564b750c5a144898294\" alt=\"\" title=\"\"></p>\n\n<p>卡辛斯基的人生很不寻常。他生于1942年，从小就具有超人的数学天才， 16岁被哈佛大学数学系录取。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090901.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da5d9418996540112f627c77cbece3abc595ea60a\" alt=\"\" title=\"\"></p>\n\n<p>1962年进入密歇根大学攻读数学博士，只用了几个月就拿到了博士学位。指导教授说他的博士论文十分深奥，全美只有十几个人能看懂。25岁时，他被加州大学柏克莱分校聘为助理教授，是该校史上最年轻的教授。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090905.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dbb9262f3886008d680f36ccced6b5a48159a792f\" alt=\"\" title=\"\"></p>\n\n<p>卡辛斯基在柏克莱只待了不到2年，就辞职了，没有任何理由。他从此脱离学术界，过上了离群索居的生活，1971年，在父母的资助下，他在蒙大拿州一个偏僻的山区盖了一间小木屋，搬到那里去住了。屋子里没有电灯、电话、自来水。平日里他吃自己种的菜、猎捕的食物，晚上点蜡烛看书，砍柴做饭取暖。1978年，他在那里寄出了第一个邮件炸弹，攻击目标是在图书馆里面随机选择的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090902.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6577a2de02fff043ac6dc4e0d18edf0655d92874\" alt=\"\" title=\"\"></p>\n\n<p>被捕后，卡辛斯基拒绝了律师为其辩护。1998年，被判处终身监禁，不得保释。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090906.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df66abc8aed3a9c6cd45500fd8f713c44a70bc819\" alt=\"\" title=\"\"></p>\n\n<p>4、</p>\n\n<p>《论工业社会及其未来》这篇论文值得细细阅读，它对人类现状和未来的分析描述，是非常震撼的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090907.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D96e439ed8371cb2fdedb922d313edb91190e158d\" alt=\"\" title=\"\"></p>\n\n<p>关于人类的现状，作者的第一句话就是：&quot;工业文明带给人类的是极大的灾难。&quot;</p>\n\n<blockquote>\n  <p>&quot;工业文明极大地增加了发达国家的人口预期寿命，但也破坏了社会的稳定性，令生活空虚无谓，剥夺了人类的尊严，导致了心理疾病的扩散，还严重地破坏了自然界。&quot;</p>\n</blockquote>\n\n<p>新技术的最大问题，就是剥夺人类的自由。&quot;自由与技术进步不相容，技术越进步，自由越后退。&quot;</p>\n\n<blockquote>\n  <p>&quot;新技术改变社会，最后人们会发现，自己将被强制去使用它。比如，自从有了汽车，城市的布局发生了很大改变，大多数人的住宅已经不在工作场所、购物区和娱乐区的步行距离之内，他们不得不依赖汽车。<strong>人们不再拥有不使用新技术的自由了。</strong>&quot;</p>\n</blockquote>\n\n<p>一项新技术诞生后，不太可能被拒绝使用，因为&quot;每一项新技术单独考虑都是可取的&quot;，然后人类就会依赖它。</p>\n\n<blockquote>\n  <p>&quot;电力、下水道、无线电话......一个人怎么能反对这些东西呢？怎么能反对数不清的技术进步呢？所有的新技术汇总到一起，就创造出了这样一个世界。<strong>在这个世界中，普通人的命运不再掌握在他自己手中，而是掌握在政客、公司主管、技术人员和官僚手中。</strong>以遗传工程为例。很少人会反对消灭某种遗传病的基因技术，但是大量的基因修改，会使人变成一种人工设计制造的产品，而不是自然的创造物。&quot;</p>\n</blockquote>\n\n<p>设想一下，如果基因技术变得成熟和普及，那么政府将不得不管制这种技术，因为万一被滥用，后果不堪设想。这样的话，个人就没有选择，只能接受政府管制，其程度将是前所未有，因为政府将可以管到你的基因结构。</p>\n\n<p>工业社会要想正常运作，必须遵循一整套严格的规则，这导致&quot;现代人都被一张规则之网所笼罩，在所有重要方面，个人的行为都必须服从这些规则。&quot;这导致所有人在本质上都高度类似。</p>\n\n<blockquote>\n  <p>&quot;今天，在技术发达地区，人们的生活方式十分相像。芝加哥的一个基督教银行职员，东京的一个佛教银行职员，莫斯科的一个共产党银行职员，他们彼此之间的日常生活十分相像，而他们的生活与1000年以前人们的生活却非常不同。这就是技术进步的结果......&quot;</p>\n</blockquote>\n\n<p>最终，&quot;<strong>技术完全控制地球上的一切，人类自由基本上将不复存在，因为个人无法对抗用超级技术武装起来的大型组织。</strong>只有极少数人握有真正的权力，但甚至就连他们的自由也是十分有限的，因为他们的行为也是受到管制的。&quot;</p>\n\n<p>5、</p>\n\n<p>关于人类的未来，卡辛斯基假设 &quot;计算机科学家成功地开发出了智能机器，这些机器无论做什么事都比人类强。在这种情况下，大概所有工作都会由巨大的、高度组织化的机器系统去做，而不再需要任何人类的努力。&quot;</p>\n\n<p>这时可能会有两种情况发生。&quot;一种是允许机器在没有人类监督的情况下，自已做出所有的决策，另一种是人类保留对于机器的控制。&quot;</p>\n\n<blockquote>\n  <p>&quot;如果我们允许机器自己做出所有的决策，人类的命运那时就全凭机器发落了。人们也许会反驳，人类决不会愚蠢到把全部权力都交给机器。但我们既不是说人类会有意将权力交给机器，也不是说机器会存心夺权。我们实际上说的是，人类可能会轻易地让自己沦落到一个完全依赖机器的位置，沦落到不能做出任何实际选择，只能接受机器的所有决策的地步。<strong>随着社会及其面临的问题变得越来越复杂，而机器变得越来越聪明，人们会让机器替他们做更多的决策。仅仅是因为机器做出的决策会比人的决策带来更好的结果。最后，维持体系运行所必需的决策已变得如此之复杂。以至于人类已无能力明智地进行决策。</strong>在这一阶段，机器实质上已处于控制地位。人们已不能把机器关上，因为我们已如此地依赖于机器，关上它们就等于是自杀。&quot;</p>\n</blockquote>\n\n<p>就算人们想尽办法，保留对机器的控制权，结果也会很糟。</p>\n\n<blockquote>\n  <p>&quot;另一方面，也可能人类还能保持对机器的控制。在这种情况下，一般人也许可以控制自己的私人机器，如他的汽车或计算机，但对于大型机器系统的控制权将落入一小群精英之手----就像今天一样。<strong>由于技术的改进，精英对于大众的控制能力将会极大提高，因为人不再必需工作，大众就成为了多余的人，成为了体系的无用负担。</strong>如果精英集团失去了怜悯心，他们完全可以决定灭绝人类大众。如果他们有些人情味，他们也可以使用宣传或其他心理学或生物学技术降低出生率，直至人类大众自行消亡，让这个世界由精英们独占。&quot;</p>\n\n<p>&quot;或者，如果精英集团是由软心肠的自由派人士组成的，他们将注意保证每个人的生理需求都得到满足，每一个孩子都在心理十分健康的条件下被抚养成人，每一个人都有一项有益于健康的癖好来打发日子，每一个可能会变得不满的人都会接受治疗以治愈其&apos;疾病&apos;。<strong>当然，生活是如此没有目的，以致于人们都不得不经过生物学的或心理学的改造，以去除他们的权力欲，或使他们的权力欲&apos;升华&apos;为无害的癖好。</strong>这些经过改造的人们也许能在这样一个社会中生活得平和愉快，但他们决不会自由。他们将被贬低到家畜的地位。&quot;</p>\n</blockquote>\n\n<p>6、</p>\n\n<p>退一步说，如果前面的假设不成立，人工智能没有取得成功，人的工作还是必要的，但是&quot;即使这种情况，机器也将承担越来越多的简单工作，而低能力的工人将越来越过剩（正如我们所见，这种事已经发生了。许多人很难或根本找不到工作，因为他们由于智力或心理原因，而不能达到体系所需要的训练水平）。&quot;</p>\n\n<blockquote>\n  <p>&quot;<strong>对于那些找到工作的人，就业的要求会越来越高。他们将需要越来越多的训练，越来越强的能力，他们将不得不越来越可靠、越来越规矩、越来越驯服，因为他们将越来越像巨型有机体的细胞。</strong>他们的任务将越来越专门化，因而他们的工作在某种意义上也将越来越脱离真实世界，仅集中于现实的一块小碎片。体系将使用一切可以使用的心理学或生物学手段来设计制造人类，使之驯顺，使之具有体系要求的能力。&quot;</p>\n</blockquote>\n\n<p>机器接管了大部分具有真正重要性的工作以后，留给人类的（或者说普通人有能力从事的）都是一些相对不那么重要的工作。</p>\n\n<blockquote>\n  <p>&quot;例如有人建议，大力发展服务业可以给人类提供工作机会。这样人们就可以把时间花在互相擦皮鞋上面，可以用出租车带着彼此到处瞎转，互相为对方做手工艺品，互相给对方端盘子等等。<strong>人类如果最终以这样的方式结局，那对于我们来说也实在是太可怜了，而且我们怀疑有多少人会觉得这样的无意义的忙碌等同于充实的生活。</strong>他们会去寻找危险的其他渲泄途径（毒品、犯罪、邪教、仇恨群体等），除非他们经过生物学或心理学的设计改造后适应了这种生活方式。&quot;</p>\n</blockquote>\n\n<p>7、</p>\n\n<p>卡辛斯基的结论就是，未来要么人类无法幸存下来，要么个人空前地依赖大型组织，空前地&quot;社会化&quot;，人类的生理和心理是设计和改造的结果，而不是自然的产物。</p>\n\n<p>唯一的解决方法就是放弃科学技术，&quot;把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。&quot;</p>\n\n<blockquote>\n  <p>&quot;我们希望已经说服了读者，体系无法通过改革来调和自由与技术。唯一的出路是摒弃整个工业-技术休系。这意味着革命，不一定是武装起义，但肯定是激烈而根本的社会性质变化。&quot;</p>\n</blockquote>\n\n<p>卡辛斯基认为，这个体系是由技术人员为了自己的利益和声望在推动前进。&quot;体系需要科学家、数学家与工程师，否则就无法正常运作。&quot;因此他选择这些人作为袭击目标。这样做当然是邪恶的，但是他对于人类命运的警告却理应受到重视。</p>\n\n<p>卡辛斯基反复提及，引入新技术一定要慎而又慎。</p>\n\n<blockquote>\n  <p>&quot;<strong>一项新技术被引入社会时，将会引发一长串其他变化，这些变化之中的大部分是不可预见的。</strong>历史经验告诉我们，技术进步给社会带来新问题的速度，远比它解决旧问题的速度要快。技术已将人类带入了一条无法轻易逃脱的死胡同。&quot;</p>\n</blockquote>\n\n<p>技术会有我们难以预测的长期后果。比如，抗生素的目的是消灭细菌，但是大量使用后却产生了难以杀死的超级细菌，人们不得不限制抗生素的使用；再比如，医疗技术提高了人类的寿命，但也因此导致了地球的人口激增、社会老龄化、生育率下降等重大的社会变化，这些恐怕都不是技术的发明者能想到的。如果新技术（比如机器人技术、基因工程、纳米技术）被恐怖主义组织掌握，后果就更可怕。如果不是真人，而是机器人在街头发动恐怖袭击，那会是怎样的情景？</p>\n\n<p>距离《论工业社会及其未来》的发表，已经过去了20多年，互联网和人工智能都变成了现实，基因技术开始萌芽。人类对于新技术的入迷简直到了无以复加的地步，恨不得越多越好，一项新技术还在实验室中，人们就开始计划如何尽快形成生产力，占领尽可能多的市场。卡辛斯基的预言似乎一步步正在变成现实，人类正毫不在意地亲手加速自己的毁灭。</p>\n\n<p>（说明：本文选自我正在写的新书《未来世界的幸存者》，点击<a href=\"http://survivor.ruanyifeng.com/\">这里</a>免费阅读全书。）</p>\n\n<p>（正文完）</p>\n\n<p>======================================================</p>\n\n<h2>《论工业社会及其未来》原文摘录</h2>\n\n<p>工业革命极大增加了城市规模和城市人口比例，而人群聚集会增加压力与攻击性。</p>\n\n<p>技术变革导致现代社会的变化十分迅速，因此整个社会不存在稳定的框架和价值观。</p>\n\n<p>有些人急于拯救自由却不愿牺牲技术带来的所谓好处，他们会提出天真的新式社会构想来调和自由与技术。</p>\n\n<p>所有人都理所当然地认为，每一个人都必需向技术的需要低头，而且理由十分充分：如果人的需求被摆在了优先于技术需要的地位，就会出现经济问题、失业、短缺甚至更糟。在我们的社会当中，&quot;精神健康&quot;的概念主要被定义为在多大程度一个人能够根据体系的需要行事并且不会流露出承受精神压力的迹象。</p>\n\n<p>经济体系所能容纳的企业数是有限的，我们大多数人只有成为别人的雇员才可以生存。</p>\n\n<p>工业-技术体系可能幸存也可能崩溃。假如该体系幸存下来，可能最终将会降低生理与心理的痛苦水平，但在此之前必须经历一段漫长而痛苦的调整期，而且人类与众多其他生命体也将付出惨重代价，永远沦为社会机器上的齿轮。更有甚者，假如这个体系幸存下来，将会导致不可避免的后果：没有任何方法能够改革或改进这一体系，使之不至于剥夺人的尊严与自主。</p>\n\n<p>假如这一体系崩溃，结果依旧会十分痛苦。但是体系规模越大，崩溃造成的结果就越可怕。因此假如真要崩溃的话最好赶早不赶迟。</p>\n\n<p>所以我们主张发动针对工业体系的革命。这场革命可能使用或不使用暴力，可能突然完成也可能在几十年时间里相对循序渐进地进行。我们无法预测这一点。但是我们的确为那些憎恨工业体系的人们勾勒了一套十分宽泛的方法，从而为反对这一特定社会形式的革命铺平道路。这不是一场政治革命。革命目标并非推翻政府，而是颠覆现存社会的经济与技术基础。</p>\n\n<p>一般来说科学家都是这样。可能其中也有少数例外，但总体而言他们的动机既不是好奇也不是造福人类，而是完成权力过程的需要。其他动机对于许多科学家来说也有作用，例如金钱与地位。</p>\n\n<p>科学技术也构成了群体权力运动，许多科学家都通过认同这一运动来满足自己的权力需求。</p>\n\n<p>因此科学盲目地前进，不考虑人类种族的真正福祉或任何其他标准，仅仅服从科学家以及提供研究资金的政府官员与企业高管的心理需求。</p>\n\n<p>体系需要科学家、数学家与工程师，否则就无法正常运作。</p>\n\n<p>遗传工程的伦理规范事实上将成为管制人类遗传构造的手段。一部分人（多半是上层阶级）将决定如此这般的遗传工程合乎&quot;道德&quot;，如此这般的做法则不道德，因而他们将在实际上将自己的价值观强加于整个人口的遗传构造。即使伦理规范是以完全民主的方式选择出来的，多数族裔也会将他们自己的价值观强加于那些很可能对于如何 &quot;道德地&quot;运用遗传工程另有看法的少数族裔。真正能够保护自由的伦理规范只能是一条，那就是禁止任何人类遗传工程。而我们可以十分有把握地说，这一点恰恰不可能在技术社会中得到实现。任何将遗传工程贬低成配角的规范都不可能维持下去，因为生物技术的巨大力量所产生的诱惑是无法抗拒的。特别是在大多数人看来，大量生物技术的应用显然且肯定是有益的（可以根除身体与精神疾病，赋予人们当今世界所需要的能力）。基因技术必将不可避免地得到大规模应用，但应用方式只能与工业-技术体系的需求相一致。</p>\n\n<p>技术之所以是如此强有力的社会力量的另一个理由是，在给定社会的条件下技术进步只会不可逆地朝一个方向前进。只要某项技术发明被引进，人们就往往会对其产生依赖，除非它被某种更先进的发明所取代。人们不仅仅作为个人依赖这项新技术。甚至体系作为一个整体都会依赖它。（例如请想像一下，如果没有了计算机，今天的体系会怎么样）因此，体系只能朝向更加技术化的方向移动。在不至于颠覆整个技术体系的前提下，技术将会不断地逼迫自由后退。</p>\n\n<p>技术的进步十分迅速并在许多方面威胁自由（拥挤、规章制度、个人对于大型组织越发严重的依赖、宣传与其他心理学技术、遗传工程、通过监视设备和计算机侵犯隐私，等等），阻挡任何一项对于自由的威胁都需要一场单独的社会斗争。那些想要保卫自由的人会被无数的新攻势及其发展速度所压倒，他们会变得微不足道并停止抵抗。分别反击这些威胁是无效的。只有把技术体系作为一个整体来反击才有成功的希望，但这就是革命而不是改革了。</p>\n\n<p>人们倾向于想当然地认为，由于革命带来的变化比改革大，所以革命也就比改革更难发动。实际上，在某些条件下革命比改革容易得多。这是因为一场革命运动能够激发出人们极大的献身热情，而一场改革运动却不能。一场革命运动许诺一下子解决所有问题并创造整个新世界；它提供人民为之甘冒风险、甘作牺牲的理想。由于这些理由，推翻整个技术体系要比对技术的某一部分----如遗传工程的应用发展----进行有效、持久的限制容易得多。在适当的条件下，许许多多的人会热情地献身于推翻工业技术体系的革命。正如我们提到的那样，寻求限制技术的某些方面的改革者是为了避免不良后果而工作。然而，革命者是为了获得强力的报偿----实现其革命理想----而工作，因此他们比改革者更努力且更执著。</p>\n\n<p>现代社会不是去改变那些使人们抑郁的条件，而是给人们抗抑郁药。</p>\n\n<p>但另一方面，请假设今后几十年的压力超出了体系的承受能力。如果体系崩溃，可能会有一个混乱时期，&quot;动乱年代&quot;，就像在过去各个时代历史所记载的那样。不可能预见动乱年代最后会产生什么结果。但无论如何人类会被赋予一个新机会。最大的危险是工业化社会很可能在崩溃后不几年就开始重组其自身，肯定会有许多人（特别是权力饥渴型的人们）急于重新开动工厂。</p>\n\n<p>工业体系将人类贬低到了被奴役的状态，而憎恨这种被奴役状态的人则面临两个任务。第一，我们必须增强体系内的社会紧张态势，以加快其崩溃或把它弱化到足够程度，使得反对体系的革命成为可能。第二，当体系充分弱化时，我们必须发展并宣传一种反对技术和工业社会的意识形态。当工业社会崩溃时，这种意识形态将有助于保证其残余被粉碎到无法修复的地步，这样体系就无法重组。工厂将被捣毁，技术书籍将被烧掉，等等。</p>\n\n<p>工业体系的崩溃不会纯粹是革命行动的结果，它不会那么难以抵御革命的攻击，除非它自身内部的发展问题导致了极为严重的困难。因此如果体系崩溃，那么它或是自发崩溃，或是部分自发、部分由革命者促发的崩溃。如果崩溃是突如其来的，许多人都会死去，因为世界人口已如此过分膨胀，离开了先进技术就无法养活自己。甚至即使崩溃足够缓慢，人口的减少可以主要通过出生率的降低而不是死亡率的提高而实现，非工业化的过程也多半是极度混乱和极度痛苦的。幻想通过平稳控制的有序方式逐步废除技术是天真的，特别是要考虑到技术爱好者们的负隅顽抗。那么，致力于体系的崩溃是否因此就十分残酷呢？也许是，也许不是。首先，除非体系本来就已经陷入了深重的困难，无论如何都很可能最终自行崩溃，否者单靠革命者是不可能强行使其崩溃的。而且体系发展得规模越大，崩溃的后果就越严重。因此加速体系崩溃的革命者或许反倒控制了灾难的规模。</p>\n\n<p>其次，我们必须权衡斗争与死亡和丧失自由与尊严这两方面的得失。对于我们之中的许多人来说，自由与尊严比长寿和避免肉体痛苦更重要。再者，我们早晚会死，死于为生存或为某一事业而战，强于活得空虚而无目的。</p>\n\n<p>第三，体系的存续所带来的痛苦并不一定就比体系崩溃所带来的痛苦更少。在全世界范围内，体系已经招致、并且正在招致的巨大痛苦曾使人类千百年与他人以及环境和睦相处的古代文化被与其解接触的工业社会所摧毁。其结果就是全方位的经济、环境、社会和心理问题。工业社会的侵扰所产生的影响之一，就是传统的人口控制在全球范围内一下子失去了平衡，因而产生了人口爆炸及其所有连带后果。接着就是心理疾病席卷了整个所谓&quot;幸运&quot;的西方社会。没有人知道臭氧层耗尽、温室效应及其他现在还不能预测的环境问题最终会为这个世界带来怎样的后果。而且就像核扩散已经显示的那样，我们无法防止新技术落入独裁者和不负责任的第三世界国家手中。愿意猜猜伊位克或北朝鲜将用遗传工程来干什么吗?</p>\n\n<p>&quot;嗨！&quot;技术爱好者们会说，&quot;科学能解决所有这些问题！我们将征服饥荒、消灭心理病痛，让每一个人都健康而快乐！&quot;是的，是的。他们200年前就是这么说的。人们曾指望工业社会能够消灭贫穷，使每一个人都快乐，等等。实际结果却不是那么回事。技术爱好者对社会问题的理解简直是无可救药地天真（或自欺欺人）。他们没有意识到（或故意视而不见）这样一个事实：当巨大的变化，即使是看上去有利的变化，被引入一个社会时，将会引发一长串其他变化，这些变化之中的大都分是不可预见的其结果则是社会的混乱。因此，技术爱好者们在试图消灭贫穷和疾病，设计制造驯顺、快乐的人格等等时，很可能会创造出比现在还糟糕的社会体系。例如，科学家们吹嘘说他们能够创造出新的、经遗传工程改造的粮食植物以消灭饥荒。然而，这将会允许人口无限膨胀下去，而众所周知，拥挤会导致紧张和攻击性的增强。这仅仅是技术会导致的可预见问题中的一个例子。我们强调指出，历史经验告诉我们，技术进步给社会带来新问题的速度远比它解决旧问题的速度要快。因此技术爱好者们要经过一个漫长的试错时期才能够为他们的美丽新世界排除掉所有的故障（假设他们最终能做到的话）。而与此同时所产生的痛苦将会如此巨大，以至于体系生存下去所带来的痛苦不见得就比体系崩溃更少。技术己将人类带入了一条无法轻易逃脱的死胡同。</p>\n\n<p>更好的办法是把这个腐朽的体系整个扔进垃圾堆，并勇敢地承受其后果。</p>\n\n<p>现在的两个主要任务是在工业社会中促进社会紧张与不稳定，以及宣传一种反对技术和工业体系的意识形态。当体系变得足够紧张和不稳定时，一场反对技术的革命就有机会发动了。这一模式将十分类似于法国和俄国革命。在两国各自革命之前的几十年里，法国和俄国社会都显示出了越来越多的紧张与脆弱迹象。同时，提供一个与旧世界完全不同的新世界愿景的意识形态发展了起来。以俄国的情况为例，革命者积极从事于破坏旧秩序的工作。然后当旧体系面临着足够的额外紧张时（法国是财政危机，俄国是军事失败），它就会被革命一扫而光。我们预想的就是这样的道路。</p>\n\n<p>大多数革命都有两个目标，一个目标是摧毁一个旧社会，另一个目标是建立革命者想像的新社会。法国和俄国的革命者没有能够成功地建立他们所梦想的新社会（这是十分幸运的事），但她们非常成功地摧毁了既存社会。</p>\n\n<p>然而，一种意识形态如想争取到热情支持，除了负面理想外必须还有正面理想，决不能只破不立。我们的正面理想是自然，即野生自然，按照其本来面目运行的地球，不依赖于人类管理、摆脱人类干涉和控制的地球生灵。我们的野生自然也包括人类本性，即不受有组织社会管制、自主运行的个人，成为偶然性或自由意志或上帝（由你的宗教或哲学观念）的产物。</p>\n\n<p>一个社会的经济与技术结构在决定一般人的生活方式方面远比政治结构更加重要。</p>\n\n<p>我们不应主张无力或消极，我们应主张打破工业体系的权力，而这将大大增加个人和小群体的权力和自由。</p>\n\n<p>（据称）贯穿整个历史，技术都是进步的，从未退步过，因此技术退步是不可能的。但这并非事实。对于&quot;进步&quot;的热情是现代社会形态的特殊现象，在大约十七世纪之前并不存在。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090903.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612655%3B1553148655%26q-key-time%3D1521612655%3B1553148655%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd339de1c7eacf3acd7b22abef3b7ed2450efc649","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/09/unabomber.html","sourceType":"blog","time":"2017-09-12 23:51:42"},{"id":25,"name":"asm.js 和 Emscripten 入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>Web 技术突飞猛进，但是有一个领域一直无法突破 ---- 游戏。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>游戏的性能要求非常高，一些大型游戏连 PC 跑起来都很吃力，更不要提在浏览器的沙盒模型里跑了！但是，尽管很困难，许多开发者始终没放弃，希望让浏览器运行 3D 游戏。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd7fe9a14d5e7095256f2bf7d4d450229dfdc6470\" alt=\"\" title=\"\"></p>\n\n<p>2012年，Mozilla 的工程师 <a href=\"https://github.com/kripken\">Alon Zakai</a> 在研究 LLVM 编译器时突发奇想：许多 3D 游戏都是用 C / C++ 语言写的，如果能将 C / C++ 语言编译成 JavaScript 代码，它们不就能在浏览器里运行了吗？众所周知，JavaScript 的基本语法与 C 语言高度相似。</p>\n\n<p>于是，他开始研究怎么才能实现这个目标，为此专门做了一个编译器项目 <a href=\"https://github.com/kripken/emscripten\">Emscripten</a>。这个编译器可以将 C / C++ 代码编译成 JS 代码，但不是普通的 JS，而是一种叫做 <a href=\"http://asmjs.org/\">asm.js</a> 的 JavaScript 变体。</p>\n\n<p>本文就将介绍 asm.js 和 Emscripten 的基本用法，介绍如何将 C / C++ 转成 JS。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090301.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0f3d6254537f8b8a8c93d77402ebe319cd651b20\" alt=\"\" title=\"\"></p>\n\n<h2>一、asm.js 的简介</h2>\n\n<h3>1.1 原理</h3>\n\n<p>C / C++ 编译成 JS 有两个最大的困难。</p>\n\n<blockquote>\n  <ul>\n<li>C / C++ 是静态类型语言，而 JS 是动态类型语言。 </li>\n<li>C / C++ 是手动内存管理，而 JS 依靠垃圾回收机制。</li>\n</ul>\n</blockquote>\n\n<p><strong>asm.js 就是为了解决这两个问题而设计的：它的变量一律都是静态类型，并且取消垃圾回收机制。</strong>除了这两点，它与 JavaScript 并无差异，也就是说，asm.js 是 JavaScript 的一个严格的子集，只能使用后者的一部分语法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090304.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D19c61e6b5171620c9ee7365aadd9f13a6d15bcbf\" alt=\"\" title=\"\"></p>\n\n<p>一旦 JavaScript 引擎发现运行的是 asm.js，就知道这是经过优化的代码，可以跳过语法分析这一步，直接转成汇编语言。另外，浏览器还会调用 WebGL 通过 GPU 执行 asm.js，即 asm.js 的执行引擎与普通的 JavaScript 脚本不同。这些都是 asm.js 运行较快的原因。据称，asm.js 在浏览器里的运行速度，大约是原生代码的50%左右。</p>\n\n<p>下面就依次介绍 asm.js 的两大语法特点。</p>\n\n<h3>1.2 静态类型的变量</h3>\n\n<p>asm.js 只提供两种<a href=\"http://asmjs.org/spec/latest/#value-types\">数据类型</a>。</p>\n\n<blockquote>\n  <ul>\n<li>32位带符号整数</li>\n<li>64位带符号浮点数</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Daa00c57951fdf2fe60f4e049ad782300dfcbf107\" alt=\"\" title=\"\"></p>\n\n<p>其他数据类型，比如字符串、布尔值或者对象，asm.js 一概不提供。它们都是以数值的形式存在，保存在内存中，通过 <a href=\"http://es6.ruanyifeng.com/#docs/arraybuffer\">TypedArray</a> 调用。</p>\n\n<p>如果变量的类型要在运行时确定，asm.js 就要求事先声明类型，并且不得改变，这样就节省了类型判断的时间。</p>\n\n<p>asm.js 的类型声明有固定写法，<code>变量 | 0</code>表示整数，<code>+变量</code>表示浮点数。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nvar a = 1;\n\nvar x = a | 0;  // x 是32位整数\nvar y = +a;  // y 是64位浮点数\n</code></pre></blockquote>\n\n<p>上面代码中，变量<code>x</code>声明为整数，<code>y</code>声明为浮点数。支持 asm.js 的引擎一看到<code>x = a | 0</code>，就知道<code>x</code>是整数，然后采用 asm.js 的机制处理。如果引擎不支持 asm.js 也没关系，这段代码照样可以运行，最后得到的还是同样的结果。</p>\n\n<p>再看下面的例子。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// 写法一\nvar first = 5;\nvar second = first;\n\n// 写法二\nvar first = 5;\nvar second = first | 0;\n</code></pre></blockquote>\n\n<p>上面代码中，写法一是普通的 JavaScript，变量<code>second</code>只有在运行时才能知道类型，这样就很慢了，写法二是 asm.js，<code>second</code>在声明时就知道是整数，速度就提高了。</p>\n\n<p>函数的参数和返回值，都要用这种方式指定类型。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nfunction add(x, y) {\n  x = x | 0;\n  y = y | 0;\n  return (x + y) | 0;\n}\n</code></pre></blockquote>  \n\n<p>上面代码中，除了参数<code>x</code>和<code>y</code>需要声明类型，函数的返回值也需要声明类型。</p>\n\n<h3>1.3 垃圾回收机制</h3>\n\n<p>asm.js 没有垃圾回收机制，所有内存操作都由程序员自己控制。asm.js 通过 TypedArray 直接读写内存。</p>\n\n<p>下面就是直接读写内存的例子。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nvar buffer = new ArrayBuffer(32768);\nvar HEAP8 = new Int8Array(buffer);\nfunction compiledCode(ptr) {\n  HEAP[ptr] = 12;\n  return HEAP[ptr + 4];\n}  \n</code></pre></blockquote>\n\n<p>如果涉及到指针，也是一样处理。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nsize_t strlen(char *ptr) {\n  char *curr = ptr;\n  while (*curr != 0) {\n    curr++;\n  }\n  return (curr - ptr);\n}\n</code></pre></blockquote>\n\n<p>上面的代码编译成 asm.js，就是下面这样。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nfunction strlen(ptr) {\n  ptr = ptr|0;\n  var curr = 0;\n  curr = ptr;\n  while (MEM8[curr]|0 != 0) {\n    curr = (curr + 1)|0;\n  }\n  return (curr - ptr)|0;\n}\n</code></pre></blockquote>\n\n<h3>1.4 asm.js 与 WebAssembly 的异同</h3>\n\n<p>如果你对 JS 比较了解，可能知道还有一种叫做 WebAssembly 的技术，也能将 C / C++ 转成 JS 引擎可以运行的代码。那么它与 asm.js 有何区别呢？</p>\n\n<p>回答是，两者的功能基本一致，就是转出来的代码不一样：asm.js 是文本，WebAssembly 是二进制字节码，因此运行速度更快、体积更小。从长远来看，WebAssembly 的前景更光明。</p>\n\n<p>但是，这并不意味着 asm.js 肯定会被淘汰，因为它有两个优点：首先，它是文本，人类可读，比较直观；其次，所有浏览器都支持 asm.js，不会有兼容性问题。</p>\n\n<h2>二、 Emscripten 编译器</h2>\n\n<h3>2.1 Emscripten 简介</h3>\n\n<p>虽然 asm.js 可以手写，但是它从来就是编译器的目标语言，要通过编译产生。目前，生成 asm.js 的主要工具是 <a href=\"http://emscripten.org\">Emscripten</a>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090306.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dba8c90d9f352d3e6bf04231adbd727114861221f\" alt=\"\" title=\"\"></p>\n\n<p>Emscripten 的底层是 LLVM 编译器，理论上任何可以生成 LLVM IR（Intermediate Representation）的语言，都可以编译生成 asm.js。 但是实际上，Emscripten 几乎只用于将 C / C++ 代码编译生成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nC/C++ ⇒ LLVM ==&gt; LLVM IR ⇒ Emscripten ⇒ asm.js\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090302.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D804721c9e6b485e6ec178bfc0d3cac721151cd39\" alt=\"\" title=\"\"></p>\n\n<h3>2.2 Emscripten 的安装</h3>\n\n<p>Emscripten 的安装可以根据<a href=\"http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html\">官方文档</a>。由于依赖较多，安装起来比较麻烦，我发现更方便的方法是<a href=\"http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html#updating-the-emscripten-sdk\">安装 SDK</a>。</p>\n\n<p>你可以按照下面的<a href=\"https://github.com/kripken/emscripten/issues/5443#issuecomment-320981440\">步骤</a>操作。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ git clone https://github.com/juj/emsdk.git\n$ cd emsdk\n$ ./emsdk install --build=Release sdk-incoming-64bit binaryen-master-64bit\n$ ./emsdk activate --build=Release sdk-incoming-64bit binaryen-master-64bit\n$ source ./emsdk_env.sh\n</code></pre></blockquote>\n\n<p>注意，最后一行非常重要。每次重新登陆或者新建 Shell 窗口，都要执行一次这行命令<code>source ./emsdk_env.sh</code>。</p>\n\n<h3>2.3 Hello World</h3>\n\n<p>首先，新建一个最简单的 C++ 程序<code>hello.cc</code>。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n#include &lt;iostream&gt;\n\nint main() {\n  std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;\n}\n</code></pre></blockquote>\n\n<p>然后，将这个程序转成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ emcc hello.cc\n$ node a.out.js\nHello World!\n</code></pre></blockquote>\n\n<p>上面代码中，<code>emcc</code>命令用于编译源码，默认生成<code>a.out.js</code>。使用 Node 执行<code>a.out.js</code>，就会在命令行输出 Hello World。</p>\n\n<p>注意，asm.js 默认自动执行<code>main</code>函数。</p>\n\n<p><code>emcc</code>是 Emscripten 的编译命令。它的用法非常简单。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 生成 a.out.js\n$ emcc hello.c\n\n# 生成 hello.js\n$ emcc hello.c -o hello.js\n\n# 生成 hello.html 和 hello.js\n$ emcc hello.c -o hello.html\n</code></pre></blockquote>\n\n<h2>三、Emscripten 语法</h2>\n\n<h3>3.1 C/C++ 调用 JavaScript</h3>\n\n<p>Emscripten 允许 C / C++ 代码直接调用 JavaScript。</p>\n\n<p>新建一个文件<code>example1.cc</code>，写入下面的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n#include &lt;emscripten.h&gt;\n\nint main() {\n  EM_ASM({ alert(&apos;Hello World!&apos;); });\n}\n</code></pre></blockquote>\n\n<p><code>EM_ASM</code>是一个宏，会调用嵌入的 JavaScript 代码。注意，JavaScript 代码要写在大括号里面。</p>\n\n<p>然后，将这个程序编译成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ emcc example1.cc -o example1.html\n</code></pre></blockquote>\n\n<p>浏览器打开<code>example1.html</code>，就会跳出对话框<code>Hello World!</code>。</p>\n\n<h3>3.2 C/C++ 与 JavaScript 的通信</h3>\n\n<p>Emscripten 允许 C / C++ 代码与 JavaScript 通信。</p>\n\n<p>新建一个文件<code>example2.cc</code>，写入下面的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n#include &lt;emscripten.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  int val1 = 21;\n  int val2 = EM_ASM_INT({ return $0 * 2; }, val1);\n\n  std::cout &lt;&lt; &quot;val2 == &quot; &lt;&lt; val2 &lt;&lt; std::endl;\n}\n</code></pre></blockquote>\n\n<p>上面代码中，<code>EM_ASM_INT</code>表示 JavaScript 代码返回的是一个整数，它的参数里面的<code>$0</code>表示第一个参数，<code>$1</code>表示第二个参数，以此类推。<code>EM_ASM_INT</code>的其他参数会按照顺序，传入 JavaScript 表达式。</p>\n\n<p>然后，将这个程序编译成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ emcc example2.cc -o example2.html\n</code></pre></blockquote>\n\n<p>浏览器打开网页<code>example2.html</code>，会显示<code>val2 == 42</code>。</p>\n\n<h3>3.3 EM_ASM 宏系列</h3>\n\n<p>Emscripten 提供以下宏。</p>\n\n<blockquote>\n  <ul>\n<li>EM_ASM：调用 JS 代码，没有参数，也没有返回值。</li>\n<li>EM<em>ASM</em>ARGS：调用 JS 代码，可以有任意个参数，但是没有返回值。</li>\n<li>EM<em>ASM</em>INT：调用 JS 代码，可以有任意个参数，返回一个整数。</li>\n<li>EM<em>ASM</em>DOUBLE：调用 JS 代码，可以有任意个参数，返回一个双精度浮点数。</li>\n<li>EM<em>ASM</em>INT_V：调用 JS 代码，没有参数，返回一个整数。</li>\n<li>EM<em>ASM</em>DOUBLE_V：调用 JS 代码，没有参数，返回一个双精度浮点数。</li>\n</ul>\n</blockquote>\n\n<p>下面是一个<code>EM_ASM_ARGS</code>的例子。新建文件<code>example3.cc</code>，写入下面的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n#include &lt;emscripten.h&gt;\n#include &lt;string&gt;\n\nvoid Alert(const std::string &amp; msg) {\n  EM_ASM_ARGS({\n    var msg = Pointer_stringify($0);\n    alert(msg);\n  }, msg.c_str());\n}\n\nint main() {\n  Alert(&quot;Hello from C++!&quot;);\n}\n</code></pre></blockquote>\n\n<p>上面代码中，我们将一个字符串传入 JS 代码。由于没有返回值，所以使用<code>EM_ASM_ARGS</code>。另外，我们都知道，在 C / C++ 里面，字符串是一个字符数组，所以要调用<code>Pointer_stringify()</code>方法将字符数组转成 JS 的字符串。</p>\n\n<p>接着，将这个程序转成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ emcc example3.cc -o example3.html\n</code></pre></blockquote>\n\n<p>浏览器打开<code>example3.html</code>，会跳出对话框&quot;Hello from C++!&quot;。</p>\n\n<h3>3.4 JavaScript 调用 C / C++ 代码</h3>\n\n<p>JS 代码也可以调用 C / C++ 代码。新建一个文件<code>example4.cc</code>，写入下面的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n#include &lt;emscripten.h&gt;\n\nextern &quot;C&quot; {\n  double SquareVal(double val) {\n    return val * val;\n  }\n}\n\nint main() {\n  EM_ASM({\n    SquareVal = Module.cwrap(&apos;SquareVal&apos;, &apos;number&apos;, [&apos;number&apos;]);\n    var x = 12.5;\n    alert(&apos;Computing: &apos; + x + &apos; * &apos; + x + &apos; = &apos; + SquareVal(x));\n  });\n}\n</code></pre></blockquote>\n\n<p>上面代码中，<code>EM_ASM</code>执行 JS 代码，里面有一个 C 语言函数<code>SquareVal</code>。这个函数必须放在<code>extern &quot;C&quot;</code>代码块之中定义，而且 JS 代码还要用<code>Module.cwrap()</code>方法引入这个函数。</p>\n\n<p><code>Module.cwrap()</code>接受三个参数，含义如下。</p>\n\n<blockquote>\n  <ul>\n<li>C 函数的名称，放在引号之中。</li>\n<li>C 函数返回值的类型。如果没有返回值，可以把类型写成<code>null</code>。</li>\n<li>函数参数类型的数组。</li>\n</ul>\n</blockquote>\n\n<p>除了<code>Module.cwrap()</code>，还有一个<code>Module.ccall()</code>方法，可以在 JS 代码之中调用 C 函数。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nvar result = Module.ccall(&apos;int_sqrt&apos;, // C 函数的名称\n  &apos;number&apos;, // 返回值的类型\n  [&apos;number&apos;], // 参数类型的数组\n  [28] // 参数数组\n); \n</code></pre></blockquote>\n\n<p>回到前面的示例，现在将<code>example4.cc</code>编译成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$  emcc -s EXPORTED_FUNCTIONS=&quot;[&apos;_SquareVal&apos;, &apos;_main&apos;]&quot; example4.cc -o example4.html\n</code></pre></blockquote>\n\n<p>注意，编译命令里面要用<code>-s EXPORTED_FUNCTIONS</code>参数给出输出的函数名数组，而且函数名前面加下划线。本例只输出两个 C 函数，所以要写成<code>[&apos;_SquareVal&apos;, &apos;_main&apos;]</code>。</p>\n\n<p>浏览器打开<code>example4.html</code>，就会看到弹出的对话框里面显示下面的内容。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nComputing: 12.5 * 12.5 = 156.25 \n</code></pre></blockquote>\n\n<h2>3.5 C 函数输出为 JavaScript 模块</h2>\n\n<p>另一种情况是输出 C 函数，供网页里面的 JavaScript 脚本调用。 新建一个文件<code>example5.cc</code>，写入下面的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nextern &quot;C&quot; {\n  double SquareVal(double val) {\n    return val * val;\n  }\n}\n</code></pre></blockquote>\n\n<p>上面代码中，<code>SquareVal</code>是一个 C 函数，放在<code>extern &quot;C&quot;</code>代码块里面，就可以对外输出。</p>\n\n<p>然后，编译这个函数。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ emcc -s EXPORTED_FUNCTIONS=&quot;[&apos;_SquareVal&apos;]&quot; example5.cc -o example5.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>-s EXPORTED_FUNCTIONS</code>参数告诉编译器，代码里面需要输出的函数名。函数名前面要加下划线。</p>\n\n<p>接着，写一个网页，加载刚刚生成的<code>example5.js</code>。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML//EN&quot;&gt;\n&lt;body&gt;\n&lt;h1&gt;Test File&lt;/h1&gt;\n&lt;script type=&quot;text/javascript&quot; src=&quot;example5.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n  SquareVal = Module.cwrap(&apos;SquareVal&apos;, &apos;number&apos;, [&apos;number&apos;]);\n  document.write(&quot;result == &quot; + SquareVal(10));\n&lt;/script&gt;\n&lt;/body&gt;\n</code></pre></blockquote>\n\n<p>浏览器打开这个网页，就可以看到<code>result == 100</code>了。</p>\n\n<h3>3.6 Node 调用 C 函数</h3>\n\n<p>如果执行环境不是浏览器，而是 Node，那么调用 C 函数就更方便了。新建一个文件<code>example6.c</code>，写入下面的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n#include &lt;stdio.h&gt;\n#include &lt;emscripten.h&gt;\n\nvoid sayHi() {\n  printf(&quot;Hi!\n&quot;);\n}\n\nint daysInWeek() {\n  return 7;\n}\n</code></pre></blockquote>\n\n<p>然后，将这个脚本编译成 asm.js。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ emcc -s EXPORTED_FUNCTIONS=&quot;[&apos;_sayHi&apos;, &apos;_daysInWeek&apos;]&quot; example6.c -o example6.js\n</code></pre></blockquote>\n\n<p>接着，写一个 Node 脚本<code>test.js</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nvar em_module = require(&apos;./api_example.js&apos;);\n\nem_module._sayHi();\nem_module.ccall(&quot;sayHi&quot;);\nconsole.log(em_module._daysInWeek());\n</code></pre></blockquote>\n\n<p>上面代码中，Node 脚本调用 C 函数有两种方法，一种是使用下划线函数名调用<code>em_module._sayHi()</code>，另一种使用<code>ccall</code>方法调用<code>em_module.ccall(&quot;sayHi&quot;)</code>。</p>\n\n<p>运行这个脚本，就可以看到命令行的输出。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node test.js\nHi!\nHi!\n7\n</code></pre></blockquote>\n\n<h2>四、用途</h2>\n\n<p>asm.js 不仅能让浏览器运行 <a href=\"http://kripken.github.io/boon/boon.html\">3D 游戏</a>，还可以运行各种<a href=\"https://github.com/dherman/asm.js/wiki/Projects-using-asm.js\">服务器软件</a>，比如 <a href=\"https://github.com/kripken/lua.vm.js\">Lua</a>、<a href=\"https://github.com/xxuejie/webruby\">Ruby</a> 和 <a href=\"https://github.com/kripken/sql.js\">SQLite</a>。 这意味着很多工具和算法，都可以使用现成的代码，不用重新写一遍。</p>\n\n<p>另外，由于 asm.js 的运行速度较快，所以一些计算密集型的操作（比如计算 Hash）可以使用 C / C++ 实现，再在 JS 中调用它们。</p>\n\n<p>真实的转码实例可以看一下 <a href=\"https://github.com/kripken/zee.js\">gzlib</a> 的编译，参考它的 <a href=\"https://github.com/kripken/zee.js/blob/master/Makefile\">Makefile</a> 怎么写。 </p>\n\n<h2>五、参考链接</h2>\n\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Asm.js\">asm.js</a>, by Wikipedia</li>\n<li><a href=\"https://kripken.github.io/mloc_emscripten_talk/cppcon.html#/\">Emscripten &amp; asm.js: C++&apos;s role in the modern web</a>, by Alon Zakai</li>\n<li><a href=\"http://kripken.github.io/emscripten-site/docs/getting_started/Tutorial.html\">Emscripten Tutorial</a>, by Emscripten</li>\n<li><a href=\"https://johnresig.com/blog/asmjs-javascript-compile-target/\">Asm.js: The JavaScript Compile Target</a>, by John Resig</li>\n<li><a href=\"http://devosoft.org/an-introduction-to-web-development-with-emscripten/\">An Introduction to Web Development with Emscripten</a>, by \nCharles Ofria</li>\n<li><a href=\"http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html\">Interacting with code</a>, by Emscripten</li>\n<li><a href=\"https://pspdfkit.com/blog/2017/webassembly-a-new-hope/\">WebAssembly: A New Hope</a>, by Philipp Spiess and James Swift</li>\n<li><a href=\"https://www.sitepoint.com/understanding-asm-js/\">Understanding asm.js</a>, by Afshin Mehrabani</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017090305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd7fe9a14d5e7095256f2bf7d4d450229dfdc6470","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html","sourceType":"blog","time":"2017-09-07 07:44:07"},{"id":26,"name":"如何使用 Issue 管理软件项目？","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>软件开发（尤其是商业软件）离不开项目管理，Issue 是最通用的管理工具之一。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>本文介绍 Issue 的基本用法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082404.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D36bc56309b08a4796e66fcd5af7ce758d82ccf04\" alt=\"\" title=\"\"></p>\n\n<h2>一、Issue 是什么？</h2>\n\n<p>Issue 指的是一项待完成的工作，通常与系统的改进相关，中文可以译为&quot;问题&quot;或&quot;事务&quot;。下面这些都是 Issue 的例子。</p>\n\n<blockquote>\n  <ul>\n<li>一个软件的 bug</li>\n<li>一项功能建议</li>\n<li>一项待完成的任务</li>\n<li>文档缺失的报告</li>\n</ul>\n</blockquote>\n\n<p>每个 Issue 应该包含该问题的所有信息和历史，使得后来的人只看这个 Issue，就能了解问题的所有方面和过程。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082403.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8d14e9509cf0a9e956f63ee7e79a9b4b62dc56da\" alt=\"\" title=\"\"></p>\n\n<p>历史上，Issue 起源于客服部门。用户打电话反映问题，客服就创建一个工单（ticket），后续的每一个处理步骤、每一次与用户的交流，都要更新工单，记录全部信息。这就是 Issue 的前身。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082418.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D625192e4ad0ccee1aa76857b7528d88ff09ba319\" alt=\"\" title=\"\"></p>\n\n<p>因此，Issue 的原始功能是问题追踪和工单管理，后来不断扩展，逐渐演变成全功能的项目管理工具，还可以用于制定和实施软件的开发计划。</p>\n\n<p>除了软件，其他项目也可以使用 Issue，比如有人把自己住宅的<a href=\"https://github.com/frabcus/house/issues?q=is%3Aissue+is%3Aclosed\">改善计划</a>都做成了 Issue。</p>\n\n<h2>二、Issue 跟踪管理系统</h2>\n\n<p>专门管理 Issue 的软件，叫做 <a href=\"https://en.wikipedia.org/wiki/Issue_tracking_system\">Issue 跟踪管理系统</a>（Issue tracking system）。它面向所有人，普通用户也可以使用。</p>\n\n<p>还有一种 <a href=\"https://en.wikipedia.org/wiki/Bug_tracking_system\">Bug 跟踪管理系统</a>，通常只面向开发者，比如下图的 Bugzilla。它和 Issue 系统可以同时使用，但是也可以被 Issue 系统取代。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082425.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D59e302eb5b3907c1cf922f04c6ac03d13de8339e\" alt=\"\" title=\"\"></p>\n\n<p>一般来说，Issue 跟踪管理系统应该具有以下功能。</p>\n\n<blockquote>\n  <ul>\n<li>项目管理 <br>\n　　- 指定 Issue 的优先级 <br>\n　　- 指定 Issue 所在的阶段 <br>\n　　- 分配负责 Issue 的处理人员 <br>\n　　- 制定日程 <br>\n　　- 监控进度，提供统计  </li>\n<li>团队合作 <br>\n　　- 讨论 <br>\n　　- 邮件通知  </li>\n<li>代码管理 <br>\n　　- 将 Issue 关联源码 <br>\n　　- 将 Issue 关联代码提交与合并</li>\n</ul>\n</blockquote>\n\n<h2>三、Github Issues</h2>\n\n<p>目前，最出名的 Issue 跟踪管理系统是 <a href=\"https://www.atlassian.com/software/jira\">JIRA</a>。它是一个收费软件，这里就不介绍了。下面通过免费的 <a href=\"https://guides.github.com/features/issues/\">Github Issues</a>，来介绍如何使用 Issue。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082426.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D51b24db390df8ebb0c0894fdab0a4e11c09c3e31\" alt=\"\" title=\"\"></p>\n\n<h3>3.1 基本用法</h3>\n\n<p>每个 Github 代码仓库都有一个 Issues 面板。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082405.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D428f92f0e0ba458e4b1d3e40720bffbf6a33b785\" alt=\"\" title=\"\"></p>\n\n<p>进入该面板，点击&quot;New Issue&quot;按钮，就可以新建 Issue。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082427.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D31386b95586a2f1469b1de7720ac06f0e3286222\" alt=\"\" title=\"\"></p>\n\n<p>上图是新建 Issue 的界面，左侧填入 Issue 的标题和内容，右侧是四个配置项（只有项目管理者才能看到）。</p>\n\n<blockquote>\n  <ul>\n<li>Assignees：人员</li>\n<li>Labels：标签</li>\n<li>Projects：项目</li>\n<li>Milestone：里程碑</li>\n</ul>\n</blockquote>\n\n<p>下面，一个个介绍这些配置项。</p>\n\n<h3>3.2 Assignee</h3>\n\n<p>Assignee 选择框用于从当前仓库的所有成员之中，指派某个 Issue 的处理人员。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082406.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3b193ebc834cf9c7a37e6c2689e9faa29ed6ede9\" alt=\"\" title=\"\"></p>\n\n<p>下拉框里面单击人名即可。</p>\n\n<h3>3.3 Labels</h3>\n\n<p>Issue 可以贴上标签，这样有利于分类管理和过滤查看。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082402.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De3a916035282aa8655e2bac41b7f0b84d55172b8\" alt=\"\" title=\"\"></p>\n\n<p>新建标签，要在 Issues 面板的首页，点击 Labels 按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082407.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4702a0bf8f72f8f0979b79c4e9c7f0f0bf221869\" alt=\"\" title=\"\"></p>\n\n<p>这时，会显示六个默认的标签。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082408.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D482ff8588d774a11e7d43da89bb46f47ae19117a\" alt=\"\" title=\"\"></p>\n\n<p>如果想新建更多的标签，可以点击 New label 按钮。然后，填写标签名，选择标签颜色。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082409.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dcddf6961eca5d25408e0babe9bf04ed6b3a42d68\" alt=\"\" title=\"\"></p>\n\n<h3>3.4 常用 Label</h3>\n\n<p>对于大型项目，   每个 Issue 至少应该有两个 Label ，一个表示性质，另一个表示优先级。</p>\n\n<p>表示性质的 Label，可以参考<a href=\"https://robinpowered.com/blog/best-practice-system-for-organizing-and-tagging-github-issues/\">这篇文章</a>的范例。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082428.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8b3c2859cc492c69aaf65ea3a9402eda431745c6\" alt=\"\" title=\"\"></p>\n\n<p>表示优先级的 Label，可以采用下面的级别。</p>\n\n<blockquote>\n  <ul>\n<li><strong>高优先级</strong>（High）：对系统有重大影响，只有解决它之后，才能去完成其他任务。</li>\n<li><strong>普通优先级</strong>（Medium）：对系统的某个部分有影响，用户的一部分操作会达不到预期效果。</li>\n<li><strong>低优先级</strong>（Low）：对系统的某个部分有影响，用户几乎感知不到。</li>\n<li><strong>微不足道</strong>（Trivial）：对系统的功能没有影响，通常是视觉效果不理想，比如字体和颜色不满意。</li>\n</ul>\n</blockquote>\n\n<h3>3.5 Milestone</h3>\n\n<p>Milestone 叫做&quot;里程碑&quot;，用作 Issue 的容器，相关 Issue 可以放在一个 Milestone 里面。常见的例子是不同的版本（version）和迭代（sprint），都可以做成 Milestone。</p>\n\n<p>新建 Milestone，要在 Issues 面板的首页，点击 Milestones 按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082410.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dcea1e337f28df575d0dcbc5a22456d7f352590bc\" alt=\"\" title=\"\"></p>\n\n<p>这时，再接着点击 New milestone 按钮，然后填写 Milestone 的名称和内容，还可以指定到期时间。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082429.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4fe775a81b73d1458c48b0744f50e5cce13a6e46\" alt=\"\" title=\"\"></p>\n\n<h3>3.6 全局视图</h3>\n\n<p>Issues 面板只能查看和操作当前仓库，Github 还提供全局视图，让用户查看和操作所有与自己相关的 Issue。</p>\n\n<p>访问 <a href=\"https://github.com/issues\">github.com/issues</a> 这个网址，就可以打开全局视图。里面的 Issue 分成三类。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082430.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De3fd916e35530d8257addae4e47994713d9baa2a\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <ul>\n<li>Created：你创建的 Issue</li>\n<li>Assigned：分配给你的 Issue</li>\n<li>Mentioned：提及你的 Issue</li>\n</ul>\n</blockquote>\n\n<p>Created 和 Assigned 的含义显而易见，Mentioned 是指他人在 Issue 里面 @ 了你。下面是一个例子。</p>\n\n<blockquote>\n  <p>It looks like the new widget form is broken on Safari. When I try and create the widget, Safari crashes. This is reproducible on 10.8, but not 10.9. Maybe a browser bug?</p>\n\n<p>/cc @kneath @jresig</p>\n</blockquote>\n\n<p>全局视图还提供了搜索、过滤和排序功能。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082431.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3570186fbeed57cfaf044ecf286c5c7fe6671b78\" alt=\"\" title=\"\"></p>\n\n<h2>四、看板功能</h2>\n\n<h3>4.1 看板是什么？</h3>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Kanban_%28development%29\">看板</a>（kanban）是敏捷开发的重要手段，主要用于项目的进度管理。所有需要完成的任务，都做成卡片，贴在一块白板上面，这就是看板。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082411.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2f40562a719c2511d000fb3235b58d963eca2a73\" alt=\"\" title=\"\"></p>\n\n<p>按照不同的阶段，看板分成若干列。上图是一种常见的分法，将项目周期分成三列。</p>\n\n<blockquote>\n  <ul>\n<li>Todo （待开发）</li>\n<li>Doing （开发中）</li>\n<li>Done （已完成）</li>\n</ul>\n</blockquote>\n\n<p>你可以根据实际情况，分出更多的列。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082412.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8b2194dde56ea3edf129b1a0886fb179fe1fe2c5\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <ul>\n<li>Todo （待安排）</li>\n<li>Plan （计划）</li>\n<li>Develop （开发）</li>\n<li>Test （测试）</li>\n<li>Deploy （部署）</li>\n<li>Done （已完成）</li>\n</ul>\n</blockquote>\n\n<h3>4.2 Github 的看板功能</h3>\n\n<p>Github 提供 Issue 看板。首先，在仓库首页进入 Projects 面板。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082414.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D90f26794a3f295bfcdad8c98a02a5fc78e9f2c02\" alt=\"\" title=\"\"></p>\n\n<p>然后，点击 New Project 按钮，新建一个 Project，比如&quot;2.0 版&quot;。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082415.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D9e593a97e437229d7526cfa52d130bc633ba36fc\" alt=\"\" title=\"\"></p>\n\n<p>接着，点击 Add column 按钮，为该项目新建若干列。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082416.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc9d7ac1f2f9ed34bff8dc1fb5421c4c57771b6be\" alt=\"\" title=\"\"></p>\n\n<p>最后，将 Issue 分配到对应的列，就新建成功了一个看板视图。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082432.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfee841ca19f5ef770ea51e4ada30b42ab4c14a95\" alt=\"\" title=\"\"></p>\n\n<p>Issue 可以从一列拖到另一列，表示从一个阶段进入另一个阶段。</p>\n\n<p>许多<a href=\"https://github.com/marketplace/category/project-management\">第三方工具</a>可以增强 Github 的看板功能，最著名的是 <a href=\"https://github.com/marketplace/zenhub\">Zenhub</a>，这里就不详细介绍了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082417.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D58ad7c43a1ff36a19f220a1c9670ef0765e6f64c\" alt=\"\" title=\"\"></p>\n\n<h2>五、码云的 Issue 系统</h2>\n\n<p>除了 Github 以外，<a href=\"https://gitlab.com/\">Gitlab</a> 也提供免费的 Issues 管理系统，而且 比前者更易用。但是，我不打算介绍它，而是想介绍<a href=\"http://www.oschina.net/\">开源中国社区</a>推出的代码托管服务<a href=\"https://gitee.com/\">码云</a>（<a href=\"https://gitee.com/\">Gitee.com</a>）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082440.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0de8b1a8aa4421e84b743bc905ceda82c2d74218\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"https://gitee.com/\">码云</a>是 Gitlab 的深度定制，提供汉语界面，符合国人的使用习惯，并且访问速度极快，我感觉比 Gitlab 快了一个数量级。另一方面，开源中国的红薯老大一直支持我，我也想借这个机会，推广一下他们的产品，让更多的人知道这个优秀的国产 SaaS 服务。</p>\n\n<h3>5.1 新建 Issue</h3>\n\n<p>码云的每个仓库都有一个 <a href=\"https://gitee.com/moce-technology_demo/jfinal/issues\">Issues 面板</a>。进入后，点击新建 Issue，就可以创建 Issue 了，里面的设置项比 Github 丰富好多。（注意，只有仓库的管理员才能看到设置项。）</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082435.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D379405c22be0c979cc098bbac7965bd9465ab92c\" alt=\"\" title=\"\"></p>\n\n<p>其中的&quot;负责人&quot;（Assignee）、&quot;标签&quot;（Label）、&quot;里程碑&quot;（Milestone）与 Github 完全一致。&quot;关联分支&quot;指定 Issue 归属于哪一个分支，&quot;开始时间&quot;和&quot;结束时间&quot;指定处理日程。&quot;置顶选项&quot;指定哪些 Issue 出现在最前面，而且还分成高中低三档。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082436.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0e804d21e3d2805d666c4ddd65ee23814d3e1c42\" alt=\"\" title=\"\"></p>\n\n<p>由于设置多，所以 Issue 列表提供的过滤开关也多。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082434.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6ffed0cb25d1e0cacd38525546660dbf22143e8f\" alt=\"\" title=\"\"></p>\n\n<h3>5.2 看板功能</h3>\n\n<p>码云的<a href=\"https://gitee.com/moce-technology_demo/jfinal/board\">看板功能</a>比 Github 更友好，直接提供四个现成的看板。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082437.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Ddc3594b7d69b971e829f952897c44948eced85d7\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <ul>\n<li>待处理</li>\n<li>进行中</li>\n<li>已完成</li>\n<li>已验收</li>\n</ul>\n</blockquote>\n\n<p>所有 Issue 的初始状态都是&quot;待处理&quot;，用户可以手动把它们拖到其他列。</p>\n\n<h3>5.3 企业版</h3>\n\n<p>码云跟 Gitlab 一样，也提供<a href=\"https://gitee.com/enterprises\">企业版</a>。里面的<a href=\"http://git.oschina.net/hesheng168/dashboard/issues\">&quot;任务&quot;</a>模块有一个强大的 Issue 全局视图，分成四种浏览模式。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082421.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfffee0593fa24e6167a8bf0be682673c796b1438\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <ul>\n<li>指派给我的</li>\n<li>我发布的</li>\n<li>我参与的</li>\n<li>全部任务</li>\n</ul>\n</blockquote>\n\n<p>这是默认的列表视图，可以点击右上角，切换成全局的&quot;看板视图&quot;。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082439.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D64c21980c94a2799b0cf968b2800a7f0003b7131\" alt=\"\" title=\"\"></p>\n\n<p>这个界面还可以直接新建任务，而不用进入仓库主页。新建任务时，允许指定&quot;关联项目&quot;、&quot;负责人&quot;和&quot;预计工时&quot;。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082422.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0fc822cedcf6c7bc0e3d3fd3b7470966b0ad4d33\" alt=\"\" title=\"\"></p>\n\n<p>新建任务以后，还可以对任务进行再次编辑，这时可以设置&quot;优先级&quot;、&quot;关联项目&quot;和&quot;子项目&quot;等。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082424.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Def8b2126c9dd2ada373114cf5e3ff7b6046ccd12\" alt=\"\" title=\"\"></p>\n\n<p>我就介绍到这里了，接下来你可以点击进入 <a href=\"https://gitee.com/enterprises/demo\">Demo</a>，体验一下上面介绍的各项功能。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017082404.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612656%3B1553148656%26q-key-time%3D1521612656%3B1553148656%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D36bc56309b08a4796e66fcd5af7ce758d82ccf04","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/08/issue.html","sourceType":"blog","time":"2017-08-29 08:23:12"},{"id":27,"name":"你的鞋都比你聪明","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>1、</p>\n\n<p>2017年2月，世界移动通讯大会（MWC）在巴塞罗那召开，今年的演讲嘉宾是日本首富软银集团 CEO 孙正义。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D755b63ce935f0d761e1aebfd5a65a2004f0f93b1\" alt=\"\" title=\"\"></p>\n\n<p>他的演讲主题是<a href=\"http://tech.sina.com.cn/it/2017-02-28/doc-ifyavvsh7051757.shtml\">《为什么人工智能肯定会超越人类？》</a>。他提到，人类的智能是一个正态分布，IQ 测试假设平均智能是100，标准差是15，因此95%的人的智商在正负两个标准差范围内（即70～130）。爱因斯坦的智商可以达到190，也就是<a href=\"https://baike.baidu.com/item/%E5%85%AD%E4%B8%AA%E6%A0%87%E5%87%86%E5%B7%AE\">六个标准差</a>，这意味着他比99.99966%的人都要聪明。但是<strong>从整体来看，人类的智能是有限的。</strong></p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081302.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec547b6798c1ca498cf0ca6bc8ed05c04102e56a\" alt=\"\" title=\"\"></p>\n\n<p>人类的智能也几乎固定不变，不会随着时间发展，很难说现代人就比古人聪明，未来的人也未必更聪明。因为智能的生理基础是大脑，人的脑容量只有1300多毫升，包含了300亿个神经元细胞。一万多年前就是如此，再过一万年，大脑可能还是这样大小，不太可能越长越大。</p>\n\n<p>人工智能的基础是大规模集成电路，指甲大小（1平方厘米）的芯片，可以集成上百万个电子元件。有人预测，这个数字每过两年就翻一倍。孙正义的预测是，30年后的集成电路，电子元件将是现在的100万倍，即1万亿个！相比大脑的神经元细胞（300亿个），他的<a href=\"http://www.nbd.com.cn/articles/2017-07-29/1133397.html\">结论</a>是，人工智能大约在2018年就能达到人类的智力，30年后的2047年，人工智能的 IQ 将达到10000。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081303.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D54bbe4eb2b57d64e9bf04be445badcfafe3ef2ff\" alt=\"\" title=\"\"></p>\n\n<p>（图片说明：2047年的晶体管集成程度，将是2017年的100万倍。）</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081304.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Deaa37f10b9dc081dfefb6946718ceec7b831138d\" alt=\"\" title=\"\"></p>\n\n<p>（图片说明：左下角是人的 IQ，右侧是人工智能的 IQ。）</p>\n\n<blockquote>\n  <p><strong>&quot;你想想，那个时候你的鞋子里内置芯片的电子元件数量，都比你的脑细胞还多。你穿的鞋子都比你聪明。&quot;</strong></p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081307.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D9cccdfcac7709225563de1774d83d143b5e5984b\" alt=\"\" title=\"\"></p>\n\n<p>2、</p>\n\n<p>孙正义出身底层，祖父是从韩国大邱移民至日本当矿工的朝鲜人。他的巨额财富来自对于未来的准确判断和投资。他早期曾经投资过思科和雅虎，都发了大财。1999年，他遇到了马云，只谈了6分钟，就决定投资2000万美元，成了阿里巴巴最大股东，这笔钱的回报率后来超过<a href=\"http://tech.sina.com.cn/i/2014-09-19/18349625738.shtml\">2500倍</a>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081308.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D881cce1d59c423b3438bd7c5fdffa0ee6db662c1\" alt=\"\" title=\"\"></p>\n\n<p>如果这一次孙正义依然正确，那么未来不仅仅是鞋子，你的住宅、汽车、手表、马桶等等，所有可以装上芯片的东西都会比你聪明。孙正义说，他的钱都投资在三个领域----人工智能、物联网和智能机器人----赌这个预言一定成真。</p>\n\n<p>实际上，智能鞋子已经上市了，内置芯片，&quot;搭载六轴传感器，可以测量日常步数，里程，消耗等数据，在开启跑步模式后，还可计算并记录跑步过程中前掌着地，触地时长和腾空比例的专业运动数据，根据这些数据实时调整运动方式方法。&quot;还有的鞋子会<a href=\"http://www.leesharing.com/2016/11/nike.html\">自动系鞋带</a>，&quot;用户穿上时，会激活脚后跟的传感器，运动鞋就开始自动调整松紧&quot;。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081309.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2aabc86641de0aa818120e673622432bf1aac265\" alt=\"\" title=\"\"></p>\n\n<p>现在的鞋就这么先进了，再过30年，它们会变成什么样？</p>\n\n<p>3、</p>\n\n<p>我们周围的所有东西，以后都会装上传感器和芯片，都会具备智能，比人类更聪明。现在已经有了智能手机、智能电视机、智能手表、智能电饭煲、智能牙刷、智能内衣......这样的智能产品将会越来越多。</p>\n\n<p>它们收集和处理各种数据，到头来变得比你更了解你。你还记得上个月的今天，你去了哪里，停留了多久，遇到谁，吃了什么吗？你每天几点入睡，每分钟的心跳是多少，有没有做梦？它们都知道。</p>\n\n<p>这些海量的数据，经过统计学处理，就可以精确地刻画你，发现你最有可能的行为是什么。更重要的是，它们还会自动替你做出最优决策。要是你不知道下一步走哪条路，就让你的鞋做决定好了。</p>\n\n<p>4、</p>\n\n<p>以 GPS 为例，开车去市中心，根本不用自己选路线，导航软件早就选好了。就算很熟悉道路，你最好还是听从软件的安排，因为软件比你掌握更多的信息。有一回，我打的去火车站，出租车司机发现软件给出的路线不是最近的，自做主张抄近路，没料到有一段单行道正在施工，根本走不通。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081310.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D307e619b42e87f9e8ab65d3c88e0d81bf55ac103\" alt=\"\" title=\"\"></p>\n\n<p><strong>这只是一个小例子：软件的选择优于你的选择。以后不仅仅是路线，所有的决定都将是软件替你来做。</strong></p>\n\n<p>你想晚上去锻炼，是健身房好，还是马路慢跑好？你的鞋就会告诉你，慢跑比较好，因为天气晴朗，风力适中，公共绿地里面的樱花开了，一路上可以闻到香气，而且你的小区正在流行感冒，健身房里面被感染的可能性大于40%。</p>\n\n<p>再比如公司聚会，你不知道该找谁聊天，但是你的鞋知道。经过分析社交网站的资料，发现你与张小姐的爱好相似，你们上一周还看过相同的电影，碰巧她还是单身，于是你的鞋建议你走向张小姐，互相认识一下。</p>\n\n<p>机器比你聪明，知道你的 DNA，了解你每顿饭摄入的热量，它比你更了解你，还了解其他相关信息，那么<strong>最优决策就是自己不要决策了，都听从机器的安排。它的决策才是对你最有利的决策。</strong></p>\n\n<p>5、</p>\n\n<p>如果将来都是人工智能代替人在决策，那么个人、个性、自我这些词就没多大意义了。古希腊神庙刻着一行字，&quot;认识你自己&quot;；苹果公司创始人乔布斯说，你要听从内心的声音。这些都不必要了。</p>\n\n<p><strong>算法刻画的你，才是真正的你。</strong>《未来简史》里面说：</p>\n\n<blockquote>\n  <p>&quot;别再浪费时间研究哲学、冥想或精神分析，你应该系统性地收集自己的生物统计数据，允许算法为你分析这些数据，告诉你你是谁、该做些什么。&quot;</p>\n</blockquote>\n\n<p>曾经有一本畅销书《内向者优势》，解释内向和外向根本不是性格问题，而是生理问题。内向者的<a href=\"https://baike.baidu.com/item/%E5%A4%9A%E5%B7%B4%E8%83%BA/62597\">多巴胺</a>分泌比较少，在公开场合容易产生疲倦，而外向者的多巴胺分泌比较多，人越多越容易兴奋。将来，人工智能会精确知道每一类活动的多巴胺指数，选出最合适你的活动，这比你自己选择可靠多了。</p>\n\n<p>6、</p>\n\n<p>以前，人们认为，&quot;智能&quot;和&quot;意识&quot;差不多是同义词，不能独立存在，只有具备意识的生物才可能具备智能。</p>\n\n<p>人工智能的兴起，使得这种想法不成立了。智能完全可以不需要意识，独立存在。<strong>没有意识的机器，也可以具备智能。</strong>这种无意识的智能，依靠的不是认知，而是模式匹配。我新买了一台扫地机器人，它对我家的房型一清二楚，根本不会撞墙。原因不是它意识到那里有墙，而是经过第一天的反复试错以后，它记住了那里没有路。再比如，机器能够认出照片里的鸟，不是因为它认识鸟，而是因为它发现这个形状可以与数据库里面鸟的形状匹配。</p>\n\n<p>意识与智能的分离，最受企业欢迎。因为企业需要的是智能，而不是意识。员工如果能够减少个人意识，增加更多的生产线上的智能，就能更符合企业的需要。</p>\n\n<p>你的鞋一天天变得更加智能，你由于不用决策了，你本人的智能高低也就不重要了，你的自我意识也会变得淡漠，因为发展个性的结果，无非就是变成你的鞋预测你将会成为的样子。<strong>最终来说，人工智能不仅取代了一部分人的智能，还将使得人们缺乏个人意识，不知道自己主张什么，想要什么，因为软件都替你安排好了。</strong>西方的民主制度可能也不必要了，因为一人一票的公民投票有一个前提：每个人知道自己想要什么。</p>\n\n<p>（说明：本文选自我正在写的新书《未来世界的幸存者》，点击<a href=\"http://survivor.ruanyifeng.com/\">这里</a>免费阅读全书。）</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D755b63ce935f0d761e1aebfd5a65a2004f0f93b1","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/08/smart-shoes.html","sourceType":"blog","time":"2017-08-22 07:28:09"},{"id":28,"name":"全文搜索引擎 Elasticsearch 入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p><a href=\"https://baike.baidu.com/item/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E\">全文搜索</a>属于最常见的需求，开源的 <a href=\"https://www.elastic.co/\">Elasticsearch</a> （以下简称 Elastic）是目前全文搜索引擎的首选。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd261f995ee64beef1553ce344501377c8540ebb0\" alt=\"\" title=\"\"></p>\n\n<p>Elastic 的底层是开源库 <a href=\"https://lucene.apache.org/\">Lucene</a>。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</p>\n\n<p>本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。</p>\n\n<h2>一、安装</h2>\n\n<p>Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考<a href=\"https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-debian-8\">这篇文章</a>，注意要保证环境变量<code>JAVA_HOME</code>正确设置。</p>\n\n<p>安装完 Java，就可以跟着<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/zip-targz.html\">官方文档</a>安装 Elastic。直接下载压缩包比较简单。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip\n$ unzip elasticsearch-5.5.1.zip\n$ cd elasticsearch-5.5.1/ \n</code></pre></blockquote>\n\n<p>接着，进入解压后的目录，运行下面的命令，启动 Elastic。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ ./bin/elasticsearch\n</code></pre></blockquote>\n\n<p>如果这时<a href=\"https://github.com/spujadas/elk-docker/issues/92\">报错</a>&quot;max virtual memory areas vm.max<em>map</em>count [65530] is too low&quot;，要运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo sysctl -w vm.max_map_count=262144\n</code></pre></blockquote>\n\n<p>如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl localhost:9200\n\n{\n  &quot;name&quot; : &quot;atntrTf&quot;,\n  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,\n  &quot;cluster_uuid&quot; : &quot;tf9250XhQ6ee4h7YI11anA&quot;,\n  &quot;version&quot; : {\n    &quot;number&quot; : &quot;5.5.1&quot;,\n    &quot;build_hash&quot; : &quot;19c13d0&quot;,\n    &quot;build_date&quot; : &quot;2017-07-18T20:44:24.823Z&quot;,\n    &quot;build_snapshot&quot; : false,\n    &quot;lucene_version&quot; : &quot;6.6.0&quot;\n  },\n  &quot;tagline&quot; : &quot;You Know, for Search&quot;\n}\n</code></pre></blockquote>\n\n<p>上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。</p>\n\n<p>按下 Ctrl + C，Elastic 就会停止运行。</p>\n\n<p>默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的<code>config/elasticsearch.yml</code>文件，去掉<code>network.host</code>的注释，将它的值改成<code>0.0.0.0</code>，然后重新启动 Elastic。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nnetwork.host: 0.0.0.0\n</code></pre></blockquote>\n\n<p>上面代码中，设成<code>0.0.0.0</code>让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。</p>\n\n<h2>二、基本概念</h2>\n\n<h3>2.1 Node 与 Cluster</h3>\n\n<p>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p>\n\n<p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p>\n\n<h3>2.2 Index</h3>\n\n<p>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p>\n\n<p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p>\n\n<p>下面的命令可以查看当前节点的所有 Index。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X GET &apos;http://localhost:9200/_cat/indices?v&apos;\n</code></pre></blockquote>\n\n<h3>2.3 Document</h3>\n\n<p>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p>\n\n<p>Document 使用 JSON 格式表示，下面是一个例子。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n{\n  &quot;user&quot;: &quot;张三&quot;,\n  &quot;title&quot;: &quot;工程师&quot;,\n  &quot;desc&quot;: &quot;数据库管理&quot;\n}\n</code></pre></blockquote>\n\n<p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p>\n\n<h3>2.4 Type</h3>\n\n<p>Document 可以分组，比如<code>weather</code>这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p>\n\n<p>不同的 Type 应该有相似的结构（schema），举例来说，<code>id</code>字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的<a href=\"https://www.elastic.co/guide/en/elasticsearch/guide/current/mapping.html\">一个区别</a>。性质完全不同的数据（比如<code>products</code>和<code>logs</code>）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p>\n\n<p>下面的命令可以列出每个 Index 所包含的 Type。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/_mapping?pretty=true&apos;\n</code></pre></blockquote>\n\n<p>根据<a href=\"https://www.elastic.co/blog/index-type-parent-child-join-now-future-in-elasticsearch\">规划</a>，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p>\n\n<h2>三、新建和删除 Index</h2>\n\n<p>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫<code>weather</code>的 Index。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X PUT &apos;localhost:9200/weather&apos;\n</code></pre></blockquote>\n\n<p>服务器返回一个 JSON 对象，里面的<code>acknowledged</code>字段表示操作成功。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n{\n  &quot;acknowledged&quot;:true,\n  &quot;shards_acknowledged&quot;:true\n}\n</code></pre></blockquote>\n\n<p>然后，我们发出 DELETE 请求，删除这个 Index。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X DELETE &apos;localhost:9200/weather&apos;\n</code></pre></blockquote>\n\n<h2>四、中文分词设置</h2>\n\n<p>首先，安装中文分词插件。这里使用的是 <a href=\"https://github.com/medcl/elasticsearch-analysis-ik/\">ik</a>，也可以考虑其他插件（比如 <a href=\"https://www.elastic.co/guide/en/elasticsearch/plugins/current/analysis-smartcn.html\">smartcn</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n$ ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip\n</code></pre></blockquote>\n\n<p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。</p>\n\n<p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p>\n\n<p>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X PUT &apos;localhost:9200/accounts&apos; -d &apos;\n{\n  &quot;mappings&quot;: {\n    &quot;person&quot;: {\n      &quot;properties&quot;: {\n        &quot;user&quot;: {\n          &quot;type&quot;: &quot;text&quot;,\n          &quot;analyzer&quot;: &quot;ik_max_word&quot;,\n          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;\n        },\n        &quot;title&quot;: {\n          &quot;type&quot;: &quot;text&quot;,\n          &quot;analyzer&quot;: &quot;ik_max_word&quot;,\n          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;\n        },\n        &quot;desc&quot;: {\n          &quot;type&quot;: &quot;text&quot;,\n          &quot;analyzer&quot;: &quot;ik_max_word&quot;,\n          &quot;search_analyzer&quot;: &quot;ik_max_word&quot;\n        }\n      }\n    }\n  }\n}&apos;\n</code></pre></blockquote>\n\n<p>上面代码中，首先新建一个名称为<code>accounts</code>的 Index，里面有一个名称为<code>person</code>的 Type。<code>person</code>有三个字段。</p>\n\n<blockquote>\n  <ul>\n<li>user</li>\n<li>title</li>\n<li>desc</li>\n</ul>\n</blockquote>\n\n<p>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。</p>\n\n<p>Elastic 的分词器称为 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html\">analyzer</a>。我们对每个字段指定分词器。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n&quot;user&quot;: {\n  &quot;type&quot;: &quot;text&quot;,\n  &quot;analyzer&quot;: &quot;ik_max_word&quot;,\n  &quot;search_analyzer&quot;: &quot;ik_max_word&quot;\n}\n</code></pre></blockquote>\n\n<p>上面代码中，<code>analyzer</code>是字段文本的分词器，<code>search_analyzer</code>是搜索词的分词器。<code>ik_max_word</code>分词器是插件<code>ik</code>提供的，可以对文本进行最大数量的分词。</p>\n\n<h2>五、数据操作</h2>\n\n<h3>5.1 新增记录</h3>\n\n<p>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向<code>/accounts/person</code>发送请求，就可以新增一条人员记录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;\n{\n  &quot;user&quot;: &quot;张三&quot;,\n  &quot;title&quot;: &quot;工程师&quot;,\n  &quot;desc&quot;: &quot;数据库管理&quot;\n}&apos; \n</code></pre></blockquote>\n\n<p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n{\n  &quot;_index&quot;:&quot;accounts&quot;,\n  &quot;_type&quot;:&quot;person&quot;,\n  &quot;_id&quot;:&quot;1&quot;,\n  &quot;_version&quot;:1,\n  &quot;result&quot;:&quot;created&quot;,\n  &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0},\n  &quot;created&quot;:true\n}\n</code></pre></blockquote>\n\n<p>如果你仔细看，会发现请求路径是<code>/accounts/person/1</code>，最后的<code>1</code>是该条记录的 Id。它不一定是数字，任意字符串（比如<code>abc</code>）都可以。</p>\n\n<p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X POST &apos;localhost:9200/accounts/person&apos; -d &apos;\n{\n  &quot;user&quot;: &quot;李四&quot;,\n  &quot;title&quot;: &quot;工程师&quot;,\n  &quot;desc&quot;: &quot;系统管理&quot;\n}&apos;\n</code></pre></blockquote>\n\n<p>上面代码中，向<code>/accounts/person</code>发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，<code>_id</code>字段就是一个随机字符串。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n{\n  &quot;_index&quot;:&quot;accounts&quot;,\n  &quot;_type&quot;:&quot;person&quot;,\n  &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;,\n  &quot;_version&quot;:1,\n  &quot;result&quot;:&quot;created&quot;,\n  &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0},\n  &quot;created&quot;:true\n}\n</code></pre></blockquote>\n\n<p>注意，如果没有先创建 Index（这个例子是<code>accounts</code>），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p>\n\n<h3>5.2 查看记录</h3>\n\n<p>向<code>/Index/Type/Id</code>发出 GET 请求，就可以查看这条记录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/1?pretty=true&apos;\n</code></pre></blockquote>\n\n<p>上面代码请求查看<code>/accounts/person/1</code>这条记录，URL 的参数<code>pretty=true</code>表示以易读的格式返回。</p>\n\n<p>返回的数据中，<code>found</code>字段表示查询成功，<code>_source</code>字段返回原始记录。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n{\n  &quot;_index&quot; : &quot;accounts&quot;,\n  &quot;_type&quot; : &quot;person&quot;,\n  &quot;_id&quot; : &quot;1&quot;,\n  &quot;_version&quot; : 1,\n  &quot;found&quot; : true,\n  &quot;_source&quot; : {\n    &quot;user&quot; : &quot;张三&quot;,\n    &quot;title&quot; : &quot;工程师&quot;,\n    &quot;desc&quot; : &quot;数据库管理&quot;\n  }\n}\n</code></pre></blockquote>\n\n<p>如果 Id 不正确，就查不到数据，<code>found</code>字段就是<code>false</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/weather/beijing/abc?pretty=true&apos;\n\n{\n  &quot;_index&quot; : &quot;accounts&quot;,\n  &quot;_type&quot; : &quot;person&quot;,\n  &quot;_id&quot; : &quot;abc&quot;,\n  &quot;found&quot; : false\n}\n</code></pre></blockquote>\n\n<h3>5.3 删除记录</h3>\n\n<p>删除记录就是发出 DELETE 请求。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X DELETE &apos;localhost:9200/accounts/person/1&apos;\n</code></pre></blockquote>\n\n<p>这里先不要删除这条记录，后面还要用到。</p>\n\n<h3>5.4 更新记录</h3>\n\n<p>更新记录就是使用 PUT 请求，重新发送一次数据。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X PUT &apos;localhost:9200/accounts/person/1&apos; -d &apos;\n{\n    &quot;user&quot; : &quot;张三&quot;,\n    &quot;title&quot; : &quot;工程师&quot;,\n    &quot;desc&quot; : &quot;数据库管理，软件开发&quot;\n}&apos; \n\n{\n  &quot;_index&quot;:&quot;accounts&quot;,\n  &quot;_type&quot;:&quot;person&quot;,\n  &quot;_id&quot;:&quot;1&quot;,\n  &quot;_version&quot;:2,\n  &quot;result&quot;:&quot;updated&quot;,\n  &quot;_shards&quot;:{&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0},\n  &quot;created&quot;:false\n}\n</code></pre></blockquote>\n\n<p>上面代码中，我们将原始数据从&quot;数据库管理&quot;改成&quot;数据库管理，软件开发&quot;。 返回结果里面，有几个字段发生了变化。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n&quot;_version&quot; : 2,\n&quot;result&quot; : &quot;updated&quot;,\n&quot;created&quot; : false\n</code></pre></blockquote>\n\n<p>可以看到，记录的 Id 没变，但是版本（version）从<code>1</code>变成<code>2</code>，操作类型（result）从<code>created</code>变成<code>updated</code>，<code>created</code>字段变成<code>false</code>，因为这次不是新建记录。</p>\n\n<h2>六、数据查询</h2>\n\n<h3>6.1 返回所有记录</h3>\n\n<p>使用 GET 方法，直接请求<code>/Index/Type/_search</code>，就会返回所有记录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/_search&apos;\n\n{\n  &quot;took&quot;:2,\n  &quot;timed_out&quot;:false,\n  &quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0},\n  &quot;hits&quot;:{\n    &quot;total&quot;:2,\n    &quot;max_score&quot;:1.0,\n    &quot;hits&quot;:[\n      {\n        &quot;_index&quot;:&quot;accounts&quot;,\n        &quot;_type&quot;:&quot;person&quot;,\n        &quot;_id&quot;:&quot;AV3qGfrC6jMbsbXb6k1p&quot;,\n        &quot;_score&quot;:1.0,\n        &quot;_source&quot;: {\n          &quot;user&quot;: &quot;李四&quot;,\n          &quot;title&quot;: &quot;工程师&quot;,\n          &quot;desc&quot;: &quot;系统管理&quot;\n        }\n      },\n      {\n        &quot;_index&quot;:&quot;accounts&quot;,\n        &quot;_type&quot;:&quot;person&quot;,\n        &quot;_id&quot;:&quot;1&quot;,\n        &quot;_score&quot;:1.0,\n        &quot;_source&quot;: {\n          &quot;user&quot; : &quot;张三&quot;,\n          &quot;title&quot; : &quot;工程师&quot;,\n          &quot;desc&quot; : &quot;数据库管理，软件开发&quot;\n        }\n      }\n    ]\n  }\n}\n</code></pre></blockquote>\n\n<p>上面代码中，返回结果的 <code>took</code>字段表示该操作的耗时（单位为毫秒），<code>timed_out</code>字段表示是否超时，<code>hits</code>字段表示命中的记录，里面子字段的含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>total</code>：返回记录数，本例是2条。</li>\n<li><code>max_score</code>：最高的匹配程度，本例是<code>1.0</code>。</li>\n<li><code>hits</code>：返回的记录组成的数组。</li>\n</ul>\n</blockquote>\n\n<p>返回的记录中，每条记录都有一个<code>_score</code>字段，表示匹配的程序，默认是按照这个字段降序排列。</p>\n\n<h3>6.2 全文搜索</h3>\n\n<p>Elastic 的查询非常特别，使用自己的<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl.html\">查询语法</a>，要求 GET 请求带有数据体。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;\n{\n  &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件&quot; }}\n}&apos;\n</code></pre></blockquote>\n\n<p>上面代码使用 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-match-query.html\">Match 查询</a>，指定的匹配条件是<code>desc</code>字段里面包含&quot;软件&quot;这个词。返回结果如下。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n{\n  &quot;took&quot;:3,\n  &quot;timed_out&quot;:false,\n  &quot;_shards&quot;:{&quot;total&quot;:5,&quot;successful&quot;:5,&quot;failed&quot;:0},\n  &quot;hits&quot;:{\n    &quot;total&quot;:1,\n    &quot;max_score&quot;:0.28582606,\n    &quot;hits&quot;:[\n      {\n        &quot;_index&quot;:&quot;accounts&quot;,\n        &quot;_type&quot;:&quot;person&quot;,\n        &quot;_id&quot;:&quot;1&quot;,\n        &quot;_score&quot;:0.28582606,\n        &quot;_source&quot;: {\n          &quot;user&quot; : &quot;张三&quot;,\n          &quot;title&quot; : &quot;工程师&quot;,\n          &quot;desc&quot; : &quot;数据库管理，软件开发&quot;\n        }\n      }\n    ]\n  }\n}\n</code></pre></blockquote>\n\n<p>Elastic 默认一次返回10条结果，可以通过<code>size</code>字段改变这个设置。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;\n{\n  &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;管理&quot; }},\n  &quot;size&quot;: 1\n}&apos;\n</code></pre></blockquote>\n\n<p>上面代码指定，每次只返回一条结果。</p>\n\n<p>还可以通过<code>from</code>字段，指定位移。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;\n{\n  &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;管理&quot; }},\n  &quot;from&quot;: 1,\n  &quot;size&quot;: 1\n}&apos;\n</code></pre></blockquote>\n\n<p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p>\n\n<h3>6.3 逻辑运算</h3>\n\n<p>如果有多个搜索关键字， Elastic 认为它们是<code>or</code>关系。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;\n{\n  &quot;query&quot; : { &quot;match&quot; : { &quot;desc&quot; : &quot;软件 系统&quot; }}\n}&apos;\n</code></pre></blockquote>\n\n<p>上面代码搜索的是<code>软件 or 系统</code>。</p>\n\n<p>如果要执行多个关键词的<code>and</code>搜索，必须使用<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/5.5/query-dsl-bool-query.html\">布尔查询</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl &apos;localhost:9200/accounts/person/_search&apos;  -d &apos;\n{\n  &quot;query&quot;: {\n    &quot;bool&quot;: {\n      &quot;must&quot;: [\n        { &quot;match&quot;: { &quot;desc&quot;: &quot;软件&quot; } },\n        { &quot;match&quot;: { &quot;desc&quot;: &quot;系统&quot; } }\n      ]\n    }\n  }\n}&apos;\n</code></pre></blockquote>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html\">ElasticSearch 官方手册</a></li>\n<li><a href=\"https://www.elastic.co/blog/a-practical-introduction-to-elasticsearch\">A Practical Introduction to Elasticsearch</a></li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017081701.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612657%3B1553148657%26q-key-time%3D1521612657%3B1553148657%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd261f995ee64beef1553ce344501377c8540ebb0","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html","sourceType":"blog","time":"2017-08-17 07:36:20"},{"id":29,"name":"Koa 框架教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>Node 主要用在开发 Web 应用。这决定了使用 Node，往往离不开 Web 应用框架。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080801.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1add65706a376562e9a250da2aeae5681b160f54\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"http://koajs.com/\">Koa</a> 就是一种简单好用的 Web 框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现，很符合 Unix 哲学。</p>\n\n<p>本文从零开始，循序渐进，教会你如何使用 Koa 写出自己的 Web 应用。每一步都有简洁易懂的示例，希望让大家一看就懂。</p>\n\n<h2>零、准备</h2>\n\n<p>首先，检查 Node 版本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node -v\nv8.0.0\n</code></pre></blockquote>\n\n<p>Koa 必须使用 7.6 以上的版本。如果你的版本低于这个要求，就要先升级 Node。</p>\n\n<p>然后，克隆本文的配套<a href=\"https://github.com/ruanyf/koa-demos\">示例库</a>。（如果不方便使用 Git，也可以下载 <a href=\"https://github.com/ruanyf/koa-demos/archive/master.zip\">zip 文件</a>解压。）</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ git clone https://github.com/ruanyf/koa-demos.git\n</code></pre></blockquote>\n\n<p>接着，进入示例库，安装依赖。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ cd koa-demos\n$ npm install\n</code></pre></blockquote>\n\n<p>所有示例源码，都在 <a href=\"https://github.com/ruanyf/koa-demos/tree/master/demos\">demos</a>  目录下面。</p>\n\n<h2>一、基本用法</h2>\n\n<h3>1.1 架设 HTTP 服务</h3>\n\n<p>只要<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/01.js\">三行代码</a>，就可以用 Koa 架设一个 HTTP 服务。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/01.js\nconst Koa = require(&apos;koa&apos;);\nconst app = new Koa();\n\napp.listen(3000);\n</code></pre></blockquote>\n\n<p>运行这个脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/01.js\n</code></pre></blockquote>\n\n<p>打开浏览器，访问 http://127.0.0.1:3000 。你会看到页面显示&quot;Not Found&quot;，表示没有发现任何内容。这是因为我们并没有告诉 Koa 应该显示什么内容。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080802.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De3cc54c7a435c11dde1b798667ac2dfaac52af59\" alt=\"\" title=\"\"></p>\n\n<h3>1.2 Context 对象</h3>\n\n<p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>\n\n<p><code>Context.response.body</code>属性就是发送给用户的内容。请看下面的例子（完整的代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/01.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/02.js\nconst Koa = require(&apos;koa&apos;);\nconst app = new Koa();\n\nconst main = ctx =&gt; {\n  ctx.response.body = &apos;Hello World&apos;;\n};\n\napp.use(main);\napp.listen(3000);\n</code></pre></blockquote>\n\n<p>上面代码中，<code>main</code>函数用来设置<code>ctx.response.body</code>。然后，使用<code>app.use</code>方法加载<code>main</code>函数。</p>\n\n<p>你可能已经猜到了，<code>ctx.response</code>代表 HTTP Response。同样地，<code>ctx.request</code>代表 HTTP Request。</p>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/02.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，现在就可以看到&quot;Hello World&quot;了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080803.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db71ff498ffad4f5512480f2f8fc9aced5ddc2011\" alt=\"\" title=\"\"></p>\n\n<h3>1.3 HTTP Response 的类型</h3>\n\n<p>Koa 默认的返回类型是<code>text/plain</code>，如果想返回其他类型的内容，可以先用<code>ctx.request.accepts</code>判断一下，客户端希望接受什么数据（根据 HTTP Request 的<code>Accept</code>字段），然后使用<code>ctx.response.type</code>指定返回类型。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/03.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/03.js\nconst main = ctx =&gt; {\n  if (ctx.request.accepts(&apos;xml&apos;)) {\n    ctx.response.type = &apos;xml&apos;;\n    ctx.response.body = &apos;&lt;data&gt;Hello World&lt;/data&gt;&apos;;\n  } else if (ctx.request.accepts(&apos;json&apos;)) {\n    ctx.response.type = &apos;json&apos;;\n    ctx.response.body = { data: &apos;Hello World&apos; };\n  } else if (ctx.request.accepts(&apos;html&apos;)) {\n    ctx.response.type = &apos;html&apos;;\n    ctx.response.body = &apos;&lt;p&gt;Hello World&lt;/p&gt;&apos;;\n  } else {\n    ctx.response.type = &apos;text&apos;;\n    ctx.response.body = &apos;Hello World&apos;;\n  }\n};\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/03.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，现在看到的就是一个 XML 文档了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080804.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc4fbd5c1b6a51b78f8e2287e7d21c36673598c2a\" alt=\"\" title=\"\"></p>\n\n<h3>1.4 网页模板</h3>\n\n<p>实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/04.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/04.js\nconst fs = require(&apos;fs&apos;);\n\nconst main = ctx =&gt; {\n  ctx.response.type = &apos;html&apos;;\n  ctx.response.body = fs.createReadStream(&apos;./demos/template.html&apos;);\n};\n</code></pre></blockquote>\n\n<p>运行这个 Demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/04.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，看到的就是<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/template.html\">模板文件</a>的内容了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080805.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D15a5eb1736eb4627bb1690a0faf3627d78544f6f\" alt=\"\" title=\"\"></p>\n\n<h2>二、路由</h2>\n\n<h3>2.1 原生路由</h3>\n\n<p>网站一般都有多个页面。通过<code>ctx.request.path</code>可以获取用户请求的路径，由此实现简单的路由。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/05.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/05.js\nconst main = ctx =&gt; {\n  if (ctx.request.path !== &apos;/&apos;) {\n    ctx.response.type = &apos;html&apos;;\n    ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;\n  } else {\n    ctx.response.body = &apos;Hello World&apos;;\n  }\n};\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/05.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000/about ，可以看到一个链接，点击后就跳到首页。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080806.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D516eac44ed3aff264bc97a223f3db28d974f706e\" alt=\"\" title=\"\"></p>\n\n<h3>2.2 koa-route 模块</h3>\n\n<p>原生路由用起来不太方便，我们可以使用封装好的<a href=\"https://www.npmjs.com/package/koa-route\"><code>koa-route</code></a>模块。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/06.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/06.js\nconst route = require(&apos;koa-route&apos;);\n\nconst about = ctx =&gt; {\n  ctx.response.type = &apos;html&apos;;\n  ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;\n};\n\nconst main = ctx =&gt; {\n  ctx.response.body = &apos;Hello World&apos;;\n};\n\napp.use(route.get(&apos;/&apos;, main));\napp.use(route.get(&apos;/about&apos;, about));\n</code></pre></blockquote>\n\n<p>上面代码中，根路径<code>/</code>的处理函数是<code>main</code>，<code>/about</code>路径的处理函数是<code>about</code>。</p>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/06.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000/about ，效果与上一个例子完全相同。</p>\n\n<h3>2.3 静态资源</h3>\n\n<p>如果网站提供静态资源（图片、字体、样式表、脚本......），为它们一个个写路由就很麻烦，也没必要。<a href=\"https://www.npmjs.com/package/koa-static\"><code>koa-static</code></a>模块封装了这部分的请求。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/12.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/12.js\nconst path = require(&apos;path&apos;);\nconst serve = require(&apos;koa-static&apos;);\n\nconst main = serve(path.join(__dirname));\napp.use(main);\n</code></pre></blockquote>\n\n<p>运行这个 Demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/12.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000/12.js，在浏览器里就可以看到这个脚本的内容。</p>\n\n<h3>2.4 重定向</h3>\n\n<p>有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。<code>ctx.response.redirect()</code>方法可以发出一个302跳转，将用户导向另一个路由。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/13.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/13.js\nconst redirect = ctx =&gt; {\n  ctx.response.redirect(&apos;/&apos;);\n  ctx.response.body = &apos;&lt;a href=&quot;/&quot;&gt;Index Page&lt;/a&gt;&apos;;\n};\n\napp.use(route.get(&apos;/redirect&apos;, redirect));\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/13.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。</p>\n\n<h2>三、中间件</h2>\n\n<h3>3.1 Logger 功能</h3>\n\n<p>Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现。</p>\n\n<p>最简单的写法就是在<code>main</code>函数里面增加一行（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/07.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/07.js\nconst main = ctx =&gt; {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  ctx.response.body = &apos;Hello World&apos;;\n};\n</code></pre></blockquote>\n\n<p>运行这个 Demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/07.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，命令行就会输出日志。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n1502144902843 GET /\n</code></pre></blockquote>\n\n<h3>3.2 中间件的概念</h3>\n\n<p>上一个例子里面的 Logger 功能，可以拆分成一个独立函数（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/08.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/08.js\nconst logger = (ctx, next) =&gt; {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  next();\n}\napp.use(logger);\n</code></pre></blockquote>\n\n<p>像上面代码中的<code>logger</code>函数就叫做&quot;中间件&quot;（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。<code>app.use()</code>用来加载中间件。</p>\n\n<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的<code>main</code>也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是<code>next</code>函数。只要调用<code>next</code>函数，就可以把执行权转交给下一个中间件。</p>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/08.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，命令行窗口会显示与上一个例子相同的日志输出。</p>\n\n<h3>3.3 中间件栈</h3>\n\n<p>多个中间件会形成一个栈结构（middle stack），以&quot;先进后出&quot;（first-in-last-out）的顺序执行。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>最外层的中间件首先执行。</li>\n<li>调用<code>next</code>函数，把执行权交给下一个中间件。</li>\n<li>...</li>\n<li>最内层的中间件最后执行。</li>\n<li>执行结束后，把执行权交回上一层的中间件。</li>\n<li>...</li>\n<li>最外层的中间件收回执行权之后，执行<code>next</code>函数后面的代码。</li>\n</ol>\n</blockquote>\n\n<p>请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/09.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/09.js\nconst one = (ctx, next) =&gt; {\n  console.log(&apos;&gt;&gt; one&apos;);\n  next();\n  console.log(&apos;&lt;&lt; one&apos;);\n}\n\nconst two = (ctx, next) =&gt; {\n  console.log(&apos;&gt;&gt; two&apos;);\n  next(); \n  console.log(&apos;&lt;&lt; two&apos;);\n}\n\nconst three = (ctx, next) =&gt; {\n  console.log(&apos;&gt;&gt; three&apos;);\n  next();\n  console.log(&apos;&lt;&lt; three&apos;);\n}\n\napp.use(one);\napp.use(two);\napp.use(three);\n\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/09.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，命令行窗口会有如下输出。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n&gt;&gt; one\n&gt;&gt; two\n&gt;&gt; three\n&lt;&lt; three\n&lt;&lt; two\n&lt;&lt; one\n</code></pre></blockquote>\n\n<p>如果中间件内部没有调用<code>next</code>函数，那么执行权就不会传递下去。作为练习，你可以将<code>two</code>函数里面<code>next()</code>这一行注释掉再执行，看看会有什么结果。</p>\n\n<h3>3.4 异步中间件</h3>\n\n<p>迄今为止，所有例子的中间件都是同步的，不包含异步操作。如果有异步操作（比如读取数据库），中间件就必须写成 <a href=\"http://es6.ruanyifeng.com/#docs/async\">async 函数</a>。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/10.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/10.js\nconst fs = require(&apos;fs.promised&apos;);\nconst Koa = require(&apos;koa&apos;);\nconst app = new Koa();\n\nconst main = async function (ctx, next) {\n  ctx.response.type = &apos;html&apos;;\n  ctx.response.body = await fs.readFile(&apos;./demos/template.html&apos;, &apos;utf8&apos;);\n};\n\napp.use(main);\napp.listen(3000);\n</code></pre></blockquote>\n\n<p>上面代码中，<code>fs.readFile</code>是一个异步操作，必须写成<code>await fs.readFile()</code>，然后中间件必须写成 async 函数。</p>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/10.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，就可以看到模板文件的内容。</p>\n\n<h3>3.5 中间件的合成</h3>\n\n<p><a href=\"https://www.npmjs.com/package/koa-compose\"><code>koa-compose</code></a>模块可以将多个中间件合成为一个。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/11.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/11.js\nconst compose = require(&apos;koa-compose&apos;);\n\nconst logger = (ctx, next) =&gt; {\n  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);\n  next();\n}\n\nconst main = ctx =&gt; {\n  ctx.response.body = &apos;Hello World&apos;;\n};\n\nconst middlewares = compose([logger, main]);\napp.use(middlewares);\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/11.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，就可以在命令行窗口看到日志信息。</p>\n\n<h2>四、错误处理</h2>\n\n<h3>4.1 500 错误</h3>\n\n<p>如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了<code>ctx.throw()</code>方法，用来抛出错误，<code>ctx.throw(500)</code>就是抛出500错误。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/14.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/14.js\nconst main = ctx =&gt; {\n  ctx.throw(500);\n};\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/14.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000，你会看到一个500错误页&quot;Internal Server Error&quot;。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080807.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D648d9851b60734cf1f20cff77d40976cc9f2ec21\" alt=\"\" title=\"\"></p>\n\n<h3>4.2 404错误</h3>\n\n<p>如果将<code>ctx.response.status</code>设置成404，就相当于<code>ctx.throw(404)</code>，返回404错误。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/15.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/15.js\nconst main = ctx =&gt; {\n  ctx.response.status = 404;\n  ctx.response.body = &apos;Page Not Found&apos;;\n};\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/15.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，你就看到一个404页面&quot;Page Not Found&quot;。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080808.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D21a48768c66e178252d49dbb5e40a6c7bd17138a\" alt=\"\" title=\"\"></p>\n\n<h3>4.3 处理错误的中间件</h3>\n\n<p>为了方便处理错误，最好使用<code>try...catch</code>将其捕获。但是，为每个中间件都写<code>try...catch</code>太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/16.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/16.js\nconst handler = async (ctx, next) =&gt; {\n  try {\n    await next();\n  } catch (err) {\n    ctx.response.status = err.statusCode || err.status || 500;\n    ctx.response.body = {\n      message: err.message\n    };\n  }\n};\n\nconst main = ctx =&gt; {\n  ctx.throw(500);\n};\n\napp.use(handler);\napp.use(main);\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/16.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，你会看到一个500页，里面有报错提示 <code>{&quot;message&quot;:&quot;Internal Server Error&quot;}</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080809.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D00348acff48803e2a3b0b79936628f119180f0b6\" alt=\"\" title=\"\"></p>\n\n<h3>4.4 error 事件的监听</h3>\n\n<p>运行过程中一旦出错，Koa 会触发一个<code>error</code>事件。监听这个事件，也可以处理错误。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/17.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/17.js\nconst main = ctx =&gt; {\n  ctx.throw(500);\n};\n\napp.on(&apos;error&apos;, (err, ctx) =&gt;\n  console.error(&apos;server error&apos;, err);\n);\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/17.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，你会在命令行窗口看到&quot;server error xxx&quot;。</p>\n\n<h3>4.5 释放 error 事件</h3>\n\n<p>需要注意的是，如果错误被<code>try...catch</code>捕获，就不会触发<code>error</code>事件。这时，必须调用<code>ctx.app.emit()</code>，手动释放<code>error</code>事件，才能让监听函数生效。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/18.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/18.js`\nconst handler = async (ctx, next) =&gt; {\n  try {\n    await next();\n  } catch (err) {\n    ctx.response.status = err.statusCode || err.status || 500;\n    ctx.response.type = &apos;html&apos;;\n    ctx.response.body = &apos;&lt;p&gt;Something wrong, please contact administrator.&lt;/p&gt;&apos;;\n    ctx.app.emit(&apos;error&apos;, err, ctx);\n  }\n};\n\nconst main = ctx =&gt; {\n  ctx.throw(500);\n};\n\napp.on(&apos;error&apos;, function(err) {\n  console.log(&apos;logging error &apos;, err.message);\n  console.log(err);\n});\n</code></pre></blockquote>\n\n<p>上面代码中，<code>main</code>函数抛出错误，被<code>handler</code>函数捕获。<code>catch</code>代码块里面使用<code>ctx.app.emit()</code>手动释放<code>error</code>事件，才能让监听函数监听到。</p>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/18.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，你会在命令行窗口看到<code>logging error</code>。</p>\n\n<h2>五、Web App 的功能</h2>\n\n<h3>5.1  Cookies</h3>\n\n<p><code>ctx.cookies</code>用来读写 Cookie。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/19.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/19.js\nconst main = function(ctx) {\n  const n = Number(ctx.cookies.get(&apos;view&apos;) || 0) + 1;\n  ctx.cookies.set(&apos;view&apos;, n);\n  ctx.response.body = n + &apos; views&apos;;\n}\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/19.js\n</code></pre></blockquote>\n\n<p>访问 http://127.0.0.1:3000 ，你会看到<code>1 views</code>。刷新一次页面，就变成了<code>2 views</code>。再刷新，每次都会计数增加1。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080810.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D278c736f5e2a99d71a90a213137620045cf3f8ed\" alt=\"\" title=\"\"></p>\n\n<h3>5.2 表单</h3>\n\n<p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。<a href=\"https://www.npmjs.com/package/koa-body\"><code>koa-body</code></a>模块可以用来从 POST 请求的数据体里面提取键值对。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/20.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/20.js\nconst koaBody = require(&apos;koa-body&apos;);\n\nconst main = async function(ctx) {\n  const body = ctx.request.body;\n  if (!body.name) ctx.throw(400, &apos;.name required&apos;);\n  ctx.body = { name: body.name };\n};\n\napp.use(koaBody());\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/20.js\n</code></pre></blockquote>\n\n<p>打开另一个命令行窗口，运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl -X POST --data &quot;name=Jack&quot; 127.0.0.1:3000\n{&quot;name&quot;:&quot;Jack&quot;}\n\n$ curl -X POST --data &quot;name&quot; 127.0.0.1:3000\nname required\n</code></pre></blockquote>\n\n<p>上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>\n\n<h3>2.3 文件上传</h3>\n\n<p><a href=\"https://www.npmjs.com/package/koa-body\"><code>koa-body</code></a>模块还可以用来处理文件上传。请看下面的例子（完整代码看<a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/21.js\">这里</a>）。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// demos/21.js\nconst os = require(&apos;os&apos;);\nconst path = require(&apos;path&apos;);\nconst koaBody = require(&apos;koa-body&apos;);\n\nconst main = async function(ctx) {\n  const tmpdir = os.tmpdir();\n  const filePaths = [];\n  const files = ctx.request.body.files || {};\n\n  for (let key in files) {\n    const file = files[key];\n    const filePath = path.join(tmpdir, file.name);\n    const reader = fs.createReadStream(file.path);\n    const writer = fs.createWriteStream(filePath);\n    reader.pipe(writer);\n    filePaths.push(filePath);\n  }\n\n  ctx.body = filePaths;\n};\n\napp.use(koaBody({ multipart: true }));\n</code></pre></blockquote>\n\n<p>运行这个 demo。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node demos/21.js\n</code></pre></blockquote>\n\n<p>打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，<code>/path/to/file</code>要更换为真实的文件路径。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ curl --form upload=@/path/to/file http://127.0.0.1:3000\n[&quot;/tmp/file&quot;]\n</code></pre></blockquote>\n\n<h2>六、参考链接</h2>\n\n<ul>\n<li><a href=\"https://github.com/koajs/workshop\">koa workshop</a></li>\n<li><a href=\"https://github.com/koajs/kick-off-koa\">kick-off-koa</a></li>\n<li><a href=\"https://github.com/koajs/examples\">Koa Examples</a></li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017080801.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612658%3B1553148658%26q-key-time%3D1521612658%3B1553148658%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1add65706a376562e9a250da2aeae5681b160f54","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/08/koa.html","sourceType":"blog","time":"2017-08-09 07:29:00"},{"id":30,"name":"正态分布为什么常见？","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>统计学里面，正态分布（normal distribution）最常见。男女身高、寿命、血压、考试成绩、测量误差等等，都属于正态分布。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017073006.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612659%3B1553148659%26q-key-time%3D1521612659%3B1553148659%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6cbf8aad2b8e12ae7ce787d851477005bc225935\" alt=\"\" title=\"\"></p>\n\n<p>以前，我认为中间状态是事物的常态，过高和过低都属于少数，这导致了正态分布的普遍性。最近，读到了 <a href=\"https://www.johndcook.com/blog/2015/03/09/why-isnt-everything-normally-distributed/\">John D. Cook</a> 的文章，才知道我的这种想法是错的。</p>\n\n<p>正态分布为什么常见？真正原因是<a href=\"https://baike.baidu.com/item/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86\">中心极限定理</a>（central limit theorem）。</p>\n\n<blockquote>\n  <p>&quot;多个独立统计量的和的平均值，符合正态分布。&quot;</p>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017073002.gif?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612659%3B1553148659%26q-key-time%3D1521612659%3B1553148659%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De5944ff156aac284f01772c31940feb869c043d0\" alt=\"\" title=\"\"></p>\n\n<p>上图中，随着统计量个数的增加，它们和的平均值越来越符合正态分布。</p>\n\n<p><strong>根据中心极限定理，如果一个事物受到多种因素的影响，不管每个因素本身是什么分布，它们加总后，结果的平均值就是正态分布。</strong></p>\n\n<p>举例来说，人的身高既有先天因素（基因），也有后天因素（营养）。每一种因素对身高的影响都是一个统计量，不管这些统计量本身是什么分布，它们和的平均值符合正态分布。（注意：男性身高和女性身高都是正态分布，但男女混合人群的身高<a href=\"https://www.johndcook.com/blog/2008/11/25/distribution-of-adult-heights/\">不是</a>正态分布。）</p>\n\n<p>许多事物都受到多种因素的影响，这导致了正态分布的常见。</p>\n\n<p>读到这里，读者可能马上就会提出一个问题：<strong>正态分布是对称的（高个子与矮个子的比例相同），但是很多真实世界的分布是不对称的。</strong></p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017073003.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612659%3B1553148659%26q-key-time%3D1521612659%3B1553148659%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D054f27e49f861b316ab70825d50046840549c6b4\" alt=\"\" title=\"\"></p>\n\n<p>比如，财富的分布就是不对称的，富人的有钱程度（可能比平均值高出上万倍），远远超出穷人的贫穷程度（平均值的十分之一就是赤贫了），即财富分布曲线有右侧的长尾。相比来说，身高的差异就小得多，最高和最矮的人与平均身高的差距，都在30%多。</p>\n\n<p>这是为什么呢，财富明明也受到多种因素的影响，怎么就不是正态分布呢？</p>\n\n<p>原来，正态分布只适合各种因素累加的情况，如果这些因素不是彼此独立的，会互相加强影响，那么就不是正态分布了。一个人是否能够挣大钱，由多种因素决定：</p>\n\n<blockquote>\n  <ul>\n<li>家庭</li>\n<li>教育</li>\n<li>运气</li>\n<li>工作</li>\n<li>...</li>\n</ul>\n</blockquote>\n\n<p>这些因素都不是独立的，会彼此加强。如果出生在上层家庭，那么你就有更大的机会接受良好的教育、找到高薪的工作、遇见好机会，反之亦然。也就是说，这不是 1 + 1 = 2 的效果，而是 1 + 1 &gt; 2。</p>\n\n<p>统计学家发现，如果各种因素对结果的影响不是相加，而是相乘，那么最终结果不是正态分布，而是<a href=\"https://baike.baidu.com/item/%E5%AF%B9%E6%95%B0%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83\">对数正态分布</a>（log normal distribution），即<code>x</code>的对数值<code>log(x)</code>满足正态分布。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017073004.gif?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612659%3B1553148659%26q-key-time%3D1521612659%3B1553148659%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db55cc27428e3a1abc0d5c18849599bbc32003ba8\" alt=\"\" title=\"\"></p>\n\n<p>这就是说，财富的对数值满足正态分布。如果平均财富是10,000元，那么1000元～10,000元之间的穷人（比平均值低一个数量级，宽度为9000）与10,000元~100,000元之间的富人（比平均值高一个数量级，宽度为90,000）人数一样多。因此，财富曲线左侧的范围比较窄，右侧出现长尾。</p>\n\n<p><strong>参考链接</strong></p>\n\n<ul>\n<li><a href=\"https://www.johndcook.com/blog/2015/03/09/why-isnt-everything-normally-distributed/\">Why isn&apos;t everything normally distributed?</a>, by John D. Cook</li>\n<li><a href=\"https://www.johndcook.com/blog/2015/03/09/why-isnt-everything-normally-distributed/\">Achievement is not normal</a>, by John D. Cook</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2017073006.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612659%3B1553148659%26q-key-time%3D1521612659%3B1553148659%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6cbf8aad2b8e12ae7ce787d851477005bc225935","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2017/08/normal-distribution.html","sourceType":"blog","time":"2017-08-02 07:33:58"},{"id":522,"name":"灵异怪谈","author":"巫九","intro":"    【此文百度贴吧首发，百度神贴之一，上千万点击，现来17K发表，希望大家收藏支持】\n    阴阳先生命中注定五弊三缺，可有解救方法？\n    与吸血僵尸的生死之恋！！！\n    苦寻的阴阳奇录，最后发现竟然是一个更大的阴谋！！！\n    秦皇陵、吸血僵尸、阴间客栈、战国古墓、阴阳奇录尽在《灵异怪谈》\n    作者腾讯微博：http://t.qq.com/zou598864634/mine\n    一群：（已满），二群：216715284，三群：108581905（只能加一个）\n    【大家好，小九为了管理方便建立了VIP读者群，只有正版读者才可以进入，想要进入的请加这两个管理的QQ：3793612，，641444464发订阅截图给这两个管理，然后由他们拉你们进群】\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/529.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":523,"name":"误入官场","author":"可大可小","intro":"    隔着两栋楼可以听见别人说的梦话，坐在办公室可以听清别人的密谋，这样的人进了官场，只要将特长运用得当，想不官运亨通都难啊。\n","type":"都市小说","state":0,"fmImg":"/static/img/book/530.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":524,"name":"符宝","author":"曾经拥有的方向感","intro":"    随身携带十多年的一张神奇黄纸，竟然可以自行衍生符箓，觅文符可以透视，金刚符可强化万物，……\n    看符箓高手玩转都市古玩界，声威鹊起。\n","type":"都市小说","state":1,"fmImg":"/static/img/book/531.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":525,"name":"耍天","author":"抽筋神手","intro":"    倔强少年为知姓氏踏上寻碑之路，在那路的终点又有什么在等着他？\n    是亲情的曙光还是地狱的轮回？\n    不管是什么，我只想找回自己的姓氏。\n    秦毅望着虚无缥缈的天道\n    拥有着神的光芒的八大神族又为何蒙受千年之冤受尽屠戮？他们到底是神是魔？\n    到底谁对谁错？\n    所有的迷都将矛头引向了石碑，引向了秦毅。\n    他就是那把钥匙，打开大陆一切未解之谜的钥匙。\n    所以，他必须死！\n    所以，他必须活着！\n    他是什么样的人？\n    疾月：他啊，是个疯子也是个傻子。你们都以为他不怕死，其实...他很怕，比谁都怕！。\n    所以我才一直活到了现在啊。秦毅笑道。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/533.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":526,"name":"恶少契约：迷糊丫头不好惹","author":"暮日流年","intro":"    求爱不成的恶魔少爷受好友唆使，想出恋爱绝招，企图扭转乾坤，因此威逼利诱胁迫平民少女签订交往契约。花美男皇太子和粗线条腹黑女会因为一纸契约擦出怎样的火花？外表冷酷、内心脆弱的忧郁王子又将付出怎样的感情？花心大少的内心碰撞又是怎样进退两难？两个人的爱情，一群人的纠葛，不对等的门第，又是否会阻拦真爱相守？且看可爱少女，如何征服顽劣恶少，赢得爱情！\n    PS：原名《花美男规则之恶少契约》　人物更名：崔敏贤=崔怀瑾　李佳人=李梦云=========================================================================\n    本文纯属虚构，为杜绝政治和社会因素，文中主要地名和财阀集团皆采用虚名，仅供YY，请勿对号入座。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/532.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":527,"name":"疑途","author":"对着石头的诗人","intro":"    大千世界，无奇不有，总有一些神秘领域，超自然现象，神秘地带是我们不能触及的地方。为了探知这些神秘而又带着死亡气息的领域，无数的探险者带着智慧、勇敢、激情踏上了疑途。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/534.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":528,"name":"凤入侯门","author":"云程","intro":"    公主奉旨下嫁，大婚前夜服毒自尽，醒来后糊里糊涂上了花轿，嫁给帝都最负盛名的浪子。\n    驸马不负众望，在新婚之夜公然召伶人入府荒唐，笙歌欢舞至天明。\n    一段你不情我不愿的姻缘，历经反目到彼此吸引，最终情归何处？\n    一对貌不合神相离的夫妻，一场牵连了三位皇子三位公主的夺嫡之战，谁主沉浮？\n    一曲长歌，倾尽韶华亦未央。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/539.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":529,"name":"凤邪","author":"玫瑰花妖","intro":"    听说南宫家二小姐的疯毛病好了，\n    听说南宫家二小姐那个丑八怪要嫁给有钱有势的男人，\n    听说南宫家二小姐的男人帅气得让女人们抓狂。\n    然，这不是听说，是事实，摆在眼前的事实。\n    只是，不曾有人想过，谁狠毒得让这具躯体背负如此丑陋的容颜十几年？\n    谁！\n    既然要了这副躯体，她就要查出罪魁祸首，让那人尝尝生不如死的痛；\n    既然要了这副躯体，她就不能再让这具躯体窝囊地活下去，所有对躯体亏欠的人，她会加倍要回来，就算天王老子也不例外！\n    ……\n    你就没爱过我？南宫小小的口气平淡如水，看着雪冰峰那冰冷的眼神，心有那么一丝痛。\n    娶你不过是为母后还一段恩，像你这样的丑八怪，你觉得配得上我爱吗？雪冰峰不懈地横了小小一眼。\n    你会后悔的！南宫小小不以为然地笑笑，转身消失在黑夜之中。\n    ……\n    本文为女强，女主偶尔有些二，有些腹黑，但是很强大，喜欢可以戳一戳，戳完记得留下脚印。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/538.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":530,"name":"异世为僧","author":"萧舒","intro":"    萧舒继《金庸世界里的道士》后之新作。\n    转世降临，出家为僧，真能离情绝欲，慧剑斩情丝？\n    修炼武功，有天下第一之志，可世间天才如夜空繁星，他真可达成？\n    金刚不坏，身陷红尘，落入花丛，真能不垢不坏？\n    一切皆在《异世为僧》，讲述一个和尚的精彩人生。\n","type":"玄幻小说","state":1,"fmImg":"/static/img/book/537.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":531,"name":"小小医师升官路","author":"蓝山语茶","intro":"    他出自军人世家，他是国家六百万注册医师之一，他懂得责任与义务。\n    是医也是医，是官还是官。\n    医者父母心，为官一身清。\n    乃知国家事，成败固人心。\n    本书纯属虚构，请不要对号入座！\n    群号：248595222欢迎加入。本书以完成！感谢大家的支持，语茶鞠身拜谢！\n","type":"玄幻小说","state":1,"fmImg":"/static/img/book/535.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":532,"name":"北冥神剑","author":"池衡水榭","intro":"    极北之地到处冰天雪地，寒冷异常，为何这里一处小小的寒叶谷，竟然四季如春？\n    这里，究竟隐藏着怎样的秘密？\n    年轻的少主池中天会遇到怎样的江湖奇遇？\n    风平浪静的武林，又为何再起波澜？\n    所有的一切，都来得太突然了，突然的让人目不暇接，让人无所适从。\n    书友群：36742190；欢迎各位读者们加入，你们的每一分支持，都是我最大的幸福！\n","type":"修真小说","state":1,"fmImg":"/static/img/book/536.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":533,"name":"升龙入道","author":"本不该此","intro":"    双刀持手，斩天下因缘，刀若换枪，破天地恩怨，天龙大陆，融龙至尊！\n    聚凝气，集融力，惊天动星，任你龙师挥武斩天，顾你融师唤兽百万，只要挡我前方路，愿屠千百万。\n    纵横万载无双，古今天地至上，掌控无尽生灵，天地不容自当与天抗衡，本不属世，何来恋乡之心？\n    龙师：凝龙--翼龙--血龙--撼龙--御龙--胤龙--渊龙--噬龙--鄍龙--天龙圣\n    融合师：初入融门--小成境--大成境--练结境--合月境--动乾境--飞跃境--破体境--煞罡境--通天镜--融圣境\n    ………………………………\n    ps:求勾搭，求包养，求鲜花，求贵宾....《大大们还在看什么？赶紧收藏了....》\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/540.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":534,"name":"冥夜传说","author":"凡尘乌鸦","intro":"    不是大神，也不想浮夸，只是一双神奇的黑玫瑰之眼，只想写出一个魔法师的故事......\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/541.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":535,"name":"极品草根太子","author":"贼眉鼠眼","intro":"    豪门后代的草根生活。\n    家族内变，太子流落民间二十载，学会一切卑鄙无耻的手段谋生，有朝一日飞鸟化凤，重回豪门，用草根的方式掌控权势。\n    翻云覆雨间，强敌灰飞烟灭。\n    嬉笑玩谑时，美人尽入胸怀。\n    （这是一个贱人的故事。）\n","type":"都市小说","state":1,"fmImg":"/static/img/book/543.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":536,"name":"十世莲华","author":"蓝紫寻","intro":"    文艺版：十世刹那芬华，犹如莲华绽放。七情之苦，八念之嗔，红尘千万，云纷飘渺。\n    她为书仙，他为道士，十世轮回苦，她和他能赌赢上天？\n    剧情版：人有三魂七魄看似少，找起来却十足的麻烦。\n    前世结下的怨孽，居然在今生得到报应。\n    为了挽救意外翻开破书，受到书仙诅咒的男朋友。兰紫歆接受书仙的刁难，前往书中的世界，寻找男朋友的三魂七魄，没想到却意外揭开了一段有关前世今生的爱情。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/546.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":537,"name":"道傲八荒","author":"莫言当年","intro":"    八荒，一个弱肉强食的世界。六界，一个波浪壮阔的舞台。\n    出身红魔棺椁的神秘少年，修行山海古经，融合真龙天元。\n    迈步走来，悟道，改天，换命。\n    在这个动荡而又黑暗的时代。\n    扛起煌煌大旗，造就不朽的传奇。\n","type":"二次元小说","state":1,"fmImg":"/static/img/book/545.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":538,"name":"诸天之塔","author":"月舞神辉","intro":"    人生一世，草生一秋。\n    无论你是帝王将相，还是才子佳人，或者流贼盗寇，抑或走夫贩卒，最终都难逃一死，都要魂归天地！\n    世间万物皆是喜生恶死，传说天上仙人执掌世间强横力量，借助各种神兵法器，抗逆生老病死之自然天律，可以长生不死。\n    世人欲求长生之道，修仙练道，自此盛行人间，然而仙路遥遥，艰险万分，世间苍生又有几人能够飞升仙界？又有多少白骨填埋在了这茫茫仙路？\n    天地神器的崩坏。六道至尊的消失，神秘的诸天之塔，远古的传说。\n    诸天之塔，天地至尊。这是天界流传着的一句传说，无数人争夺的诸天之塔，到底隐藏着什么秘密呢？\n    我的新书《穿越之远古兽魂》已经发布，希望喜欢我的书的朋友，也都去看看，希望大家也同样喜欢它.......传送门http://www.17k.com/book/668860.html\n","type":"二次元小说","state":1,"fmImg":"/static/img/book/542.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":539,"name":"无尽剑装","author":"衣冠胜雪","intro":"    一个在家族中地位不高的玄气弟子，偶然在地摊上得到一块奇异玉石，里面藏著一门上古剑修传下来的绝世剑阵修炼之法！\n    冰火两仪剑阵，三叠琴音剑阵，四合八级剑阵，六脉五行剑阵，七星八卦剑阵，九天雷火剑阵，十方无极剑阵，周天挪移剑阵，紫雾虚弥剑阵，道心种魔剑阵，万剑归宗剑阵……\n    天下地下，唯我剑阵！\n    与我作对者，一概万剑轰杀！\n    。。。。\n    求订阅，求推荐票！！！！\n","type":"玄幻小说","state":0,"fmImg":"/static/img/book/544.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":540,"name":"闷骚少爷甩不掉","author":"木阳","intro":"    你出去！章熙儿冲着躺在身旁的欧阳勋大声喊。\n    不。从那个贱人口中就轻轻飘出这么一个字。\n    我走，那我走好了吧！章熙儿真是要疯掉了。\n    你身上衣服是我买的，你要现在脱吗？那个贱人都没抬头。\n    这该怎么办，她当时可只是为了帮忙接机啊，怎么就扯上了这么个二世祖呢。这个帅哥金主还不知怎么就赖上她不走了。\n    她才25岁啊，她还是个小清新啊，她还没有男朋友呢啊！看来，她只好和他斗争到底了！\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/547.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":541,"name":"我的男友是禽兽","author":"哟哟不怕","intro":"    十一年前，他们相遇在一片阴暗的森林之中。\n    他，是在飞机上遇难的富家少爷，温柔又腹黑；\n    他，是被遗弃的孩子，从小被老虎养大，单纯又野蛮；\n    当温柔的他遇上单纯的他，开始手足无措；当单纯的他爱上温柔的他开始变得柔情蜜意。\n    你不可以欺负我哦！\n    ......\n    呐呐！和我交配。\n    一个温柔腹黑攻和单纯野蛮受的小故事。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/551.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":542,"name":"汉末皇叔","author":"诸葛清风","intro":"    “我叫季玉！”\n    “好吧！其实我叫刘璋字季玉！”\n    当季玉发现自己变成了可怜的刘璋，他会做出什么样的选择呢？让我们拭目以待吧！\n    －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n    兄弟们，清风新书开张，求推荐，求收藏1\n","type":"玄幻小说","state":1,"fmImg":"/static/img/book/549.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":543,"name":"哑受","author":"三念","intro":"    他的名字叫小莫\n    他是个哑巴，他学习很棒，他会踢球，他会打架；\n    他还会弹钢琴、拉小提琴……\n    唯一有所欠缺的是：他不会说话\n    ……\n    和家把他捡回家，让他变成了普通人\n    《哑受》这本书讲述的是三对好基友的故事；\n    腹黑受小莫与单纯攻和平；两小无猜，青梅竹马；\n    苦难和一提与强势楚万成；曲折多变，苦尽甘来；\n    强受高秦涟与黑帮混小子赵本慈；一见钟情，欢喜冤家。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/552.png","clickHits":0,"zanHits":1,"time":"2017-12-27 14:54:19"},{"id":544,"name":"召唤美女军团","author":"写字板","intro":"    重生异界的军校高材生，拥有了召唤星辰天女的能力。为了解开星辰天女族损落之谜，也为了能够回到自己的家乡，他开始带着美女军团，崛起当世，以无敌的姿态，横扫一切~~~\n","type":"玄幻小说","state":0,"fmImg":"/static/img/book/550.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":545,"name":"灭掉天尊","author":"不以木为剑","intro":"    杨林——一个平凡而普通的孩子。虽然他的前世非常强大，号称万古来的第一天才！\n    但是，那惊才艳艳的前世，还不是被天尊给坑杀了！\n    这一世，杨林只想做自己。奈何，命运总是这么爱捉弄人！\n    杨林妥协过，灰心过，失望过······\n    到了最后，还不是要拿起手中的武器，拼了性命的去抗争吗？\n    一夫拼命，美女我有；一夫拼命，天下任我走。\n    境界划分：低级，中级，高级，地仙，地君，破道，立道，成道、兵之境、将之境、王之境、天王境\n    欢迎大家送花支持，欢迎大家注册收藏······\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/553.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":546,"name":"魔法师莱恩传","author":"无限生机","intro":"    伟大的魔法师不仅仅拥有强大的力量，还能够精妙的控制自己所拥有的力量。当你有一天可以自由的操纵魔法的力量，比如在自己的脚下施放火球术杀伤敌人而自身却分毫不伤，那才算是入门了。\n    作者码字的目的当然是让读者看得爽了，但是本书不会写成“王八之气冲天而起，小弟收的数不胜数，美女后宫没完没了，反面角色全是白痴。”\n    新书《刑天战记之瀚海星河》已经上传http://www.17k.com/book/791357.html\n    作者qq：1003045476\n","type":"玄幻小说","state":1,"fmImg":"/static/img/book/548.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:19"},{"id":547,"name":"横行霸道","author":"踏雪真人","intro":"    六道翻腾神鬼怒，\n    九天震荡风雷激。\n    我持本心，不忧、不惑、不惧。\n    横行九天，雄霸六道。\n    ____________________________________\n    已完本《网游之神经过敏》、《无限杀路》、《仗剑高歌》三本书，人品保证，请大家放心阅读。\n","type":"修真小说","state":1,"fmImg":"/static/img/book/556.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:21"},{"id":548,"name":"养兽为妻","author":"莫柒染","intro":"    当了半辈子杀手，还没来得及和爱人风花雪月，就被自己手里的手榴弹炸得魂归地府。\n    再睁开眼，艾玛，我用牛奶滋润的光滑皮肤呢？我靠吃木瓜养成的妖娆身材呢？\n    老娘是人不是动物啊！\n    睡了一觉，那个美的冒泡的帅哥是肿么回事？\n    看在你对我挺好的份儿上，我就留下好了，你等着，等我变成人，一定吃定你！\n    ————\n    来了不留下脚印的都是坏孩子，我要代表月亮消灭你们。啊哈哈\n    喜欢此文的人可以加群282640784，敲门砖书中任意出现的人物名，欢迎大家一起讨论　提意见\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/555.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:21"},{"id":549,"name":"特种高手","author":"子夜天明","intro":"    意外变故，侥幸活下来的特种兵刘芒，来到都市，开始了和警花，校花，美女老总的同居生活，更是成为警花的小受，校花的陪练，美女老总的贴身秘书，伴随着艳遇而来的却是一场场惊心动魄的阴谋，当阴谋破解却发现一切都是宿命的轮回。\n    群号：214060291200285861\n","type":"都市小说","state":1,"fmImg":"/static/img/book/554.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:21"},{"id":550,"name":"都市超级戒指","author":"不死皇","intro":"    刚失恋的毕业大学生方晨意外之下得到了进化之戒，从此生活发生了天翻地覆的变化！做任务，攒挑战点，许愿技能！杀凶兽，爆幸运点，抽取随机物品！\n    无限风云起，一路桃花红！为红颜，他踏黑道，登黑榜，执掌天门！为兄弟，起腥风，溅血雨，头染一片青天！为国家，平岛国，灭北约，杀欧盟，欲立华夏神威！\n    不一样的都市，不一样的精彩！\n    推荐几本不错的书，千曲晓声《美女便利店》，王朝芒果《美人不胜收》，他乡的灯火《官网天下》,那边般若的《绝品全才》书荒的童鞋可以去逛逛！\n    支持本书的人可以加群261859096\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/557.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:21"},{"id":551,"name":"网游之亡灵杀手","author":"壹虎酒","intro":"    生活的艰辛，家人的嘲讽，朋友的背叛……\n    他的热血渐渐冷却，心也慢慢冰封。化身黑暗中的幽灵，猎杀无辜的生命。\n    朋友、兄弟、团队、忠诚、爱情……再次唤醒心灵最深处的光明。\n    且看他如何完成自我救赎，抓住生命中最闪亮的东西！\n    官方群：一壶老酒118126584。希望喜欢的兄弟多交流。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/562.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:21"}],
    '/getStoryList':{"total":51825,"list":[{"id":543,"name":"哑受","author":"三念","intro":"    他的名字叫小莫\n    他是个哑巴，他学习很棒，他会踢球，他会打架；\n    他还会弹钢琴、拉小提琴……\n    唯一有所欠缺的是：他不会说话\n    ……\n    和家把他捡回家，让他变成了普通人\n    《哑受》这本书讲述的是三对好基友的故事；\n    腹黑受小莫与单纯攻和平；两小无猜，青梅竹马；\n    苦难和一提与强势楚万成；曲折多变，苦尽甘来；\n    强受高秦涟与黑帮混小子赵本慈；一见钟情，欢喜冤家。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/552.png","clickHits":0,"zanHits":1,"time":"2017-12-27 14:54:19"},{"id":522,"name":"灵异怪谈","author":"巫九","intro":"    【此文百度贴吧首发，百度神贴之一，上千万点击，现来17K发表，希望大家收藏支持】\n    阴阳先生命中注定五弊三缺，可有解救方法？\n    与吸血僵尸的生死之恋！！！\n    苦寻的阴阳奇录，最后发现竟然是一个更大的阴谋！！！\n    秦皇陵、吸血僵尸、阴间客栈、战国古墓、阴阳奇录尽在《灵异怪谈》\n    作者腾讯微博：http://t.qq.com/zou598864634/mine\n    一群：（已满），二群：216715284，三群：108581905（只能加一个）\n    【大家好，小九为了管理方便建立了VIP读者群，只有正版读者才可以进入，想要进入的请加这两个管理的QQ：3793612，，641444464发订阅截图给这两个管理，然后由他们拉你们进群】\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/529.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":523,"name":"误入官场","author":"可大可小","intro":"    隔着两栋楼可以听见别人说的梦话，坐在办公室可以听清别人的密谋，这样的人进了官场，只要将特长运用得当，想不官运亨通都难啊。\n","type":"都市小说","state":0,"fmImg":"/static/img/book/530.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":524,"name":"符宝","author":"曾经拥有的方向感","intro":"    随身携带十多年的一张神奇黄纸，竟然可以自行衍生符箓，觅文符可以透视，金刚符可强化万物，……\n    看符箓高手玩转都市古玩界，声威鹊起。\n","type":"都市小说","state":1,"fmImg":"/static/img/book/531.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":525,"name":"耍天","author":"抽筋神手","intro":"    倔强少年为知姓氏踏上寻碑之路，在那路的终点又有什么在等着他？\n    是亲情的曙光还是地狱的轮回？\n    不管是什么，我只想找回自己的姓氏。\n    秦毅望着虚无缥缈的天道\n    拥有着神的光芒的八大神族又为何蒙受千年之冤受尽屠戮？他们到底是神是魔？\n    到底谁对谁错？\n    所有的迷都将矛头引向了石碑，引向了秦毅。\n    他就是那把钥匙，打开大陆一切未解之谜的钥匙。\n    所以，他必须死！\n    所以，他必须活着！\n    他是什么样的人？\n    疾月：他啊，是个疯子也是个傻子。你们都以为他不怕死，其实...他很怕，比谁都怕！。\n    所以我才一直活到了现在啊。秦毅笑道。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/533.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":526,"name":"恶少契约：迷糊丫头不好惹","author":"暮日流年","intro":"    求爱不成的恶魔少爷受好友唆使，想出恋爱绝招，企图扭转乾坤，因此威逼利诱胁迫平民少女签订交往契约。花美男皇太子和粗线条腹黑女会因为一纸契约擦出怎样的火花？外表冷酷、内心脆弱的忧郁王子又将付出怎样的感情？花心大少的内心碰撞又是怎样进退两难？两个人的爱情，一群人的纠葛，不对等的门第，又是否会阻拦真爱相守？且看可爱少女，如何征服顽劣恶少，赢得爱情！\n    PS：原名《花美男规则之恶少契约》　人物更名：崔敏贤=崔怀瑾　李佳人=李梦云=========================================================================\n    本文纯属虚构，为杜绝政治和社会因素，文中主要地名和财阀集团皆采用虚名，仅供YY，请勿对号入座。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/532.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:15"},{"id":527,"name":"疑途","author":"对着石头的诗人","intro":"    大千世界，无奇不有，总有一些神秘领域，超自然现象，神秘地带是我们不能触及的地方。为了探知这些神秘而又带着死亡气息的领域，无数的探险者带着智慧、勇敢、激情踏上了疑途。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/534.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":528,"name":"凤入侯门","author":"云程","intro":"    公主奉旨下嫁，大婚前夜服毒自尽，醒来后糊里糊涂上了花轿，嫁给帝都最负盛名的浪子。\n    驸马不负众望，在新婚之夜公然召伶人入府荒唐，笙歌欢舞至天明。\n    一段你不情我不愿的姻缘，历经反目到彼此吸引，最终情归何处？\n    一对貌不合神相离的夫妻，一场牵连了三位皇子三位公主的夺嫡之战，谁主沉浮？\n    一曲长歌，倾尽韶华亦未央。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/539.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":529,"name":"凤邪","author":"玫瑰花妖","intro":"    听说南宫家二小姐的疯毛病好了，\n    听说南宫家二小姐那个丑八怪要嫁给有钱有势的男人，\n    听说南宫家二小姐的男人帅气得让女人们抓狂。\n    然，这不是听说，是事实，摆在眼前的事实。\n    只是，不曾有人想过，谁狠毒得让这具躯体背负如此丑陋的容颜十几年？\n    谁！\n    既然要了这副躯体，她就要查出罪魁祸首，让那人尝尝生不如死的痛；\n    既然要了这副躯体，她就不能再让这具躯体窝囊地活下去，所有对躯体亏欠的人，她会加倍要回来，就算天王老子也不例外！\n    ……\n    你就没爱过我？南宫小小的口气平淡如水，看着雪冰峰那冰冷的眼神，心有那么一丝痛。\n    娶你不过是为母后还一段恩，像你这样的丑八怪，你觉得配得上我爱吗？雪冰峰不懈地横了小小一眼。\n    你会后悔的！南宫小小不以为然地笑笑，转身消失在黑夜之中。\n    ……\n    本文为女强，女主偶尔有些二，有些腹黑，但是很强大，喜欢可以戳一戳，戳完记得留下脚印。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/538.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"},{"id":530,"name":"异世为僧","author":"萧舒","intro":"    萧舒继《金庸世界里的道士》后之新作。\n    转世降临，出家为僧，真能离情绝欲，慧剑斩情丝？\n    修炼武功，有天下第一之志，可世间天才如夜空繁星，他真可达成？\n    金刚不坏，身陷红尘，落入花丛，真能不垢不坏？\n    一切皆在《异世为僧》，讲述一个和尚的精彩人生。\n","type":"玄幻小说","state":1,"fmImg":"/static/img/book/537.png","clickHits":0,"zanHits":0,"time":"2017-12-27 14:54:17"}]},
    '/getBlogList':{"total":553,"list":[{"id":1,"name":"Node 调试工具入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>JavaScript 程序越来越复杂，调试工具的重要性日益凸显。客户端脚本有浏览器，Node 脚本怎么调试呢？</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec2b77d560a7fa934a82bcb95433251c989d5aef\" alt=\"\" title=\"\"></p>\n\n<p>2016年，Node 决定将 Chrome 浏览器的&quot;开发者工具&quot;作为官方的调试工具，使得 Node 脚本也可以使用图形界面调试，这大大方便了开发者。</p>\n\n<p>本文介绍如何使用 Node 脚本的调试工具。</p>\n\n<h2>一、示例程序</h2>\n\n<p>为了方便讲解，下面是一个示例脚本。首先，新建一个工作目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir debug-demo\n$ cd debug-demo\n</code></pre></blockquote>\n\n<p>然后，生成<code>package.json</code>文件，并安装 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">Koa</a> 框架和 koa-route 模块。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ npm init -y\n$ npm install --save koa koa-route\n</code></pre></blockquote>\n\n<p>接着，新建一个脚本<code>app.js</code>，并写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// app.js\nconst Koa = require(&apos;koa&apos;);\nconst router = require(&apos;koa-route&apos;);\n\nconst app = new Koa();\n\nconst main = ctx =&gt; {\n  ctx.response.body = &apos;Hello World&apos;;\n};\n\nconst welcome = (ctx, name) =&gt; {\n  ctx.response.body = &apos;Hello &apos; + name;\n};\n\napp.use(router.get(&apos;/&apos;, main));\napp.use(router.get(&apos;/:name&apos;, welcome));\n\napp.listen(3000);\nconsole.log(&apos;listening on port 3000&apos;);\n</code></pre></blockquote>\n\n<p>上面代码是一个简单的 Web 应用，指定了两个路由，访问后会显示一行欢迎信息。如果想了解代码的详细含义，可以参考 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">Koa 教程</a>。</p>\n\n<h2>二、启动开发者工具</h2>\n\n<p>现在，运行上面的脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect app.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect</code>参数是启动调试模式必需的。这时，打开浏览器访问<code>http://127.0.0.1:3000</code>，就可以看到 Hello World 了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031902.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0f7a5869f754fed79c42e1096b7b743b44f496b2\" alt=\"\" title=\"\"></p>\n\n<p>接下来，就要开始调试了。一共有两种打开调试工具的方法，第一种是在 Chrome 浏览器的地址栏，键入 <code>chrome://inspect</code>或者<code>about:inspect</code>，回车后就可以看到下面的界面。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031903.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D992dcac9c22a8adbfaeb168e224236ca4bac471d\" alt=\"\" title=\"\"></p>\n\n<p>在 Target 部分，点击 inspect 链接，就能进入调试工具了。</p>\n\n<p>第二种进入调试工具的方法，是在 http://127.0.0.1:3000 的窗口打开&quot;开发者工具&quot;，顶部左上角有一个 Node 的绿色标志，点击就可以进入。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031904.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D16cb3df6b7f535a5685a46f90fc99cbf3d3fa42e\" alt=\"\" title=\"\"></p>\n\n<h2>三、调试工具窗口</h2>\n\n<p>调试工具其实就是&quot;开发者工具&quot;的定制版，省去了那些对服务器脚本没用的部分。</p>\n\n<p>它主要有四个面板。</p>\n\n<blockquote>\n  <ul>\n<li>Console：控制台</li>\n<li>Memory：内存</li>\n<li>Profiler：性能</li>\n<li>Sources：源码</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031905.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D38b8828893983c02e08f13980c7dbe0a25c03e4a\" alt=\"\" title=\"\"></p>\n\n<p>这些面板的用法，基本上跟浏览器环境差不多，这里只介绍 Sources （源码）面板。</p>\n\n<h2>四、设置断点</h2>\n\n<p>进入 Sources 面板，找到正在运行的脚本<code>app.js</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031906.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D40e8b76d4f31b0cd4e747af4476603e093a43f32\" alt=\"\" title=\"\"></p>\n\n<p>在第11行（也就是下面这一行）的行号上点一下，就设置了一个断点。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nctx.response.body = &apos;Hello &apos; + name;\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031907.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8f3da848b36efaaa3971de6db9ec575d1cee8740\" alt=\"\" title=\"\"></p>\n\n<p>这时，浏览器访问 http://127.0.0.1:3000/alice ，页面会显示正在等待服务器返回。切换到调试工具，可以看到 Node 主线程处于暂停（paused）阶段。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031908.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc0c3235e83a3b74b5bbe565aa0e3e334ea52c150\" alt=\"\" title=\"\"></p>\n\n<p>进入 Console 面板，输入 name，会返回 alice。这表明我们正处在断点处的上下文（context）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031909.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da3ad58d41a9079a3d038577c53188148dcb4be77\" alt=\"\" title=\"\"></p>\n\n<p>再切回 Sources 面板，右侧可以看到 Watch、Call Stack、Scope、Breakpoints 等折叠项。打开 Scope 折叠项，可以看到 Local 作用域和 Global 作用域里面的所有变量。</p>\n\n<p>Local 作用域里面，变量<code>name</code>的值是<code>alice</code>，双击进入编辑状态，把它改成<code>bob</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031910.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4f31b96a584a0a1d0f77bd474f24adf2b9444dfa\" alt=\"\" title=\"\"></p>\n\n<p>然后，点击顶部工具栏的继续运行按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031911.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da87d5772442cffce7fb042dd63cf309daebdcd05\" alt=\"\" title=\"\"></p>\n\n<p>页面上就可以看到 Hello bob 了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031912.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D82c8d21bfcf9e0433dcbdd8b806c38f7d9276d34\" alt=\"\" title=\"\"></p>\n\n<p>命令行下，按下 ctrl + c，终止运行<code>app.js</code>。</p>\n\n<h2>五、调试非服务脚本</h2>\n\n<p>Web 服务脚本会一直在后台运行，但是大部分脚本只是处理某个任务，运行完就会终止。这时，你可能根本没有时间打开调试工具。等你打开了，脚本早就结束运行了。这时怎么调试呢？</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect=9229 -e &quot;setTimeout(function() { console.log(&apos;yes&apos;); }, 30000)&quot;\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect=9229</code>指定调试端口为 9229，这是调试工具默认的通信端口。<code>-e</code>参数指定一个字符串，作为代码运行。</p>\n\n<p>访问<code>chrome://inspect</code>，就可以进入调试工具，调试这段代码了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031913.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfc40b600a1945a361ca5e44607b48d2ce9e6944a\" alt=\"\" title=\"\"></p>\n\n<p>代码放在<code>setTimeout</code>里面，总是不太方便。那些运行时间较短的脚本，可能根本来不及打开调试工具。这时就要使用下面的方法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect-brk=9229 app.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect-brk</code>指定在第一行就设置断点。也就是说，一开始运行，就是暂停的状态。</p>\n\n<h2>六、忘了写 --inspect 怎么办？</h2>\n\n<p>打开调试工具的前提是，启动 Node 脚本时就加上<code>--inspect</code>参数。如果忘了这个参数，还能不能调试呢？</p>\n\n<p>回答是可以的。首先，正常启动脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node app.js\n</code></pre></blockquote>\n\n<p>然后，在另一个命令行窗口，查找上面脚本的进程号。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ ps ax | grep app.js \n\n30464 pts/11   Sl+    0:00 node app.js\n30541 pts/12   S+     0:00 grep app.js\n</code></pre></blockquote>\n\n<p>上面命令中，<code>app.js</code>的进程号是<code>30464</code>。</p>\n\n<p>接着，运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node -e &apos;process._debugProcess(30464)&apos;\n</code></pre></blockquote>\n\n<p>上面命令会建立进程 30464 与调试工具的连接，然后就可以打开调试工具了。</p>\n\n<p>还有一种方法，就是向脚本进程发送 <a href=\"https://stackoverflow.com/questions/13052548/node-js-how-to-attach-to-a-running-process-and-to-debug-the-server-with-a-conso\">SIGUSR1</a> 信号，也可以建立调试连接。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ kill -SIGUSR1 30464\n</code></pre></blockquote>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4\">Debugging Node.js with Google Chrome</a>, by Jacopo Daeli</li>\n<li><a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\">Debugging Node.js with Chrome DevTools</a>, by Paul Irish</li>\n<li><a href=\"https://remysharp.com/2018/03/03/last-minute-node-debugging\">Last minute node debugging</a>, by Remy Sharp</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec2b77d560a7fa934a82bcb95433251c989d5aef","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/node-debugger.html","sourceType":"blog","time":"2018-03-20 08:11:35"},{"id":2,"name":"日本70岁退休谈起","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>1、</p>\n\n<p>2018年初，日本政府<a href=\"https://www.qdaily.com/articles/50475.html\">修改法律</a>，推迟公务员的退休年龄。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>现在，日本的公务员是60岁～63岁退休。新法律生效后，退休年龄立刻推迟到65岁，然后逐步推迟到70岁。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd6988d1648c21c3199c38b43b17cdea5e89e1045\" alt=\"\" title=\"\"></p>\n\n<p>更厉害的是，日本政府同时宣布，养老金制度也要改革。现在是65岁领取养老金，将来只有到了70岁才能领。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030802.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D033a894aa81cac356403331c5a1b8e2ccab96a55\" alt=\"\" title=\"\"></p>\n\n<p>如果我是一个刚刚毕业的日本大学生，听到这种消息，恐怕腿都要软了。日本那种毕恭毕敬、论资排辈的社会里面，上班简直像受罪一样。你必须每天小心翼翼地勤勉工作，日复一日地加班，所有前辈都下班了，你才能下班。这种生活要一直过到七十岁，怎不令人害怕？</p>\n\n<p>等到你走也走不动了，吃也吃不下了，才能领养老金，那么养老金又有多大意义呢，能够保障什么质量的生活呢？毕竟七十岁以前，都要靠自己啊。</p>\n\n<p>2、</p>\n\n<p>日本政府推迟退休，实在是迫不得已，因为日本的人口老龄化太严重了。</p>\n\n<p>日本是全世界人均寿命最高的国家之一，男81.7岁，女88.5岁。同时，日本也是全世界出生率最低的国家之一。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030804.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db5026b30c86604653251a9a03fb161231788124c\" alt=\"\" title=\"\"></p>\n\n<p>结果就是人口不断萎缩，国民的平均年龄越来越大。2015年，日本人的平均年龄已经到了46.5岁，是全世界平均年龄最大的国家，而且这个数字以后还会变大。据估计，四十年后，日本人口会减少三分之一。</p>\n\n<p>日本对输入外国劳动力和外国移民控制极严，导致劳动力越来越少。日本政府发现，一方面，交税的人口不断减少；另一方面，领取养老金的人口不断增多，而且领的时间越来越长。于是别无选择，只能让老年人多上几年班，晚几年领养老金。</p>\n\n<p>3、</p>\n\n<p>几乎所有发达国家都存在同样的问题：养老金存在缺口，无法满足越来越多的老年人口。日本只是问题最严重而已。</p>\n\n<p>有些地区还不那么发达，也出现养老金问题，比如台湾地区。台湾的生育率也是世界最低之一，养老金早就不够用了，破产在即，不得不立刻改革，减少养老金发放规模，每个人的缴款增加，但是未来领取的金额却要减少。台湾年轻人的薪水并不高，台北房价却直逼香港东京，现在养老金又要减少，年轻人的郁闷和绝望可想而知。一个台湾网友给出了三条对策。</p>\n\n<blockquote>\n  <ul>\n<li>上策：要求改变制度设计，每一代人自己养自己，让有钱的老人补贴没钱的老人，不要拿下一代的钱发给上一代人。</li>\n<li>中策：移民，彻底脱离这个制度。自己出不去，也要让下一代出去。</li>\n<li>下策：如果走不了，就不要生育，并且拼命地挣钱和存钱。同时，支持安乐死合法化，因为未来很可能，你的钱都用光了，人却还没死。</li>\n</ul>\n</blockquote>\n\n<p>4、</p>\n\n<p>请设想这样一种情景。未来很可能过了65岁，你的头发白了、眼睛花了、牙齿松了，还不得不朝九晚五地上班，为别人打工。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030803.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df39c32ae18eb0396a025d9ba0fef256d54c8bda3\" alt=\"\" title=\"\"></p>\n\n<p>就算你能健康活过七十岁领到养老金，那些钱也很可能由于通货膨胀，以及僧多粥少，而变得非常微薄。</p>\n\n<p>这种前景只要想一想，就会觉得不寒而栗。大多数人之所以工作，不是因为热爱工作，而是因为这样可以挣到钱，可以有保障，得到安稳的退休生活。但是这一切看上去很难实现了，如今你必须忍受着疲惫，工作更多年，到头来发现，你的养老并没有保障。</p>\n\n<p>难怪日本和台湾的很多年轻人，看不到前景，对未来不抱希望。日本和台湾都有很高的<a href=\"https://www.zhihu.com/question/19840174\">自杀率</a>，我想这绝不是偶然的。</p>\n\n<p>5、</p>\n\n<p>作为个人，要摆脱这种老无所依的命运，马上能想到的解决办法就是要多多挣钱。你不得不拼命工作，挣更多的钱。但是，这条路上已经挤满了人，很可能你为雇主投入了100%的心力，年复一年，到老还是在为生存挣扎。另一方面，很多人上班其实并不开心，想想看，如果要一直苦闷地熬到60多岁，人生一定没有什么幸福感。</p>\n\n<p>我有时会有另外一种想法：反正已经是这种处境了，为什么不索性换一种活法呢？如果不喜欢这个工作，你是否还要继续下去，熬到退休拿养老金？如果养老金是苦苦支撑到七十岁才能拿到，那能不能就当它不存在，趁早去干一些自己想干的事情？至少也要找一些自己喜欢、做起来开心的工作吧。</p>\n\n<p>甚至可不可以再进一步，与其等待别人决定，你应该在什么时候退休。我也可以做一回命运的主人，哪天觉得没意思了，拍拍衣服说，从现在开始我退休了，过另外一种生活。以前还有养老金可以期待，现在这种期待即使存在，也肯定小多了。</p>\n\n<p>提前退休并不意味着，从此你什么也不干了，而是让你有机会，转身尝试另一种生活，在一个自己有热情的领域创造出更大的价值。一旦你体验过，按照自己的想法生活，自由安排时间，你就完全回不去了，再也无法忍受那种大公司小隔间的呆板压抑的生活了。</p>\n\n<p>6、</p>\n\n<p>你可能会说，我的这种想法是水中月，镜中花，一厢情愿而已。没工作了就没钱，没钱怎么活？确实，提前退休就没收入了，但这注定我一定要为别人打工到退休吗？</p>\n\n<p>事实上，美国早有人研究过这个问题：一个普通的工薪族，怎么样才能在40岁退休？结论居然是，只要你不是那么穷，有一定的积蓄，普通人也可以40岁退休。</p>\n\n<p>这里有一个计算公式，如果你的所有钱都投资在证券上面，只要你一年的支出小于投资组合原始金额的4%，那么你就可以退休了。这被称为<a href=\"https://www.bloomberg.com/features/2016-early-retirement/\">&quot;百分之四&quot;规则</a>（Four Percent Rule）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030805.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8348c9d06d0930aa8d40dc192c34e826c21a2303\" alt=\"\" title=\"\"></p>\n\n<p>它的依据是1926年至1976年的美国证券投资回报率，有人发现即使这段时间熊市居多，如果你每年取出原始投资金额的4%，一直要到33年以后才会把钱取光。要是碰到大牛市，就可以撑更久。</p>\n\n<p>如果这条规则正确，那么可以推算，如果你每年的总支出为4万人民币，而你现在的证券投资有100万，那么你就可以退休了。如果每年支出40万，那么证券投资需要1000万。这些钱能够支撑30多年，中国人的平均寿命现在也就是70多岁。事实上，有一项研究专门验证这项规则，结果发现它（在美国）成立的概率是94%。</p>\n\n<p>7、</p>\n\n<p>当然，我不是说，你真的用这个规则，来安排自己的退休规划。尽管随着年龄变老，人的支出一般会越来越少，但是万一有突发事件（比如生了大病），恐怕马上就会耗尽存款。（不过，即使你没有退休，突发事件也有可能耗尽你的存款，你的生活保障并不会因为有没有正在上班，而有实质的不同。）</p>\n\n<p>我举这条规则的用意是，我想用它证明，只要管控好支出，提前退休在财务上是完全可行的。如果你很早就开始提前规划，可能性就会大大增加，如果你对自己的消费有严格的纪律，就完全有可能做到。</p>\n\n<p>普通人的生存正在变得越来越难，养老金和退休这样的字眼，正在离你越来越远，全世界皆是如此。你必须为自己早做打算，而在我看来，如果规划得当，你的人生至少可以不是那么悲惨，要熬到七十岁油干灯尽才能退休。</p>\n\n<p>（说明：本文收录在即将出版的<a href=\"http://www.ruanyifeng.com/survivor/\">《未来世界的幸存者》</a>一书之中。）</p>\n\n<p>（正文完）</p>\n\n<p>=========================================</p>\n\n<p>你最近有没有换工作的打算？下面向大家介绍一个国内著名的 IT 行业招聘网站：<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a>。</p>\n\n<p>优秀的人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力，从海量机会中找到最适合的那个。<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 让您可以向数百家互联网企业，匿名展示简历和职业期望，省下查找职位和投递简历的时间。通过这种方式，对您感兴趣的企业，主动邀请您参加面试。</p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030806.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D01fcbcfdcf5889695623b23f2cd43b6c8cbd35da\" alt=\"\" title=\"\"></a></p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 的用户之中，既有厌倦了大公司螺丝钉般的重复工作，转而进入创业公司的前 BAT 员工；也有在小公司工作多年，一心想进入大公司的互联网人；还有向往国外的工作与生活，成功肉身翻墙新加坡的工程师。</p>\n\n<p>准备好用不一样的方式迎接更好的职业机会了吗？现在就<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">提交申请</a>吧！</p>\n\n<p>关注 100offer 的公众号，了解更多资讯。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030808.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1600ed69252681ee5b8828e6e69c3359562899f1\" alt=\"\" title=\"\"></p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd6988d1648c21c3199c38b43b17cdea5e89e1045","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/retire-at-70.html","sourceType":"blog","time":"2018-03-08 08:15:38"},{"id":3,"name":"HTTP/2 服务器推送（Server Push）教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p><a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\">HTTP/2 协议</a>的主要目的是提高网页性能。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>头信息（header）原来是直接传输文本，现在是压缩后传输。原来是同一个 TCP 连接里面，上一个回应（response）发送完了，服务器才能发送下一个，现在可以多个回应一起发送。</p>\n\n<p>服务器推送（server push）是 HTTP/2 协议里面，唯一一个需要开发者自己配置的功能。其他功能都是服务器和浏览器自动实现，不需要开发者关心。</p>\n\n<p>本文详细介绍服务器推送的原理和配置方法。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030501.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df660e66421f2fd66eb54d82af29698b04b4b8835\" alt=\"\" title=\"\"></p>\n\n<h2>一、传统的网页请求方式</h2>\n\n<p>下面是一个非常简单的 HTML 网页文件<code>index.html</code>。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;hello world&lt;/h1&gt;\n  &lt;img src=&quot;example.png&quot;&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></blockquote>\n\n<p>这个网页包含一张样式表<code>style.css</code>和一个图片文件<code>example.png</code>。为了渲染这个网页，浏览器会发出三个请求。第一个请求是<code>index.html</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nGET /index.html HTTP/1.1\n</code></pre></blockquote>\n\n<p>服务器收到这个请求，就把<code>index.html</code>发送给浏览器。浏览器发现里面包含了样式表和图片，于是再发出两个请求。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nGET /style.css HTTP/1.1\n</code></pre></blockquote>\n\n<blockquote><pre><code class=\"language-bash\">\nGET /example.png HTTP/1.1\n</code></pre></blockquote>\n\n<p>这就是传统的网页请求方式。它有两个问题，一是至少需要两轮 HTTP 通信，二是收到样式文件之前，网页都会显示一片空白，这个阶段一旦超过2秒，用户体验就会非常不好。</p>\n\n<h2>二、传统方式的改进</h2>\n\n<p>一种解决办法就是把外部资源合并在网页文件里面，减少 HTTP 请求。比如，把样式表的内容写在<code>&lt;style&gt;</code>标签之中，把图片改成 Base64 编码的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\">Data URL</a>。</p>\n\n<p>另一种方法就是资源的<a href=\"https://w3c.github.io/preload/\">预加载</a>（preload）。网页预先告诉浏览器，立即下载某些资源。比如，上例可以写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;link rel=&quot;preload&quot; href=&quot;/styles.css&quot; as=&quot;style&quot;&gt;\n&lt;link rel=&quot;preload&quot; href=&quot;/example.png&quot; as=&quot;image&quot;&gt;\n</code></pre></blockquote>\n\n<p>对于上例来说，<code>preload</code>命令并没有什么帮助。但是，如果前一个网页就使用这个命令，预加载后一个网页需要的资源，那么用户打开后一个网页时，就会感觉速度飞快。</p>\n\n<p>这两种方法都有缺点。第一种方法虽然减少了 HTTP 请求，但是把不同类型的代码合并在一个文件里，违反了分工原则。第二种方法只是提前了下载时间，并没有减少 HTTP 请求。</p>\n\n<h2>三、服务器推送的概念</h2>\n\n<p>服务器推送（server push）指的是，还没有收到浏览器的请求，服务器就把各种资源推送给浏览器。 </p>\n\n<p>比如，浏览器只请求了<code>index.html</code>，但是服务器把<code>index.html</code>、<code>style.css</code>、<code>example.png</code>全部发送给浏览器。这样的话，只需要一轮 HTTP 通信，浏览器就得到了全部资源，提高了性能。</p>\n\n<h2>四、Nginx 实现</h2>\n\n<p><a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/\">Nginx</a> 从 1.13.9 版开始，支持服务器推送。<a href=\"http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html\">前一篇教程</a>已经做好了 Nginx 容器，接着就来体验一下。</p>\n\n<p>首先，进入工作目录，把原来的首页删除。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ cd nginx-docker-demo\n$ rm html/index.html\n</code></pre></blockquote>\n\n<p>然后，新建<code>html/index.html</code>文件，写入本文第一节的网页源码。</p>\n\n<p>另外，<code>html</code>子目录下面，还要新建两个文件<code>example.png</code>和<code>style.css</code>。前者可以随便找一张 PNG 图片，后者要在里面写一些样式。</p>\n\n<blockquote><pre><code class=\"language-css\">\nh1 {\n  color: red;\n}\n</code></pre></blockquote>\n\n<p>最后，打开配置文件<code>conf/conf.d/default.conf</code>，将 443 端口的部分改成下面的样子。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2;\n    server_name  localhost;\n\n    ssl                      on;\n    ssl_certificate          /etc/nginx/certs/example.crt;\n    ssl_certificate_key      /etc/nginx/certs/example.key;\n\n    ssl_session_timeout  5m;\n\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers   on;\n\n    location / {\n      root   /usr/share/nginx/html;\n      index  index.html index.htm;\n      http2_push /style.css;\n      http2_push /example.png;\n    }\n}\n</code></pre></blockquote>\n\n<p>其实就是最后多了两行<code>http2_push</code>命令。它的意思是，如果用户请求根路径<code>/</code>，就推送<code>style.css</code>和<code>example.png</code>。</p>\n\n<p>现在可以启动容器了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  --volume &quot;$PWD/conf&quot;:/etc/nginx \n  -p 127.0.0.2:8080:80 \n  -p 127.0.0.2:8081:443 \n  -d \n  nginx\n</code></pre></blockquote>\n\n<p>打开浏览器，访问 https://127.0.0.2:8081 。浏览器会提示证书不安全，不去管它，继续访问，就能看到网页了。</p>\n\n<p>网页上看不出来服务器推送，必须打开&quot;开发者工具&quot;，切换到 Network 面板，就可以看到其实只发出了一次请求，<code>style.css</code>和<code>example.png</code>都是推送过来的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030502.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D58f89c9490c4ea83dbb71d59bcb30229be9adf4e\" alt=\"\" title=\"\"></p>\n\n<p>查看完毕，关闭容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>五、Apache 实现实现</h2>\n\n<p>Apache 也类似，可以在配置文件<code>httpd.conf</code>或者<code>.htaccess</code>里面打开服务器推送。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;FilesMatch &quot;index.html$&quot;&gt;\n    Header add Link &quot;&lt;/styles.css&gt;; rel=preload; as=style&quot;\n    Header add Link &quot;&lt;/example.png&gt;; rel=preload; as=image&quot;\n&lt;/FilesMatch&gt;\n</code></pre></blockquote>\n\n<h2>六、后端实现</h2>\n\n<p>上面的服务器推送，需要写在服务器的配置文件里面。这显然很不方便，每次修改都要重启服务，而且应用与服务器的配置不应该混在一起。</p>\n\n<p>服务器推送还有另一个实现方法，就是后端应用产生 HTTP 回应的头信息<code>Link</code>命令。服务器发现有这个头信息，就会进行服务器推送。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nLink: &lt;/styles.css&gt;; rel=preload; as=style\n</code></pre></blockquote>\n\n<p>如果要推送多个资源，就写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nLink: &lt;/styles.css&gt;; rel=preload; as=style, &lt;/example.png&gt;; rel=preload; as=image\n</code></pre></blockquote>\n\n<p>可以参考 <a href=\"https://ops.tips/blog/nginx-http2-server-push/\">Go</a>、<a href=\"https://blog.risingstack.com/node-js-http-2-push/\">Node</a>、<a href=\"https://blog.cloudflare.com/using-http-2-server-push-with-php/\">PHP</a> 的实现范例。</p>\n\n<p>这时，Nginx 的<a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/\">配置</a>改成下面这样。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2;\n\n    # ...\n\n    root /var/www/html;\n\n    location = / {\n        proxy_pass http://upstream;\n        http2_push_preload on;\n    }\n}\n</code></pre></blockquote>\n\n<p>如果服务器或者浏览器不支持 HTTP/2，那么浏览器就会按照 preload 来处理这个头信息，预加载指定的资源文件。</p>\n\n<p>事实上，这个头信息就是 preload 标准提出的，它的语法和<code>as</code>属性的值都写在了<a href=\"https://w3c.github.io/preload/#as-attribute\">标准</a>里面。</p>\n\n<h2>七、缓存问题</h2>\n\n<p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p>\n\n<p>一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2 default_server;\n\n    ssl_certificate ssl/certificate.pem;\n    ssl_certificate_key ssl/key.pem;\n\n    root /var/www/html;\n    http2_push_preload on;\n\n    location = /demo.html {\n        add_header Set-Cookie &quot;session=1&quot;;\n        add_header Link $resources;\n    }\n}\n\n\nmap $http_cookie $resources {\n    &quot;~*session=1&quot; &quot;&quot;;\n    default &quot;&lt;/style.css&gt;; as=style; rel=preload&quot;;\n}\n</code></pre></blockquote>\n\n<h2>八、性能提升</h2>\n\n<p>服务器推送可以提高性能。网上<a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/#measuring-server-push-performance\">测评</a>的结果是，打开这项功能，比不打开时的 HTTP/2 快了8%，比将资源都嵌入网页的 HTTP/1 快了5%。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030503.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D5f79946b57d439a26b76efa93af9a5c6e382ee5c\" alt=\"\" title=\"\"></p>\n\n<p>可以看到，提升程度也不是特别多，大概是几百毫秒。而且，也不建议一次推送太多资源，这样反而会拖累性能，因为浏览器不得不处理所有推送过来的资源。只推送 CSS 样式表可能是一个比较好的选择。</p>\n\n<h2>九、参考链接</h2>\n\n<ul>\n<li><a href=\"https://www.smashingmagazine.com/2017/04/guide-http2-server-push/\">A Comprehensive Guide To HTTP/2 Server Push</a>，by Jeremy Wagner</li>\n<li><a href=\"https://www.nginx.com/blog/nginx-1-13-9-http2-server-push/\">Introducing HTTP/2 Server Push with NGINX 1.13.9</a>, by Nginx</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030501.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df660e66421f2fd66eb54d82af29698b04b4b8835","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/http2_server_push.html","sourceType":"blog","time":"2018-03-05 07:58:27"},{"id":4,"name":"Nginx 容器教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>春节前，我看到 Nginx <a href=\"https://hg.nginx.org/nginx/rev/641306096f5b\">加入</a>了 HTTP/2 的 server push 功能，就很想试一下。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>正好这些天，我在学习 <a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">Docker</a>，就想到可以用 <a href=\"https://hub.docker.com/_/nginx/\">Nginx 容器</a>。万一哪里改乱了，直接删掉，再重启一个容器就可以了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022701.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df18f40e9cd9bbda0cbce061029feae6e9055406c\" alt=\"\" title=\"\"></p>\n\n<p>下面就是我搭建 Nginx 容器的过程，以及如何加入 SSL 证书。你会看到 Docker 用来测试软件的新功能，真的很方便，很值得学习。如果你还不会 Docker，可以先看<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">《Docker 入门教程》</a>，非常简单，半小时以内就能学会。</p>\n\n<h2>一、HTTP 服务</h2>\n\n<p>Nginx 的最大作用，就是搭建一个 Web Server。有了容器，只要一行命令，服务器就架设好了，完全不用配置。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  -p 127.0.0.2:8080:80 \n  --rm \n  --name mynginx \n  nginx\n</code></pre></blockquote>\n\n<p>上面命令下载并运行官方的 <a href=\"https://hub.docker.com/_/nginx/\">Nginx image</a>，默认是最新版本（latest），当前是 1.13.9。如果本机安装过以前的版本，请删掉重新安装，因为只有 1.13.9 才开始支持 server push。</p>\n\n<p>上面命令的各个参数含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>-d</code>：在后台运行</li>\n<li><code>-p</code> ：容器的<code>80</code>端口映射到<code>127.0.0.2:8080</code></li>\n<li><code>--rm</code>：容器停止运行后，自动删除容器文件</li>\n<li><code>--name</code>：容器的名字为<code>mynginx</code></li>\n</ul>\n</blockquote>\n\n<p>如果没有报错，就可以打开浏览器访问 127.0.0.2:8080 了。正常情况下，显示 Nginx 的欢迎页。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022703.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df79c809075159bfdbc22c3f555ef35d0f505a084\" alt=\"\" title=\"\"></p>\n\n<p>然后，把这个容器终止，由于<code>--rm</code>参数的作用，容器文件会自动删除。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>二、映射网页目录</h2>\n\n<p>网页文件都在容器里，没法直接修改，显然很不方便。下一步就是让网页文件所在的目录<code>/usr/share/nginx/html</code>映射到本地。</p>\n\n<p>首先，新建一个目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir nginx-docker-demo\n$ cd nginx-docker-demo\n</code></pre></blockquote>\n\n<p>然后，新建一个<code>html</code>子目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir html\n</code></pre></blockquote>\n\n<p>在这个子目录里面，放置一个<code>index.html</code>文件，内容如下。</p>\n\n<blockquote><pre><code class=\"language-markup\">\n&lt;h1&gt;Hello World&lt;/h1&gt;\n</code></pre></blockquote>\n\n<p>接着，就可以把这个子目录<code>html</code>，映射到容器的网页文件目录<code>/usr/share/nginx/html</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  -p 127.0.0.2:8080:80 \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  nginx\n</code></pre></blockquote>\n\n<p>打开浏览器，访问 127.0.0.2:8080，应该就能看到 Hello World 了。</p>\n\n<h2>三、拷贝配置</h2>\n\n<p>修改网页文件还不够，还要修改 Nginx 的配置文件，否则后面没法加 SSL 支持。</p>\n\n<p>首先，把容器里面的 Nginx 配置文件拷贝到本地。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container cp mynginx:/etc/nginx .\n</code></pre></blockquote>\n\n<p>上面命令的含义是，把<code>mynginx</code>容器的<code>/etc/nginx</code>拷贝到当前目录。不要漏掉最后那个点。</p>\n\n<p>执行完成后，当前目录应该多出一个<code>nginx</code>子目录。然后，把这个子目录改名为<code>conf</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mv nginx conf\n</code></pre></blockquote>\n\n<p>现在可以把容器终止了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>四、映射配置目录</h2>\n\n<p>重新启动一个新的容器，这次不仅映射网页目录，还要映射配置目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  --volume &quot;$PWD/conf&quot;:/etc/nginx \n  -p 127.0.0.2:8080:80 \n  -d \n  nginx\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--volume &quot;$PWD/conf&quot;:/etc/nginx</code>表示把容器的配置目录<code>/etc/nginx</code>，映射到本地的<code>conf</code>子目录。</p>\n\n<p>浏览器访问 127.0.0.2:8080，如果能够看到网页，就说明本地的配置生效了。这时，可以把这个容器终止。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop mynginx\n</code></pre></blockquote>\n\n<h2>五、自签名证书</h2>\n\n<p>现在要为容器加入 HTTPS 支持，第一件事就是生成私钥和证书。正式的证书需要证书当局（CA）的签名，这里是为了测试，搞一张自签名（self-signed）证书就可以了。</p>\n\n<p>下面，我参考的是 <a href=\"https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04\">DigitalOcean</a> 的教程。首先，确定你的机器安装了 <a href=\"https://www.openssl.org/source/\">OpenSSL</a>，然后执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo openssl req \n  -x509 \n  -nodes \n  -days 365 \n  -newkey rsa:2048 \n  -keyout example.key \n  -out example.crt\n</code></pre></blockquote>\n\n<p>上面命令的各个参数含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>req</code>：处理证书签署请求。</li>\n<li><code>-x509</code>：生成自签名证书。</li>\n<li><code>-nodes</code>：跳过为证书设置密码的阶段，这样 Nginx 才可以直接打开证书。</li>\n<li><code>-days 365</code>：证书有效期为一年。</li>\n<li><code>-newkey rsa:2048</code>：生成一个新的私钥，采用的算法是2048位的 RSA。</li>\n<li><code>-keyout</code>：新生成的私钥文件为当前目录下的<code>example.key</code>。</li>\n<li><code>-out</code>：新生成的证书文件为当前目录下的<code>example.crt</code>。</li>\n</ul>\n</blockquote>\n\n<p>执行后，命令行会跳出一堆问题要你回答，比如你在哪个国家、你的 Email 等等。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022702.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D357d0486fc97d74c7681eec9bf4ce3d514cedf77\" alt=\"\" title=\"\"></p>\n\n<p>其中最重要的一个问题是 Common Name，正常情况下应该填入一个域名，这里可以填 127.0.0.2。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nCommon Name (e.g. server FQDN or YOUR name) []:127.0.0.2\n</code></pre></blockquote>\n\n<p>回答完问题，当前目录应该会多出两个文件：<code>example.key</code>和<code>example.crt</code>。</p>\n\n<p><code>conf</code>目录下新建一个子目录<code>certs</code>，把这两个文件放入这个子目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir conf/certs\n$ mv example.crt example.key conf/certs\n</code></pre></blockquote>\n\n<h2>六、HTTPS 配置</h2>\n\n<p>有了私钥和证书，就可以打开 Nginx 的 HTTPS 了。</p>\n\n<p>首先，打开<code>conf/conf.d/default.conf</code>文件，在结尾添加下面的配置。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nserver {\n    listen 443 ssl http2;\n    server_name  localhost;\n\n    ssl                      on;\n    ssl_certificate          /etc/nginx/certs/example.crt;\n    ssl_certificate_key      /etc/nginx/certs/example.key;\n\n    ssl_session_timeout  5m;\n\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers   on;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n}\n</code></pre></blockquote>\n\n<p>然后，启动一个新的 Nginx 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name mynginx \n  --volume &quot;$PWD/html&quot;:/usr/share/nginx/html \n  --volume &quot;$PWD/conf&quot;:/etc/nginx \n  -p 127.0.0.2:8080:80 \n  -p 127.0.0.2:8081:443 \n  -d \n  nginx\n</code></pre></blockquote>\n\n<p>上面命令中，不仅映射了容器的80端口，还映射了443端口，这是 HTTPS 的专用端口。</p>\n\n<p>打开浏览器，访问 https://127.0.0.2:8081/ 。因为使用了自签名证书，浏览器会提示不安全。不要去管它，选择继续访问，应该就可以看到 Hello World 了。</p>\n\n<p>至此，Nginx 容器的 HTTPS 支持就做好了。有了这个容器，下一篇文章，我就来试验 HTTP/2 的 server push 功能。</p>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://blog.docker.com/2015/04/tips-for-deploying-nginx-official-image-with-docker/\">Tips for deploying nginx(official image) with docker</a>, by Mario Ponticello</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-run-nginx-in-a-docker-container-on-ubuntu-14-04\">How To Run Nginx in a Docker Container on Ubuntu 14.04</a>, by Thomas Taege</li>\n<li><a href=\"https://docs.docker.com/samples/library/nginx/\">Official Docker Library docs</a>,  by Docker</li>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-in-ubuntu-16-04\">How To Create a Self-Signed SSL Certificate for Nginx in Ubuntu 16.04</a>, by Justin Ellingwood</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022701.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612645%3B1553148645%26q-key-time%3D1521612645%3B1553148645%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df18f40e9cd9bbda0cbce061029feae6e9055406c","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html","sourceType":"blog","time":"2018-02-27 08:05:52"},{"id":5,"name":"Node 定时器详解","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>JavaScript 是单线程运行，异步操作特别重要。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>只要用到引擎之外的功能，就需要跟外部交互，从而形成异步操作。由于异步操作实在太多，JavaScript 不得不提供很多异步语法。这就好比，有些人老是受打击， 他的抗打击能力必须变得很强，否则他就完蛋了。</p>\n\n<p>Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 <a href=\"http://thlorenz.com/learnuv/book/history/history_1.html\">libuv</a> 做这件事。这个库负责各种回调函数的执行时间，毕竟异步任务最后还是要回到主线程，一个个排队执行。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df2ed67d3ed4d25af420cea4f1f15629e5b30dc93\" alt=\"\" title=\"\"></p>\n\n<p>为了协调异步任务，Node 居然提供了四个定时器，让任务可以在指定的时间运行。</p>\n\n<blockquote>\n  <ul>\n<li>setTimeout()</li>\n<li>setInterval()</li>\n<li>setImmediate()</li>\n<li>process.nextTick()</li>\n</ul>\n</blockquote>\n\n<p>前两个是语言的标准，后两个是 Node 独有的。它们的写法差不多，作用也差不多，不太容易区别。</p>\n\n<p>你能说出下面代码的运行结果吗？</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// test.js\nsetTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n(() =&gt; console.log(5))();\n</code></pre></blockquote>\n\n<p>运行结果如下。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node test.js\n5\n3\n4\n1\n2\n</code></pre></blockquote>\n\n<p>如果你能一口说对，可能就不需要再看下去了。本文详细解释，Node 怎么处理各种定时器，或者更广义地说，libuv 库怎么安排异步任务在主线程上执行。</p>\n\n<h2>一、同步任务和异步任务</h2>\n\n<p>首先，同步任务总是比异步任务更早执行。</p>\n\n<p>前面的那段代码，只有最后一行是同步任务，因此最早执行。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n(() =&gt; console.log(5))();\n</code></pre></blockquote>\n\n<h2>二、本轮循环和次轮循环</h2>\n\n<p>异步任务可以分成两种。</p>\n\n<blockquote>\n  <ul>\n<li>追加在<strong>本轮循环</strong>的异步任务</li>\n<li>追加在<strong>次轮循环</strong>的异步任务</li>\n</ul>\n</blockquote>\n\n<p>所谓&quot;循环&quot;，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，后文会详细解释。这里只要理解，本轮循环一定早于次轮循环执行即可。</p>\n\n<p>Node 规定，<code>process.nextTick</code>和<code>Promise</code>的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>的回调函数，追加在次轮循环。</p>\n\n<p>这就是说，文首那段代码的第三行和第四行，一定比第一行和第二行更早执行。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// 下面两行，次轮循环执行\nsetTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\n// 下面两行，本轮循环执行\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n</code></pre></blockquote>\n\n<h2>三、process.nextTick()</h2>\n\n<p><code>process.nextTick</code>这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022302.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0ede6eb316df022c0840f7885f55e8350933ec1c\" alt=\"\" title=\"\"></p>\n\n<p>Node 执行完所有同步任务，接下来就会执行<code>process.nextTick</code>的任务队列。所以，下面这行代码是第二个输出结果。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nprocess.nextTick(() =&gt; console.log(3));\n</code></pre></blockquote>\n\n<p>基本上，如果你希望异步任务尽可能快地执行，那就使用<code>process.nextTick</code>。</p>\n\n<h2>四、微任务</h2>\n\n<p>根据语言规格，<code>Promise</code>对象的回调函数，会进入异步任务里面的&quot;微任务&quot;（microtask）队列。</p>\n\n<p>微任务队列追加在<code>process.nextTick</code>队列的后面，也属于本轮循环。所以，下面的代码总是先输出<code>3</code>，再输出<code>4</code>。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n// 3\n// 4\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6c6447132171eeceb8f23f5284f42850b4000ce7\" alt=\"\" title=\"\"></p>\n\n<p>注意，只有前一个队列全部清空以后，才会执行下一个队列。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nprocess.nextTick(() =&gt; console.log(1));\nPromise.resolve().then(() =&gt; console.log(2));\nprocess.nextTick(() =&gt; console.log(3));\nPromise.resolve().then(() =&gt; console.log(4));\n// 1\n// 3\n// 2\n// 4\n</code></pre></blockquote>\n\n<p>上面代码中，全部<code>process.nextTick</code>的回调函数，执行都会早于<code>Promise</code>的。</p>\n\n<p>至此，本轮循环的执行顺序就讲完了。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>同步任务</li>\n<li>process.nextTick()</li>\n<li>微任务</li>\n</ol>\n</blockquote>\n\n<h2>五、事件循环的概念</h2>\n\n<p>下面开始介绍次轮循环的执行顺序，这就必须理解什么是事件循环（event loop）了。</p>\n\n<p>Node 的<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">官方文档</a>是这样介绍的。</p>\n\n<blockquote>\n  <p>&quot;When Node.js starts, it initializes the event loop, processes the provided input script  which may make async API calls, schedule timers, or call process.nextTick(), then begins processing the event loop.&quot;</p>\n</blockquote>\n\n<p>这段话很重要，需要仔细读。它表达了三层意思。</p>\n\n<p>首先，有些人以为，除了主线程，还存在一个单独的事件循环线程。不是这样的，只有一个主线程，事件循环是在主线程上完成的。</p>\n\n<p>其次，Node 开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情。</p>\n\n<blockquote>\n  <ul>\n<li>同步任务</li>\n<li>发出异步请求</li>\n<li>规划定时器生效的时间</li>\n<li>执行<code>process.nextTick()</code>等等</li>\n</ul>\n</blockquote>\n\n<p>最后，上面这些事情都干完了，事件循环就正式开始了。</p>\n\n<h2>六、事件循环的六个阶段</h2>\n\n<p>事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。</p>\n\n<p>每一轮的事件循环，分成六个阶段。这些阶段会依次执行。</p>\n\n<blockquote>\n  <ol start=\"1\">\n<li>timers</li>\n<li>I/O callbacks</li>\n<li>idle, prepare</li>\n<li>poll</li>\n<li>check</li>\n<li>close callbacks</li>\n</ol>\n</blockquote>\n\n<p>每个阶段都有一个先进先出的回调函数队列。只有一个阶段的回调函数队列清空了，该执行的回调函数都执行了，事件循环才会进入下一个阶段。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022304.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6dbe6a60b316a9f24be19102638f2e77837af203\" alt=\"\" title=\"\"></p>\n\n<p>下面简单介绍一下每个阶段的含义，详细介绍可以看<a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">官方文档</a>，也可以参考 libuv 的<a href=\"https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1\">源码解读</a>。</p>\n\n<p><strong>（1）timers</strong></p>\n\n<p>这个是定时器阶段，处理<code>setTimeout()</code>和<code>setInterval()</code>的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。</p>\n\n<p><strong>（2）I/O callbacks</strong></p>\n\n<p>除了以下操作的回调函数，其他的回调函数都在这个阶段执行。</p>\n\n<blockquote>\n  <ul>\n<li><code>setTimeout()</code>和<code>setInterval()</code>的回调函数</li>\n<li><code>setImmediate()</code>的回调函数</li>\n<li>用于关闭请求的回调函数，比如<code>socket.on(&apos;close&apos;, ...)</code></li>\n</ul>\n</blockquote>\n\n<p><strong>（3）idle, prepare</strong></p>\n\n<p>该阶段只供 libuv 内部调用，这里可以忽略。</p>\n\n<p><strong>（4）Poll</strong></p>\n\n<p>这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。</p>\n\n<p>这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</p>\n\n<p><strong>（5）check</strong></p>\n\n<p>该阶段执行<code>setImmediate()</code>的回调函数。</p>\n\n<p><strong>（6）close callbacks</strong></p>\n\n<p>该阶段执行关闭请求的回调函数，比如<code>socket.on(&apos;close&apos;, ...)</code>。</p>\n\n<h2>七、事件循环的示例</h2>\n\n<p>下面是来自官方文档的一个示例。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nconst fs = require(&apos;fs&apos;);\n\nconst timeoutScheduled = Date.now();\n\n// 异步任务一：100ms 后执行的定时器\nsetTimeout(() =&gt; {\n  const delay = Date.now() - timeoutScheduled;\n  console.log(`${delay}ms`);\n}, 100);\n\n// 异步任务二：文件读取后，有一个 200ms 的回调函数\nfs.readFile(&apos;test.js&apos;, () =&gt; {\n  const startCallback = Date.now();\n  while (Date.now() - startCallback &lt; 200) {\n    // 什么也不做\n  }\n});\n</code></pre></blockquote>\n\n<p>上面代码有两个异步任务，一个是 100ms 后执行的定时器，一个是文件读取，它的回调函数需要 200ms。请问运行结果是什么？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D993a43472a86017ec92380987e137dd2eeb1d47b\" alt=\"\" title=\"\"></p>\n\n<p>脚本进入第一轮事件循环以后，没有到期的定时器，也没有已经可以执行的 I/O 回调函数，所以会进入 Poll 阶段，等待内核返回文件读取的结果。由于读取小文件一般不会超过 100ms，所以在定时器到期之前，Poll 阶段就会得到结果，因此就会继续往下执行。</p>\n\n<p>第二轮事件循环，依然没有到期的定时器，但是已经有了可以执行的 I/O 回调函数，所以会进入 I/O callbacks 阶段，执行<code>fs.readFile</code>的回调函数。这个回调函数需要 200ms，也就是说，在它执行到一半的时候，100ms 的定时器就会到期。但是，必须等到这个回调函数执行完，才会离开这个阶段。</p>\n\n<p>第三轮事件循环，已经有了到期的定时器，所以会在 timers 阶段执行定时器。最后输出结果大概是200多毫秒。</p>\n\n<h2>八、setTimeout 和 setImmediate</h2>\n\n<p>由于<code>setTimeout</code>在 timers 阶段执行，而<code>setImmediate</code>在 check 阶段执行。所以，<code>setTimeout</code>会早于<code>setImmediate</code>完成。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nsetTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\n</code></pre></blockquote>\n\n<p>上面代码应该先输出<code>1</code>，再输出<code>2</code>，但是实际执行的时候，结果却是不确定，有时还会先输出<code>2</code>，再输出<code>1</code>。</p>\n\n<p>这是因为<code>setTimeout</code>的第二个参数默认为<code>0</code>。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据<a href=\"https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_args\">官方文档</a>，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，<code>setTimeout(f, 0)</code>等同于<code>setTimeout(f, 1)</code>。</p>\n\n<p>实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行<code>setImmediate</code>的回调函数。</p>\n\n<p>但是，下面的代码一定是先输出2，再输出1。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nconst fs = require(&apos;fs&apos;);\n\nfs.readFile(&apos;test.js&apos;, () =&gt; {\n  setTimeout(() =&gt; console.log(1));\n  setImmediate(() =&gt; console.log(2));\n});\n</code></pre></blockquote>\n\n<p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，<code>setImmediate</code>才会早于<code>setTimeout</code>执行。</p>\n\n<h2>九、参考链接</h2>\n\n<ul>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\">The Node.js Event Loop, Timers, and process.nextTick()</a>, by Node.js</li>\n<li><a href=\"https://jsblog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1\">Handling IO -- NodeJS Event Loop</a>, by Deepal Jayasekara</li>\n<li><a href=\"http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/\">setImmediate() vs nextTick() vs setTimeout(fn,0) - in depth explanation</a>, by Paul Shan</li>\n<li><a href=\"http://voidcanvas.com/nodejs-event-loop/\">Node.js event loop workflow &amp; lifecycle in low level</a>, by Paul Shan</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018022301.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df2ed67d3ed4d25af420cea4f1f15629e5b30dc93","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html","sourceType":"blog","time":"2018-02-23 08:43:45"},{"id":6,"name":"Docker 微服务教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>Docker 是一个容器工具，提供虚拟环境。很多人认为，它改变了我们对软件的认识。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>站在 Docker 的角度，软件就是容器的组合：业务逻辑容器、数据库容器、储存容器、队列容器......Docker 使得软件可以拆分成若干个标准化容器，然后像搭积木一样组合起来。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021306.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db6840b3eb476ed6b06a9e8492cbe4c59f24d03f7\" alt=\"\" title=\"\"></p>\n\n<p>这正是微服务（microservices）的思想：软件把任务外包出去，让各种外部服务完成这些任务，软件本身只是底层服务的调度中心和组装层。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021302.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd5c12ae6e3bc3b7229a6e48f7a571b81a10bea34\" alt=\"\" title=\"\"></p>\n\n<p>微服务很适合用 Docker 容器实现，每个容器承载一个服务。一台计算机同时运行多个容器，从而就能很轻松地模拟出复杂的微服务架构。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021303.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D234d7aeef1d5ffe029e84d48cb5956c948a0b563\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html\">上一篇教程</a>介绍了 Docker 的概念和基本用法，本文接着往下介绍，如何在一台计算机上实现多个服务，让它们互相配合，组合出一个应用程序。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021304.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D794f48fb90d724d01cc9baec5dfbf33b31d6edda\" alt=\"\" title=\"\"></p>\n\n<p>我选择的示例软件是 <a href=\"https://wordpress.org/\">WordPress</a>。它是一个常用软件，全世界用户据说超过几千万。同时它又非常简单，只要两个容器就够了（业务容器 + 数据库容器），很适合教学。而且，这种&quot;业务 + 数据库&quot;的容器架构，具有通用性，许多应用程序都可以复用。</p>\n\n<p>为了加深读者理解，本文采用三种方法，演示如何架设 WordPress 网站。</p>\n\n<blockquote>\n  <ul>\n<li>方法 A：自建 WordPress 容器</li>\n<li>方法 B：采用官方的 WordPress 容器</li>\n<li>方法 C：采用 Docker Compose 工具</li>\n</ul>\n</blockquote>\n\n<h2>一、预备工作：image 仓库的镜像网址</h2>\n\n<p>本教程需要从仓库下载 image 文件，但是国内访问 Docker 的官方仓库很慢，还经常断线，所以要把仓库网址改成国内的镜像站。这里推荐使用官方镜像 registry.docker-cn.com 。下面是我的 Debian 系统的默认仓库修改方法，其他系统的修改方法参考<a href=\"https://www.docker-cn.com/registry-mirror\">官方文档</a>。</p>\n\n<p>打开<code>/etc/default/docker</code>文件（需要<code>sudo</code>权限），在文件的底部加上一行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nDOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;\n</code></pre></blockquote>\n\n<p>然后，重启 Docker 服务。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo service docker restart\n</code></pre></blockquote>\n\n<p>现在就会自动从镜像仓库下载 image 文件了。</p>\n\n<h2>二、方法 A：自建 WordPress 容器</h2>\n\n<p>前面说过，本文会用三种方法演示 WordPress 的安装。第一种方法就是自建 WordPress 容器。</p>\n\n<h3>2.1 官方 的 PHP image</h3>\n\n<p>首先，新建一个工作目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir docker-demo &amp;&amp; cd docker-demo\n</code></pre></blockquote>\n\n<p>然后，执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name wordpress \n  --volume &quot;$PWD/&quot;:/var/www/html \n  php:5.6-apache\n</code></pre></blockquote>\n\n<p>上面的命令基于<code>php</code>的 image 文件新建一个容器，并且运行该容器。<code>php</code>的标签是<code>5.6-apache</code>，说明装的是 PHP 5.6，并且自带 Apache 服务器。该命令的三个参数含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>--rm</code>：停止运行后，自动删除容器文件。</li>\n<li><code>--name wordpress</code>：容器的名字叫做<code>wordpress</code>。</li>\n<li><code>--volume &quot;$PWD/&quot;:/var/www/html</code>：将当前目录（<code>$PWD</code>）映射到容器的<code>/var/www/html</code>（Apache 对外访问的默认目录）。因此，当前目录的任何修改，都会反映到容器里面，进而被外部访问到。</li>\n</ul>\n</blockquote>\n\n<p>运行上面的命令以后，如果一切正常，命令行会提示容器对外的 IP 地址，请记下这个地址，我们要用它来访问容器。我分配到的 IP 地址是 172.17.0.2。</p>\n\n<p>打开浏览器，访问 172.17.0.2，你会看到下面的提示。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nForbidden\nYou don&apos;t have permission to access / on this server.\n</code></pre></blockquote>\n\n<p>这是因为容器的<code>/var/www/html</code>目录（也就是本机的<code>docker-demo</code>目录）下面什么也没有，无法提供可以访问的内容。</p>\n\n<p>请在本机的<code>docker-demo</code>目录下面，添加一个最简单的 PHP 文件<code>index.php</code>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n&lt;?php \nphpinfo();\n?&gt;\n</code></pre></blockquote>\n\n<p>保存以后，浏览器刷新<code>172.17.0.2</code>，应该就会看到熟悉的<code>phpinfo</code>页面了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021305.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D5de30b20608db3c72808560f4593608e65dab3eb\" alt=\"\" title=\"\"></p>\n\n<h3>2.2 拷贝 WordPress 安装包</h3>\n\n<p>既然本地的<code>docker-demo</code>目录可以映射到容器里面，那么把 WordPress 安装包拷贝到<code>docker-demo</code>目录下，不就可以通过容器访问到 WordPress 的安装界面了吗？</p>\n\n<p>首先，在<code>docker-demo</code>目录下，执行下面的命令，抓取并解压 WordPress 安装包。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ wget https://cn.wordpress.org/wordpress-4.9.4-zh_CN.tar.gz\n$ tar -xvf wordpress-4.9.4-zh_CN.tar.gz\n</code></pre></blockquote>\n\n<p>解压以后，WordPress 的安装文件会在<code>docker-demo/wordpress</code>目录下。</p>\n\n<p>这时浏览器访问<code>http://172.17.0.2/wordpress</code>，就能看到 WordPress 的安装提示了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021307.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D87c76c168cc3f5a820d8861a9d3c63d532cd4528\" alt=\"\" title=\"\"></p>\n\n<h3>2.3 官方的 MySQL 容器</h3>\n\n<p>WordPress 必须有数据库才能安装，所以必须新建 MySQL 容器。</p>\n\n<p>打开一个新的命令行窗口，执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  --rm \n  --name wordpressdb \n  --env MYSQL_ROOT_PASSWORD=123456 \n  --env MYSQL_DATABASE=wordpress \n  mysql:5.7\n</code></pre></blockquote>\n\n<p>上面的命令会基于 MySQL 的 image 文件（5.7版本）新建一个容器。该命令的五个命令行参数的含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>-d</code>：容器启动后，在后台运行。</li>\n<li><code>--rm</code>：容器终止运行后，自动删除容器文件。</li>\n<li><code>--name wordpressdb</code>：容器的名字叫做<code>wordpressdb</code></li>\n<li><code>--env MYSQL_ROOT_PASSWORD=123456</code>：向容器进程传入一个环境变量<code>MYSQL_ROOT_PASSWORD</code>，该变量会被用作 MySQL 的根密码。</li>\n<li><code>--env MYSQL_DATABASE=wordpress</code>：向容器进程传入一个环境变量<code>MYSQL_DATABASE</code>，容器里面的 MySQL 会根据该变量创建一个同名数据库（本例是<code>WordPress</code>）。</li>\n</ul>\n</blockquote>\n\n<p>运行上面的命令以后，正常情况下，命令行会显示一行字符串，这是容器的 ID，表示已经新建成功了。</p>\n\n<p>这时，使用下面的命令查看正在运行的容器，你应该看到<code>wordpress</code>和<code>wordpressdb</code>两个容器正在运行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container ls\n</code></pre></blockquote>\n\n<p>其中，<code>wordpressdb</code>是后台运行的，前台看不见它的输出，必须使用下面的命令查看。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container logs wordpressdb\n</code></pre></blockquote>\n\n<h3>2.4 定制 PHP 容器</h3>\n\n<p>现在 WordPress 容器和 MySQL 容器都已经有了。接下来，要把 WordPress 容器连接到 MySQL 容器了。但是，PHP 的官方 image 不带有<code>mysql</code>扩展，必须自己新建 image 文件。</p>\n\n<p>首先，停掉 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress\n</code></pre></blockquote>\n\n<p>停掉以后，由于<code>--rm</code>参数的作用，该容器文件会被自动删除。</p>\n\n<p>然后，在<code>docker-demo</code>目录里面，新建一个<code>Dockerfile</code>文件，写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nFROM php:5.6-apache\nRUN docker-php-ext-install mysqli\nCMD apache2-foreground\n</code></pre></blockquote>\n\n<p>上面代码的意思，就是在原来 PHP 的 image 基础上，安装<code>mysqli</code>的扩展。然后，启动 Apache。</p>\n\n<p>基于这个 Dockerfile 文件，新建一个名为<code>phpwithmysql</code>的 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker build -t phpwithmysql .\n</code></pre></blockquote>\n\n<h3>2.5 Wordpress 容器连接 MySQL</h3>\n\n<p>现在基于 phpwithmysql image，重新新建一个 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  --rm \n  --name wordpress \n  --volume &quot;$PWD/&quot;:/var/www/html \n  --link wordpressdb:mysql \n  phpwithmysql\n</code></pre></blockquote>\n\n<p>跟上一次相比，上面的命令多了一个参数<code>--link wordpressdb:mysql</code>，表示 WordPress 容器要连到<code>wordpressdb</code>容器，冒号表示该容器的别名是<code>mysql</code>。</p>\n\n<p>这时还要改一下<code>wordpress</code>目录的权限，让容器可以将配置信息写入这个目录（容器内部写入的<code>/var/www/html</code>目录，会映射到这个目录）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ chmod -R 777 wordpress\n</code></pre></blockquote>\n\n<p>接着，回到浏览器的<code>http://172.17.0.2/wordpress</code>页面，点击&quot;现在就开始！&quot;按钮，开始安装。</p>\n\n<p>WordPress 提示要输入数据库参数。输入的参数如下。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021308.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D801fd47f3a376b6421d30529032a99c9970019e3\" alt=\"\" title=\"\"></p>\n\n<blockquote>\n  <ul>\n<li>数据库名：<code>wordpress</code></li>\n<li>用户名：<code>root</code></li>\n<li>密码：<code>123456</code></li>\n<li>数据库主机：<code>mysql</code></li>\n<li>表前缀：<code>wp_</code>（不变）</li>\n</ul>\n</blockquote>\n\n<p>点击&quot;下一步&quot;按钮，如果 Wordpress 连接数据库成功，就会出现下面的页面，这就表示可以安装了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021309.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De9514d0610f2d050b225189e1ba483c51be9f4cd\" alt=\"\" title=\"\"></p>\n\n<p>至此，自建 WordPress 容器的演示完毕，可以把正在运行的两个容器关闭了（容器文件会自动删除）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress wordpressdb\n</code></pre></blockquote>\n\n<h2>三、方法 B：Wordpress 官方镜像</h2>\n\n<p>上一部分的自建 WordPress 容器，还是挺麻烦的。其实不用这么麻烦，Docker 已经提供了官方 <a href=\"https://hub.docker.com/_/wordpress/\">WordPress</a> image，直接用那个就可以了。有了上一部分的基础，下面的操作就很容易理解了。</p>\n\n<h3>3.1 基本用法</h3>\n\n<p>首先，新建并启动 MySQL 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  --rm \n  --name wordpressdb \n  --env MYSQL_ROOT_PASSWORD=123456 \n  --env MYSQL_DATABASE=wordpress \n  mysql:5.7\n</code></pre></blockquote>\n\n<p>然后，基于官方的 WordPress image，新建并启动 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run \n  -d \n  --rm \n  --name wordpress \n  --env WORDPRESS_DB_PASSWORD=123456 \n  --link wordpressdb:mysql \n  wordpress\n</code></pre></blockquote>\n\n<p>上面命令中，各个参数的含义前面都解释过了，其中环境变量<code>WORDPRESS_DB_PASSWORD</code>是 MySQL 容器的根密码。</p>\n\n<p>上面命令指定<code>wordpress</code>容器在后台运行，导致前台看不见输出，使用下面的命令查出<code>wordpress</code>容器的 IP 地址。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container inspect wordpress\n</code></pre></blockquote>\n\n<p>上面命令运行以后，会输出很多内容，找到<code>IPAddress</code>字段即可。我的机器返回的 IP 地址是<code>172.17.0.3</code>。 </p>\n\n<p>浏览器访问<code>172.17.0.3</code>，就会看到 WordPress 的安装提示。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021310.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D6e92e55675cd5b46b32338357b755d7dac07c15b\" alt=\"\" title=\"\"></p>\n\n<h3>3.2 WordPress 容器的定制</h3>\n\n<p>到了上一步，官方 WordPress 容器的安装就已经成功了。但是，这种方法有两个很不方便的地方。</p>\n\n<blockquote>\n  <ul>\n<li>每次新建容器，返回的 IP 地址不能保证相同，导致要更换 IP 地址访问 WordPress。</li>\n<li>WordPress 安装在容器里面，本地无法修改文件。</li>\n</ul>\n</blockquote>\n\n<p>解决这两个问题很容易，只要新建容器的时候，加两个命令行参数就可以了。</p>\n\n<p>先把刚才启动的 WordPress 容器终止（容器文件会自动删除）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress\n</code></pre></blockquote>\n\n<p>然后，使用下面的命令新建并启动 WordPress 容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n $ docker container run \n  -d \n  -p 127.0.0.2:8080:80 \n  --rm \n  --name wordpress \n  --env WORDPRESS_DB_PASSWORD=123456 \n  --link wordpressdb:mysql \n  --volume &quot;$PWD/wordpress&quot;:/var/www/html \n  wordpress\n</code></pre></blockquote>\n\n<p>上面的命令跟前面相比，命令行参数只多出了两个。</p>\n\n<blockquote>\n  <ul>\n<li><code>-p 127.0.0.2:8080:80</code>：将容器的 80 端口映射到<code>127.0.0.2</code>的<code>8080</code>端口。</li>\n<li><code>--volume &quot;$PWD/wordpress&quot;:/var/www/html</code>：将容器的<code>/var/www/html</code>目录映射到当前目录的<code>wordpress</code>子目录。</li>\n</ul>\n</blockquote>\n\n<p>浏览器访问<code>127.0.0.2:8080:80</code>就能看到 WordPress 的安装提示了。而且，你在<code>wordpress</code>子目录下的每次修改，都会反映到容器里面。</p>\n\n<p>最后，终止这两个容器（容器文件会自动删除）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container stop wordpress wordpressdb\n</code></pre></blockquote>\n\n<h2>四、方法 C：Docker Compose 工具</h2>\n\n<p>上面的方法 B 已经挺简单了，但是必须自己分别启动两个容器，启动的时候，还要在命令行提供容器之间的连接信息。因此，Docker 提供了一种更简单的方法，来管理多个容器的联动。</p>\n\n<h3>4.1 Docker Compose 简介</h3>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021311.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D73175fd1db4fcf02a6df9e8b8c3052ba42e150c3\" alt=\"\" title=\"\"></p>\n\n<p><a href=\"https://docs.docker.com/compose/\">Compose</a> 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 <a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html\">YAML</a> 格式的配置文件<code>docker-compose.yml</code>，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 启动所有服务\n$ docker-compose up\n# 关闭所有服务\n$ docker-compose stop\n</code></pre></blockquote>\n\n<h3>4.2 Docker Compose 的安装</h3>\n\n<p>Mac 和 Windows 在安装 docker 的时候，会一起安装 docker compose。Linux 系统下的安装参考<a href=\"https://docs.docker.com/compose/install/#install-compose\">官方文档</a>。 </p>\n\n<p>安装完成后，运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose --version\n</code></pre></blockquote>\n\n<h3>4.3 WordPress 示例</h3>\n\n<p>在<code>docker-demo</code>目录下，新建<code>docker-compose.yml</code>文件，写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nmysql:\n    image: mysql:5.7\n    environment:\n     - MYSQL_ROOT_PASSWORD=123456\n     - MYSQL_DATABASE=wordpress\nweb:\n    image: wordpress\n    links:\n     - mysql\n    environment:\n     - WORDPRESS_DB_PASSWORD=123456\n    ports:\n     - &quot;127.0.0.3:8080:80&quot;\n    working_dir: /var/www/html\n    volumes:\n     - wordpress:/var/www/html\n</code></pre></blockquote>\n\n<p>上面代码中，两个顶层标签表示有两个容器<code>mysql</code>和<code>web</code>。每个容器的具体设置，前面都已经讲解过了，还是挺容易理解的。</p>\n\n<p>启动两个容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose up\n</code></pre></blockquote>\n\n<p>浏览器访问 http://127.0.0.3:8080，应该就能看到 WordPress 的安装界面。</p>\n\n<p>现在关闭两个容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose stop\n</code></pre></blockquote>\n\n<p>关闭以后，这两个容器文件还是存在的，写在里面的数据不会丢失。下次启动的时候，还可以复用。下面的命令可以把这两个容器文件删除（容器必须已经停止运行）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker-compose rm\n</code></pre></blockquote>\n\n<h2>五、参考链接</h2>\n\n<ul>\n<li><a href=\"https://www.sitepoint.com/how-to-manually-build-docker-containers-for-wordpress/\">How to Manually Build Docker Containers for WordPress</a>, by Aleksander Koko</li>\n<li><a href=\"https://www.sitepoint.com/how-to-use-the-official-docker-wordpress-image/\">How to Use the Official Docker WordPress Image</a>, by Aleksander Koko</li>\n<li><a href=\"https://www.sitepoint.com/deploying-wordpress-with-docker/\">Deploying WordPress with Docker</a>, by Aleksander Koko</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018021306.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612646%3B1553148646%26q-key-time%3D1521612646%3B1553148646%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db6840b3eb476ed6b06a9e8492cbe4c59f24d03f7","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html","sourceType":"blog","time":"2018-02-13 09:31:50"},{"id":7,"name":"Docker 入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>2013年发布至今， <a href=\"https://www.docker.com/\">Docker</a> 一直广受瞩目，被认为可能会改变软件行业。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018020901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612647%3B1553148647%26q-key-time%3D1521612647%3B1553148647%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3888ab38ddde6fb657f7667548c29ce0391a2247\" alt=\"\" title=\"\"></p>\n\n<h2>一、环境配置的难题</h2>\n\n<p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>\n\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>\n\n<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>\n\n<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n\n<h2>二、虚拟机</h2>\n\n<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>\n\n<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>\n\n<p><strong>（1）资源占用多</strong></p>\n\n<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>\n\n<p><strong>（2）冗余步骤多</strong></p>\n\n<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>\n\n<p><strong>（3）启动慢</strong></p>\n\n<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>\n\n<h2>三、Linux 容器</h2>\n\n<p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>\n\n<p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个<a href=\"https://opensource.com/article/18/1/history-low-level-container-runtimes\">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>\n\n<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>\n\n<p><strong>（1）启动快</strong></p>\n\n<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>\n\n<p><strong>（2）资源占用少</strong></p>\n\n<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>\n\n<p><strong>（3）体积小</strong></p>\n\n<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>\n\n<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>\n\n<h2>四、Docker 是什么？</h2>\n\n<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>\n\n<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>\n\n<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n\n<h2>五、Docker 的用途</h2>\n\n<p>Docker 的主要用途，目前有三大类。</p>\n\n<p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>\n\n<p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>\n\n<p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>\n\n<h2>六、Docker 的安装</h2>\n\n<p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p>\n\n<p>Docker CE 的安装请参考官方文档。</p>\n\n<blockquote>\n  <ul>\n<li><a href=\"https://docs.docker.com/docker-for-mac/install/\">Mac</a></li>\n<li><a href=\"https://docs.docker.com/docker-for-windows/install/\">Windows</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\">Ubuntu</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/debian/\">Debian</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">CentOS</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/fedora/\">Fedora</a></li>\n<li><a href=\"https://docs.docker.com/install/linux/docker-ce/binaries/\">其他 Linux 发行版</a></li>\n</ul>\n</blockquote>\n\n<p>安装完成后，运行下面的命令，验证是否安装成功。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker version\n# 或者\n$ docker info\n</code></pre></blockquote>\n\n<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href=\"https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user\">官方文档</a>）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ sudo usermod -aG docker $USER\n</code></pre></blockquote>\n\n<p>Docker 是服务器----客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href=\"https://docs.docker.com/config/daemon/systemd/\">官方文档</a>）。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# service 命令的用法\n$ sudo service docker start\n\n# systemctl 命令的用法\n$ sudo systemctl start docker\n</code></pre></blockquote>\n\n<h2>六、image 文件</h2>\n\n<p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>\n\n<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 列出本机的所有 image 文件。\n$ docker image ls\n\n# 删除 image 文件\n$ docker image rm [imageName]\n</code></pre></blockquote>\n\n<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>\n\n<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href=\"https://hub.docker.com/\">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>\n\n<h2>七、实例：hello world</h2>\n\n<p>下面，我们通过最简单的 image 文件&quot;<a href=\"https://hub.docker.com/r/library/hello-world/\">hello world&quot;</a>，感受一下 Docker。</p>\n\n<p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\">下一篇文章</a>的第一节。有需要的朋友，可以先看一下。</p>\n\n<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image pull library/hello-world\n</code></pre></blockquote>\n\n<p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>\n\n<p>由于 Docker 官方提供的 image 文件，都放在<a href=\"https://hub.docker.com/r/library/\"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image pull hello-world\n</code></pre></blockquote>\n\n<p>抓取成功以后，就可以在本机看到这个 image 文件了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image ls\n</code></pre></blockquote>\n\n<p>现在，运行这个 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run hello-world\n</code></pre></blockquote>\n\n<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>\n\n<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>\n\n<p>如果运行成功，你会在屏幕上读到下面的输出。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\n... ...\n</code></pre></blockquote>\n\n<p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p>\n\n<p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run -it ubuntu bash\n</code></pre></blockquote>\n\n<p>对于那些不会自动终止的容器，必须使用<a href=\"https://docs.docker.com/engine/reference/commandline/container_kill/\"><code>docker container kill</code></a> 命令手动终止。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container kill [containID]\n</code></pre></blockquote>\n\n<h2>八、容器文件</h2>\n\n<p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 列出本机正在运行的容器\n$ docker container ls\n\n# 列出本机所有容器，包括终止运行的容器\n$ docker container ls --all\n</code></pre></blockquote>\n\n<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p>\n\n<p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href=\"https://docs.docker.com/engine/reference/commandline/container_rm/\"><code>docker container rm</code></a>命令删除。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container rm [containerID]\n</code></pre></blockquote>\n\n<p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p>\n\n<h2>九、Dockerfile 文件</h2>\n\n<p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p>\n\n<p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>\n\n<p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p>\n\n<h2>十、实例：制作自己的 Docker 容器</h2>\n\n<p>下面我以 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p>\n\n<p>作为准备工作，请先<a href=\"https://github.com/ruanyf/koa-demos/archive/master.zip\">下载源码</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ git clone https://github.com/ruanyf/koa-demos.git\n$ cd koa-demos\n</code></pre></blockquote>\n\n<h3>10.1 编写 Dockerfile 文件</h3>\n\n<p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href=\"https://github.com/ruanyf/koa-demos/blob/master/.dockerignore\">内容</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n.git\nnode_modules\nnpm-debug.log\n</code></pre></blockquote>\n\n<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>\n\n<p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href=\"https://github.com/ruanyf/koa-demos/blob/master/Dockerfile\">内容</a>。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nFROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\n</code></pre></blockquote>\n\n<p>上面代码一共五行，含义如下。</p>\n\n<blockquote>\n  <ul>\n<li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>\n<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>\n<li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li>\n<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>\n<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>\n</ul>\n</blockquote>\n\n<h3>10.2 创建 image 文件</h3>\n\n<p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image build -t koa-demo .\n# 或者\n$ docker image build -t koa-demo:0.0.1 .\n</code></pre></blockquote>\n\n<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p>\n\n<p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image ls\n</code></pre></blockquote>\n\n<h3>10.3 生成容器</h3>\n\n<p><code>docker container run</code>命令会从 image 文件生成容器。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run -p 8000:3000 -it koa-demo /bin/bash\n# 或者\n$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash\n</code></pre></blockquote>\n\n<p>上面命令的各个参数含义如下：</p>\n\n<blockquote>\n  <ul>\n<li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li>\n<li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>\n<li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>\n<li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>\n</ul>\n</blockquote>\n\n<p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nroot@66d80f4aaf1e:/app#\n</code></pre></blockquote>\n\n<p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nroot@66d80f4aaf1e:/app# node demos/01.js\n</code></pre></blockquote>\n\n<p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found&quot;，这是因为这个 <a href=\"https://github.com/ruanyf/koa-demos/blob/master/demos/01.js\">demo</a> 没有写路由。</p>\n\n<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p>\n\n<p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 在本机的另一个终端窗口，查出容器的 ID\n$ docker container ls\n\n# 停止指定的容器运行\n$ docker container kill [containerID]\n</code></pre></blockquote>\n\n<p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n# 查出容器的 ID\n$ docker container ls --all\n\n# 删除指定的容器文件\n$ docker container rm [containerID]\n</code></pre></blockquote>\n\n<p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash\n</code></pre></blockquote>\n\n<h3>10.4 CMD 命令</h3>\n\n<p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\nFROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\nCMD node demos/01.js\n</code></pre></blockquote>\n\n<p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p>\n\n<p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p>\n\n<p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1\n</code></pre></blockquote>\n\n<h3>10.5 发布 image 文件</h3>\n\n<p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>\n\n<p>首先，去 <a href=\"https://hub.docker.com/\">hub.docker.com</a>  或 <a href=\"https://cloud.docker.com\">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker login\n</code></pre></blockquote>\n\n<p>接着，为本地的 image 标注用户名和版本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image tag [imageName] [username]/[repository]:[tag]\n# 实例\n$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1\n</code></pre></blockquote>\n\n<p>也可以不标注用户名，重新构建一下 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image build -t [username]/[repository]:[tag] .\n</code></pre></blockquote>\n\n<p>最后，发布 image 文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker image push [username]/[repository]:[tag]\n</code></pre></blockquote>\n\n<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>\n\n<h2>十一、其他有用的命令</h2>\n\n<p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>\n\n<p><strong>（1）docker container start</strong></p>\n\n<p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container start [containerID]\n</code></pre></blockquote>\n\n<p><strong>（2）docker container stop</strong></p>\n\n<p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ bash container stop [containerID]\n</code></pre></blockquote>\n\n<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>\n\n<p><strong>（3）docker container logs</strong></p>\n\n<p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container logs [containerID]\n</code></pre></blockquote>\n\n<p><strong>（4）docker container exec</strong></p>\n\n<p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container exec -it [containerID] /bin/bash\n</code></pre></blockquote>\n\n<p><strong>（5）docker container cp</strong></p>\n\n<p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ docker container cp [containID]:[/path/to/file] .\n</code></pre></blockquote>\n\n<p>非常感谢你一直读到了这里，这个系列还有<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\">下一篇</a>，介绍如何使用 Docker 搭建真正的网站，欢迎<a href=\"http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html\">继续阅读</a>。</p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018020901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612647%3B1553148647%26q-key-time%3D1521612647%3B1553148647%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3888ab38ddde6fb657f7667548c29ce0391a2247","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html","sourceType":"blog","time":"2018-02-09 05:53:27"},{"id":8,"name":"汇编语言入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012204.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd78c9986281022aee9aad5383b391fc352b8280f\" alt=\"\" title=\"\"></p>\n\n<p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>\n\n<p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012202.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D3b74b90c1eef5feef9e6e4c73c3d3d2ffe6097c7\" alt=\"\" title=\"\"></p>\n\n<h2>一、汇编语言是什么？</h2>\n\n<p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>\n\n<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。<a href=\"http://www.ruanyifeng.com/blog/2014/11/compiler.html\">编译器</a>的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>\n\n<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012203.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da4252298c1806683885e5c60b7f1cdb530dc8ebd\" alt=\"\" title=\"\"></p>\n\n<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>\n\n<h2>二、来历</h2>\n\n<p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>\n\n<p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p>\n\n<p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012205.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D015e7a31b2663c2318964e40a3d7a50aedbdbe7b\" alt=\"\" title=\"\"></p>\n\n<p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>\n\n<h2>三、寄存器</h2>\n\n<p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>\n\n<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>\n\n<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012206.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2c294f33e1e5a682751be2d7b26de481b3d5c77a\" alt=\"\" title=\"\"></p>\n\n<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>\n\n<h2>四、寄存器的种类</h2>\n\n<p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>\n\n<blockquote>\n  <ul>\n<li>EAX</li>\n<li>EBX</li>\n<li>ECX</li>\n<li>EDX</li>\n<li>EDI</li>\n<li>ESI</li>\n<li>EBP</li>\n<li>ESP</li>\n</ul>\n</blockquote>\n\n<p>上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012207.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd70aadfd9ca917fb62ecbbc83d856877eb0b99f1\" alt=\"\" title=\"\"></p>\n\n<p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p>\n\n<h2>五、内存模型：Heap</h2>\n\n<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>\n\n<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012208.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da503072300af4072fadd1f2cea73f54969a460a1\" alt=\"\" title=\"\"></p>\n\n<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012209.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D65cb8c45ddc8d4ed13bc8c172188f7adfd6c7269\" alt=\"\" title=\"\"></p>\n\n<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>\n\n<h2>六、内存模型：Stack</h2>\n\n<p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012210.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1b58548d479bbc93da61a304a201581e33d83db4\" alt=\"\" title=\"\"></p>\n\n<p>请看下面的例子。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nint main() {\n   int a = 2;\n   int b = 3;\n}\n</code></pre></blockquote>\n\n<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012211.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1239b4514aab6ae51b0eb56d383893f272cf928b\" alt=\"\" title=\"\"></p>\n\n<p>如果函数内部调用了其他函数，会发生什么情况？</p>\n\n<blockquote><pre><code class=\"language-clike\">\nint main() {\n   int a = 2;\n   int b = 3;\n   return add_a_and_b(a, b);\n}\n</code></pre></blockquote>\n\n<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012212.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D054a7a1583f55583021d6a46f4df0053f22f4c6b\" alt=\"\" title=\"\"></p>\n\n<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>\n\n<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做&quot;入栈&quot;，英文是 push；栈的回收叫做&quot;出栈&quot;，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做&quot;后进先出&quot;的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012213.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D288bf7bae34bf96273aaab451582d606d470a7de\" alt=\"\" title=\"\"></p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012214.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dde7de4aa3f5f773512ad8aa58cdaadb7d25e9c84\" alt=\"\" title=\"\"></p>\n\n<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012215.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D54cbb26a33a6a9dde358837ad5bcc905f3f28d3b\" alt=\"\" title=\"\"></p>\n\n<h2>七、CPU 指令</h2>\n\n<h3>7.1 一个实例</h3>\n\n<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nint add_a_and_b(int a, int b) {\n   return a + b;\n}\n\nint main() {\n   return add_a_and_b(2, 3);\n}\n</code></pre></blockquote>\n\n<p>gcc 将这个程序转成汇编语言。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ gcc -S example.c\n</code></pre></blockquote>\n\n<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>\n\n<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>\n\n<blockquote><pre><code class=\"language-clike\">\n_add_a_and_b:\n   push   %ebx\n   mov    %eax, [%esp+8] \n   mov    %ebx, [%esp+12]\n   add    %eax, %ebx \n   pop    %ebx \n   ret  \n\n_main:\n   push   3\n   push   2\n   call   _add_a_and_b \n   add    %esp, 8\n   ret\n</code></pre></blockquote>\n\n<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>\n\n<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   %ebx\n</code></pre></blockquote>\n\n<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>\n\n<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>\n\n<h3>7.2 push 指令</h3>\n\n<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>\n\n<p>然后，开始执行第一行代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   3\n</code></pre></blockquote>\n\n<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>\n\n<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   2\n</code></pre></blockquote>\n\n<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012216.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D65ed333e199ccae23510d13212a794146cba3e0c\" alt=\"\" title=\"\"></p>\n\n<h3>7.3 call 指令</h3>\n\n<p>第三行的<code>call</code>指令用来调用函数。</p>\n\n<blockquote><pre><code class=\"language-clike\">\ncall   _add_a_and_b\n</code></pre></blockquote>\n\n<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>\n\n<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npush   %ebx\n</code></pre></blockquote>\n\n<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>\n\n<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>\n\n<h3>7.4 mov 指令</h3>\n\n<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nmov    %eax, [%esp+8] \n</code></pre></blockquote>\n\n<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>\n\n<p>下一行代码也是干同样的事情。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nmov    %ebx, [%esp+12] \n</code></pre></blockquote>\n\n<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>\n\n<h3>7.5 add 指令</h3>\n\n<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nadd    %eax, %ebx\n</code></pre></blockquote>\n\n<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>\n\n<h3>7.6 pop 指令</h3>\n\n<p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>\n\n<blockquote><pre><code class=\"language-clike\">\npop    %ebx\n</code></pre></blockquote>\n\n<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>\n\n<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>\n\n<h3>7.7 ret 指令</h3>\n\n<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nret\n</code></pre></blockquote>\n\n<p>可以看到，该指令没有运算子。</p>\n\n<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nadd    %esp, 8 \n</code></pre></blockquote>\n\n<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>\n\n<blockquote><pre><code class=\"language-clike\">\nret\n</code></pre></blockquote>\n\n<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>\n\n<h2>八、参考链接</h2>\n\n<ul>\n<li><a href=\"http://kakaroto.homelinux.net/2017/11/introduction-to-reverse-engineering-and-assembly/\">Introduction to reverse engineering and Assembly</a>, by Youness Alaoui</li>\n<li><a href=\"http://www.cs.virginia.edu/~evans/cs216/guides/x86.html\">x86 Assembly Guide</a>, by University of Virginia Computer Science</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018012204.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd78c9986281022aee9aad5383b391fc352b8280f","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html","sourceType":"blog","time":"2018-01-21 18:17:48"},{"id":9,"name":"加密货币的本质","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>去年，比特币暴涨，其他币也像雨后春笋一样冒出来，已经有1000多种了。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>很多人都在问，加密货币（cryptocurrency）的时代，真的来临了吗？将来会不会人类不再使用美元、人民币，改用加密货币？那么多品种，我应该使用哪一种币？要不要现在就去投资一些？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db3f7e08de9693f72c7251e39f16c1b8504be59b9\" alt=\"\" title=\"\"></p>\n\n<p>这些问题的答案，我也想知道，就花了很多时间查阅资料、研究协议。前两周发表的<a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\">《区块链入门教程》</a>和<a href=\"http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html\">《比特币入门教程》</a>，是我的学习心得。但是，那两篇教程主要介绍基本概念、探讨协议的可行性，没回答一个根本的问题：加密货币到底是什么？</p>\n\n<p>下面就是我对这个问题的思考。阅读之前，如果你已经了解区块链和比特币，那很好；如果不了解，也没关系，本文不涉及技术，只讨论最基本的原理。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011102.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Decce88f5b0a3643f1a23db54dabd339a1bfd87d8\" alt=\"\" title=\"\"></p>\n\n<h2>一、钱是什么？</h2>\n\n<p>我们都知道，人民币是钱，美元是钱，金银财宝是钱。我问一个问题，它们为什么能成为钱？</p>\n\n<p>你可能回答，因为它们有价值，或者是价值的代表。但是，有价值的东西多了，为什么只有这些品种成为了钱？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011103.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da87be8850d5a2d6240d3e89c8179aa899aa22991\" alt=\"\" title=\"\"></p>\n\n<p>答案很容易想到，因为人们普遍相信（认同）它们的价值，其他东西的价值难以得到普通认同，无法成为钱。比如，邮票的价值就没有普遍的认同，除了集邮爱好者，其他地方都不能当钱用。一般来说，认同的人越多，这种钱的通用性就越高。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011104.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3De0835a17dd937a9484268ec751770f5761b7a337\" alt=\"\" title=\"\"></p>\n\n<p>我曾经去俄罗斯旅行，当地货币是卢布。可是，一旦离开俄国，没人相信它的购买力，所以卢布离开俄国就没用了。相反，全世界人民都相信美元的价值，所以全世界都能用。我用美元付账的时候，我发现那些俄国人都很满意。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011105.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D43c0a7d2cee1b0f5a8c253db6254aea099863b4f\" alt=\"\" title=\"\"></p>\n\n<p>所以，<strong>钱的本质，或者说货币的本质，就是它的可信性。</strong>它必须使人们相信，它是有价值的，然后才能成为钱，才能被收藏和支付。</p>\n\n<h2>二、可信性</h2>\n\n<p>为什么钱必须是可信的？因为对方必须相信它的价值，否则你没法支付出去。那么，接下来的问题就是，可信的东西是否就是钱？</p>\n\n<p>我的回答是 Yes。<strong>一样东西能否成为钱，只取决于人们是否相信它的价值，至于它是不是真的有价值，根本不重要。</strong></p>\n\n<p>如果马云在一张纸条上写&quot;这张纸条价值10000元&quot;，下面签了他的名，并且附上防伪标记。你说这纸条是钱吗？我跟你保证，这就是钱，你用来支付，人们都会接受，马云等同于发行了一种新的纸币。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011106.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D060b19e7f07e7cd4c7411d99c37314770a285593\" alt=\"\" title=\"\"></p>\n\n<p>比特币也是如此，它是什么，其实不太重要。重要的是，它必须保证自己是可信的，这样才能让足够的人相信它的价值，然后才能成为钱。</p>\n\n<h2>三、比特币的可信性</h2>\n\n<p><strong>比特币要解决的核心问题，就是创造一种可信的数字凭证。</strong>由于这种凭证可信，所以能够当做货币。</p>\n\n<p>比特币的技术基础是加密学，因为只有加密学才能保证它的可信性。一旦加密被破解，它就没法当作货币了。这也是这一类数字凭证被称为&quot;加密货币&quot;的原因。</p>\n\n<p>技术人员对比特币感兴趣，还有一个重要原因。任何需要可靠的数字凭证的场合，也许都可以用到这种技术。</p>\n\n<h2>四、比特币的特点</h2>\n\n<p>比特币有三个特点，就是因为做到了这三点，所以它可信，能够当作钱。</p>\n\n<p><strong>首先，它不会被（轻易）偷走。</strong>或者反过来说，它使得你无法去偷别人，你只能花你自己的钱。因为必须要有别人的私钥，才能取出他的钱。正常情况下，你拿不到别人的私钥。</p>\n\n<p><strong>其次，它无法伪造。</strong>每一个比特币都能追溯来源，而所有比特币都来源于矿工获得的奖励。矿工只有新建区块，才能获得奖励，这是很难的事情，所以无法伪造比特币。</p>\n\n<p><strong>最后，它无法大批生成。</strong>原因跟上一条一样，比特币的发行速度是稳定的，现在每10分钟新增12.5个，然后每四年减半，最终停止增长。因此不会像纸币那样，政府滥发导致通货膨胀。</p>\n\n<h2>五、比特币有实体吗？</h2>\n\n<p>由于后面要提到的原因，比特币不可能拥有实体，没法做到&quot;从口袋里掏出一个币&quot;这种场景，交易都必须通过互联网完成。</p>\n\n<p>你可能会说，钱都有实体，怎么可能存在无形的钱呢？答案正好相反，<strong>钱就应该是无形的，那些实体的钱其实是对物质材料的浪费，由于技术不够发达，不得不做成实体。</strong></p>\n\n<p>我小时候买东西，都必须用现金，否则没法证明，自己拥有购买力。只有通过实体的钱，才能保证对方确实收到了钱。如果银行业发达，就不用现金了，可以使用银行卡。支付的时候，对方抄一下银行卡号码，查询银行&quot;这个账户有钱吗&quot;。银行回答有钱，OK，成交。</p>\n\n<p>但是，互联网使得实体的银行卡也不需要了。如果存在一个开放的中央记账系统，任何人都可以查询，你把钱划到老板的账户，老板查询一下，发现收到了，交易自动成交，整个过程都是无形的，还需要什么银行卡呢？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011108.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D7852b7b8f447833e41dc9cc3e2718375714d5974\" alt=\"\" title=\"\"></p>\n\n<p>这个中央记账系统已经实现了，就叫做区块链。</p>\n\n<h2>六、区块链的作用</h2>\n\n<p><strong>区块链就是一个数据库，记载了所有的交易，用作中央记账系统。</strong></p>\n\n<p><strong>每笔交易的核心，就是一句话，比如&quot;张三向李四转移了1个比特币&quot;。</strong>为了证明这句话可信，张三为它加上了数字签名。任何人都可以用张三的公钥，证明这确实是张三本人的行为。另一方面，其他人无法伪造张三的数字签名，所以不可能伪造这笔交易。</p>\n\n<p>矿工们收到这句话，首先验证数字签名的可信性，然后验证张三确实拥有这些比特币（每一笔交易都有上一笔交易的编号，用来查询比特币的来源）。验证通过以后，就着手把这句话写入区块链了。一旦写入区块链，所有人就都可以查询到，因此这笔比特币就被认为，从张三转移到了李四。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011107.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfbe8d70bae4825e6dc573e251d61762bfd492958\" alt=\"\" title=\"\"></p>\n\n<p><strong>区块链的作用就是把这句话永久保存下来了，让任何人都可以查看，并且任何人（包括张三本人在内）都无法再修改了。</strong></p>\n\n<p><strong>货币是什么？其实就是这句话。这一句话就完成了一次支付。</strong>我们平时用人民币支付，其实只是用纸币表达这条信息。如果每个人都可以实时写入/读取中央记账系统（区块链），那么完全可以不携带货币。</p>\n\n<h2>七、双重支出</h2>\n\n<p>前面说过，交易不可能被伪造。但是，由于每一笔交易都是一串二进制信号，因此可能被复制。举例来说，&quot;张三向李四转移了1个比特币&quot;这句话，可能被其他人复制，也可能被张三自己复制，提交到区块链。</p>\n\n<p><strong>如果这句话被两次写入区块链，就意味着张三可以把同一笔钱花掉两次。</strong>但是，第二次写入的时候，查询区块链可以发现张三已经把这笔钱花掉了，从而认定这是不合法的交易，不能写入区块链。因此，复制交易是不可能的。</p>\n\n<p><strong>比较麻烦的是另一种情况，就是张三把同一笔钱付给两个人。</strong>他先向区块链提交一个交易&quot;张三向李四转移了1个比特币&quot;，然后又提交了另一个交易&quot;张三向王五转移了1个比特币&quot;。这两个交易都可能被认为是真实的交易，从而进入区块链。因此，必须有办法防止出现这种情况。</p>\n\n<p>情况一：同一个矿工收到了这两个交易。那么他会察觉到，它们不可能同时成立，因此选择其中的一笔写入区块链。</p>\n\n<p>情况二：矿工 A 收到了第一笔交易，矿工 B 收到了第二笔交易，他们各自都会认定这是合法的交易，分别把这两笔交易写入了两个区块，这时区块链就出现了分叉。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011109.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D2267bbc11e5ace556c5b98f1b4ad7f6c1fbe86b1\" alt=\"\" title=\"\"></p>\n\n<p>比特币协议规定，分叉点之后最先达到6个区块的那个分支，被认定为正式的区块链，其他分支都将被放弃。由于区块的生成速度由计算能力决定，所以到底哪一笔交易最后会被写入区块链，完全由它所在的分支能吸引多少计算能力决定。<strong>隐藏的逻辑是，如果大多数人（计算能力）选择相信某一笔交易，那么它就应该是真的。</strong></p>\n\n<p>综上所述，双重支出不可能发生。因为中央记账系统总有办法发现，你把同一笔钱花了两遍。但是，这也说明了比特币的一个代价，就是交易不能实时确认，必须等待至少一个小时。</p>\n\n<h2>八、参考链接</h2>\n\n<ul>\n<li><a href=\"http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/\">How the Bitcoin protocol actually works</a>, by Michael Nielsen</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018011101.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612648%3B1553148648%26q-key-time%3D1521612648%3B1553148648%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db3f7e08de9693f72c7251e39f16c1b8504be59b9","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html","sourceType":"blog","time":"2018-01-11 08:02:19"},{"id":10,"name":"比特币入门教程","author":"阮一峰","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>比特币（bitcoin）诞生于2008年的一篇<a href=\"https://bitcoin.org/en/bitcoin-paper\">论文</a>。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>一个署名为中本聪的人，提出了革命性的构想：让我们创造一种不受政府或其他任何人控制的货币！这个想法堪称疯狂：一串数字，背后没有任何资产支持，也没有任何人负责，你把它当作钱付给对方，怎么会有人愿意接受？</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010401.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D192d0b21725292ffcf4bae7cfcba20094e0ae926\" alt=\"\" title=\"\"></p>\n\n<p>但是，狂想居然变成了现实。随后的几年，在全世界无数爱好者的支持下，比特币网络运行起来了，越来越多的人和资本参与，星星之火，终成燎原。刚刚过去的2017年，比特币迎来了爆发式的增长，从年初的1000美元，最高涨到了2万美元，全世界都为之震动，上到政府，下到普通百姓都在关注。事实就是比特币已经并将继续改变世界。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010402.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8f84b77854fe8dcbbd4d144a68583730bac66c50\" alt=\"\" title=\"\"></p>\n\n<p>新闻媒体往往只关注它的火爆表现，忽视或者无法回答一些基本的问题。</p>\n\n<blockquote>\n  <ul>\n<li>比特币的原理是什么？</li>\n<li>为什么这个无人管理的体系可以成功运作？</li>\n<li>比特币交易的流程是怎么回事？</li>\n<li>它与区块链又是什么关系？</li>\n</ul>\n</blockquote>\n\n<p>下面，我尝试回答这些问题，希望帮助大家理解比特币。抛开技术细节，还是很容易解释的。</p>\n\n<p>有一点说明，本文只讨论技术问题，不涉及如何投资比特币，更不会预测价格走势。事实上，我也不知道，如果我知道怎么发财，可能就不会在这里写博客了。</p>\n\n<h2>一、非对称加密</h2>\n\n<p>首先，理解比特币，必须理解<a href=\"http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html\">非对称加密</a>。</p>\n\n<p>你可能听说过这个词，所谓非对称加密，其实很简单，就是加密和解密需要两把钥匙：一把公钥和一把私钥。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010403.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8927176033349a0ec24b064203ed285d4e79346a\" alt=\"\" title=\"\"></p>\n\n<p>公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息，然后发送给你，你用私钥解密，取出信息。反过来，你也可以用私钥加密信息，别人用你的公钥解开，从而证明这个信息确实是你发出的，且未被篡改，这叫做数字签名（更详细的介绍请看<a href=\"http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html\">《什么是数字签名》</a>）。</p>\n\n<p>现在请设想，<strong>如果公钥加密的不是普通的信息，而是加密了一笔钱，发送给你，这会怎样？</strong></p>\n\n<p>首先，你能解开加密包，取出里面的钱，因为私钥在你手里。其次，别人偷不走这笔钱，因为他们没有你的私钥。因此，支付可以成功。</p>\n\n<p>这就是比特币（以及其他数字货币）的原理：非对称加密保证了支付的可靠性。</p>\n\n<p>由于支付的钱必须通过私钥取出，所以你是谁并不重要，重要的是谁拥有私钥。只有拥有了私钥，才能取出支付给你的钱。（事实上，真实的交易流程稍有不同，私钥保证的不是取出支付给你的钱，而是保证只有你能把这些属于你的钱支付出去，详见后文。）</p>\n\n<h2>二、比特币钱包</h2>\n\n<p>对于比特币来说，钱不是支付给个人的，而是支付给某一把私钥。这就是交易匿名性的根本原因，因为没有人知道，那些私钥背后的主人是谁。</p>\n\n<p>所以，<strong>比特币交易的第一件事，就是你必须拥有自己的公钥和私钥。</strong></p>\n\n<p>你去网上那些比特币交易所开户，它们会让你首先生成一个比特币钱包（wallet）。<strong>这个钱包不是用来存放比特币，而是存放你的公钥和私钥。</strong>软件会帮你生成这两把钥匙，然后放在钱包里面。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010404.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D405957a9ba4f5aafb59b3bc31da822a42022fdd8\" alt=\"\" title=\"\"></p>\n\n<p>根据协议，公钥的长度是512位。这个长度不太方便传播，因此协议又规定，要为公钥生成一个160位的指纹。所谓指纹，就是一个比较短的、易于传播的哈希值。160位是二进制，写成十六进制，大约是26到35个字符，比如 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2。这个字符串就叫做钱包的地址，它是唯一的，即每个钱包的地址肯定都是不一样的。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010405.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D14aae41536ab36e5bc2b3695ec4eb1983ed9b796\" alt=\"\" title=\"\"></p>\n\n<p>你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。由于你是这个地址的拥有者，所以你会收到这笔钱。</p>\n\n<p>由于你是否拥有某个钱包地址，是由私钥证明的（具体的证明方法稍后介绍），所以一定要保护好私钥。这是极其重要的，如果你的私钥被偷了，你的比特币也就等于没了，因为他人可以冒用你的身份了，把钱包里面的钱都转走。</p>\n\n<p>同样的，你向他人支付比特币，千万不能写错他人的钱包地址，否则你的比特币就支付到了另一个不同的人了。</p>\n\n<h2>三、交易过程</h2>\n\n<p>下面，我把整个流程串起来，看看比特币如何完成一笔交易。</p>\n\n<p><strong>一笔交易就是一个地址的比特币，转移到另一个地址。</strong>由于比特币的交易记录全部都是公开的，哪个地址拥有多少比特币，都是可以查到的。因此，支付方是否拥有足够的比特币，完成这笔交易，这是可以轻易验证的。</p>\n\n<p>问题出在怎么防止其他人，冒用你的名义申报交易。举例来说，有人申报了一笔交易：地址 A 向地址 B 支付10个比特币。我怎么知道这个申报是真的，申报人就是地址 A 的主人？</p>\n\n<p>比特币协议规定，申报交易的时候，除了交易金额，转出比特币的一方还必须提供以下数据。</p>\n\n<blockquote>\n  <ul>\n<li>上一笔交易的 Hash（你从哪里得到这些比特币）</li>\n<li>本次交易双方的地址</li>\n<li>支付方的公钥</li>\n<li>支付方的私钥生成的数字签名</li>\n</ul>\n</blockquote>\n\n<p>验证这笔交易是否属实，需要三步。</p>\n\n<blockquote>\n  <p>第一步，找到上一笔交易，确认支付方的比特币来源。</p>\n\n<p>第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。</p>\n\n<p>第三步，使用公钥去解开数字签名，保证私钥属实。</p>\n</blockquote>\n\n<p>经过上面三步，就可以认定这笔交易是真实的。</p>\n\n<h2>四、交易确认与区块链</h2>\n\n<p>确认交易的真实性以后，交易还不算完成。<strong>交易数据必须写入数据库，才算成立，对方才能真正收到钱。</strong></p>\n\n<p>比特币使用的是一种特殊的数据库，叫做区块链（blockchain），详细的介绍请看<a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\">《区块链入门教程》</a>。本文只讨论交易如何写入区块链。</p>\n\n<p>首先，所有的交易数据都会传送到矿工那里。矿工负责把这些交易写入区块链。</p>\n\n<p>根据比特币协议，一个区块的大小最大是 1MB，而一笔交易大概是500字节左右，因此一个区块最多可以包含2000多笔交易。矿工负责把这2000多笔交易打包在一起，组成一个区块，然后计算这个区块的 Hash。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010406.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D811a702b726a25b0beaa4d38273d9652dc5be918\" alt=\"\" title=\"\"></p>\n\n<p>计算 Hash 的过程叫做采矿，这需要大量的计算。矿工之间也在竞争，谁先算出 Hash，谁就能第一个添加新区块进入区块链，从而享受这个区块的全部收益，而其他矿工将一无所获。</p>\n\n<p>一笔交易一旦写入了区块链，就无法反悔了。这里需要建立一个观念：<strong>比特币不存放在钱包或其他别的地方，而是只存在于区块链上面。</strong>区块链记载了你参与的每一笔交易，你得到过多少比特币，你又支付了多少比特币，因此可以算出来你拥有多少资产。</p>\n\n<h2>五、矿工的收益</h2>\n\n<p>交易的确认离不开矿工。为什么有人愿意做矿工呢？</p>\n\n<p>比特币协议规定，挖到新区块的矿工将获得奖励，一开始（2008年）是50个比特币，然后每4年减半，目前（2018年）是12.5个比特币。这也是比特币的供给增加机制，流通中新增的比特币都是这样诞生的。</p>\n\n<p>你可能看出来了，每4年奖励减半，那么到了2140年，矿工将得不到任何奖励，比特币的数量也将停止增加。这时，矿工的收益就完全依靠交易手续费了。</p>\n\n<p>所谓交易手续费，就是矿工可以从每笔交易抽成，具体的金额由支付方自愿决定。你完全可以一毛不拔，一分钱也不给矿工，但是那样的话，你的交易就会没人处理，迟迟无法写入区块链，得到确认。矿工们总是优先处理手续费最高的交易。</p>\n\n<p>目前由于交易数量猛增，手续费已经水涨船高，一个区块2000多笔交易的手续费总额可以达到3～10个比特币。如果你的手续费给低了，很可能过了一个星期，交易还没确认。</p>\n\n<p>一个区块的奖励金12.5个比特币，再加上手续费，收益是相当可观的。按照目前的价格，可以达到100万～200万人民币。想想看，运气好的话，几分钟就能挖到一个区块，拿到这样一大笔钱，怪不得人们对挖矿趋之若鹜。</p>\n\n<h2>六、区块的扩容</h2>\n\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html\">《区块链入门教程》</a>说过，比特币协议规定，平均10分钟诞生一个区块。区块的大小只有 1MB，最多只能包含2000多笔交易。也就是说，比特币网络每10分钟，最多只能处理2000多笔交易，换算一下，就是处理速度为3～5笔/秒。</p>\n\n<p>全世界的比特币交易这么多，可是区块链每秒最多只能处理5笔，这已经成为制约比特币发展的一个瓶颈。</p>\n\n<p>很早就有人呼吁，改革比特币协议，提升处理速度。这件事在2017年8月有了一点眉目，当时区块链发生了一次分叉，诞生了一个新协议，称为 <a href=\"https://en.wikipedia.org/wiki/Bitcoin_Cash\">Bitcoin Cash</a>（简称 BCH）。这种新货币其他方面都与比特币一致，就是每个区块的大小从 1MB 增加到了 8MB，因此处理速度提升了8倍，手续费也低得多。该协议是对原有区块链的分叉，因此当时持有比特币的人，等于一人获赠了一份同样数量的 BCH。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010407.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D885f3829b8c7f2e9dec722a9047db4d3d752b058\" alt=\"\" title=\"\"></p>\n\n<p>BCH 等于创造了一种新货币，还有人提议，原始比特币的区块大小提升到 2MB，这称为 <a href=\"https://en.wikipedia.org/wiki/SegWit2x\">SegWit2x</a> 。这个建议原定于2017年11月实施，但是最后一刻由于缺乏共识，就被取消了，目前还在讨论中。</p>\n\n<h2>七、点对点网络</h2>\n\n<p>比特币是一个全世界的开放网络，只要你有服务器，就能加入这个网络，成为一个节点。每个节点都包含了整个区块链（目前大概 100多 GB），并且节点之间时刻不停地在同步信息。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010408.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D779bb8768a71d13edba53994d63b4264698144dc\" alt=\"\" title=\"\"></p>\n\n<p>当你发生了一笔支付，你所在的节点就会把这笔交易告诉另一个节点，直至传遍整个网络。矿工从网上收集各种新发生的交易，将它们打包写入区块链。一旦写入成功，\n矿工所在节点的区块链，就成为最新版本，其他节点都会来复制新增的区块，保证全网的区块链都是一致的。</p>\n\n<p>最后，你所在的节点也拿到了最新的区块链，从而得知你早先的那笔交易，已经写在里面了，至此交易确认成功。</p>\n\n<h2>八、还有一个问题</h2>\n\n<p>写到这里，我就介绍完了比特币的基本知识，希望你已经明白了比特币是怎么回事。但是还有一个根本的问题，我没有回答：比特币的本质到底是什么？</p>\n\n<p>说到底，比特币只是区块链的一条记录，是凭空生成的，为什么可以当钱用？举例来说，矿工获得12.5个比特币的奖励，其实就是区块链有一个记录：&quot;xxx地址获得12.5个比特币&quot;。正是这行记录，导致该矿工获得了大笔金钱。如果区块链突然增加了一条记录，记载你的地址获得了1000个比特币，你就真的会有1000个比特币。这到底是为什么？</p>\n\n<p>这篇文章已经够长了，这个问题就留到下次再谈，欢迎关注本系列的最后一篇文章<a href=\"http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html\">《加密货币的本质》</a>。</p>\n\n<h2>九、参考链接</h2>\n\n<ul>\n<li><a href=\"https://arstechnica.com/tech-policy/2017/12/how-bitcoin-works/\">How Bitcoin works</a> , by Timothy B. Lee</li>\n<li><a href=\"http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html\">Bitcoins the hard way: Using the raw Bitcoin protocol</a>, by Ken Shirriff</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018010401.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612649%3B1553148649%26q-key-time%3D1521612649%3B1553148649%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D192d0b21725292ffcf4bae7cfcba20094e0ae926","blogType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html","sourceType":"blog","time":"2018-01-04 08:07:10"}]},
    '/getBlogInfo':{"id":1,"name":"Node 调试工具入门教程","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>JavaScript 程序越来越复杂，调试工具的重要性日益凸显。客户端脚本有浏览器，Node 脚本怎么调试呢？</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec2b77d560a7fa934a82bcb95433251c989d5aef\" alt=\"\" title=\"\"></p>\n\n<p>2016年，Node 决定将 Chrome 浏览器的&quot;开发者工具&quot;作为官方的调试工具，使得 Node 脚本也可以使用图形界面调试，这大大方便了开发者。</p>\n\n<p>本文介绍如何使用 Node 脚本的调试工具。</p>\n\n<h2>一、示例程序</h2>\n\n<p>为了方便讲解，下面是一个示例脚本。首先，新建一个工作目录，并进入该目录。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ mkdir debug-demo\n$ cd debug-demo\n</code></pre></blockquote>\n\n<p>然后，生成<code>package.json</code>文件，并安装 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">Koa</a> 框架和 koa-route 模块。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ npm init -y\n$ npm install --save koa koa-route\n</code></pre></blockquote>\n\n<p>接着，新建一个脚本<code>app.js</code>，并写入下面的内容。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\n// app.js\nconst Koa = require(&apos;koa&apos;);\nconst router = require(&apos;koa-route&apos;);\n\nconst app = new Koa();\n\nconst main = ctx =&gt; {\n  ctx.response.body = &apos;Hello World&apos;;\n};\n\nconst welcome = (ctx, name) =&gt; {\n  ctx.response.body = &apos;Hello &apos; + name;\n};\n\napp.use(router.get(&apos;/&apos;, main));\napp.use(router.get(&apos;/:name&apos;, welcome));\n\napp.listen(3000);\nconsole.log(&apos;listening on port 3000&apos;);\n</code></pre></blockquote>\n\n<p>上面代码是一个简单的 Web 应用，指定了两个路由，访问后会显示一行欢迎信息。如果想了解代码的详细含义，可以参考 <a href=\"http://www.ruanyifeng.com/blog/2017/08/koa.html\">Koa 教程</a>。</p>\n\n<h2>二、启动开发者工具</h2>\n\n<p>现在，运行上面的脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect app.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect</code>参数是启动调试模式必需的。这时，打开浏览器访问<code>http://127.0.0.1:3000</code>，就可以看到 Hello World 了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031902.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D0f7a5869f754fed79c42e1096b7b743b44f496b2\" alt=\"\" title=\"\"></p>\n\n<p>接下来，就要开始调试了。一共有两种打开调试工具的方法，第一种是在 Chrome 浏览器的地址栏，键入 <code>chrome://inspect</code>或者<code>about:inspect</code>，回车后就可以看到下面的界面。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031903.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D992dcac9c22a8adbfaeb168e224236ca4bac471d\" alt=\"\" title=\"\"></p>\n\n<p>在 Target 部分，点击 inspect 链接，就能进入调试工具了。</p>\n\n<p>第二种进入调试工具的方法，是在 http://127.0.0.1:3000 的窗口打开&quot;开发者工具&quot;，顶部左上角有一个 Node 的绿色标志，点击就可以进入。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031904.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D16cb3df6b7f535a5685a46f90fc99cbf3d3fa42e\" alt=\"\" title=\"\"></p>\n\n<h2>三、调试工具窗口</h2>\n\n<p>调试工具其实就是&quot;开发者工具&quot;的定制版，省去了那些对服务器脚本没用的部分。</p>\n\n<p>它主要有四个面板。</p>\n\n<blockquote>\n  <ul>\n<li>Console：控制台</li>\n<li>Memory：内存</li>\n<li>Profiler：性能</li>\n<li>Sources：源码</li>\n</ul>\n</blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031905.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D38b8828893983c02e08f13980c7dbe0a25c03e4a\" alt=\"\" title=\"\"></p>\n\n<p>这些面板的用法，基本上跟浏览器环境差不多，这里只介绍 Sources （源码）面板。</p>\n\n<h2>四、设置断点</h2>\n\n<p>进入 Sources 面板，找到正在运行的脚本<code>app.js</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031906.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D40e8b76d4f31b0cd4e747af4476603e093a43f32\" alt=\"\" title=\"\"></p>\n\n<p>在第11行（也就是下面这一行）的行号上点一下，就设置了一个断点。</p>\n\n<blockquote><pre><code class=\"language-javascript\">\nctx.response.body = &apos;Hello &apos; + name;\n</code></pre></blockquote>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031907.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8f3da848b36efaaa3971de6db9ec575d1cee8740\" alt=\"\" title=\"\"></p>\n\n<p>这时，浏览器访问 http://127.0.0.1:3000/alice ，页面会显示正在等待服务器返回。切换到调试工具，可以看到 Node 主线程处于暂停（paused）阶段。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031908.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dc0c3235e83a3b74b5bbe565aa0e3e334ea52c150\" alt=\"\" title=\"\"></p>\n\n<p>进入 Console 面板，输入 name，会返回 alice。这表明我们正处在断点处的上下文（context）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031909.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da3ad58d41a9079a3d038577c53188148dcb4be77\" alt=\"\" title=\"\"></p>\n\n<p>再切回 Sources 面板，右侧可以看到 Watch、Call Stack、Scope、Breakpoints 等折叠项。打开 Scope 折叠项，可以看到 Local 作用域和 Global 作用域里面的所有变量。</p>\n\n<p>Local 作用域里面，变量<code>name</code>的值是<code>alice</code>，双击进入编辑状态，把它改成<code>bob</code>。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031910.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D4f31b96a584a0a1d0f77bd474f24adf2b9444dfa\" alt=\"\" title=\"\"></p>\n\n<p>然后，点击顶部工具栏的继续运行按钮。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031911.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Da87d5772442cffce7fb042dd63cf309daebdcd05\" alt=\"\" title=\"\"></p>\n\n<p>页面上就可以看到 Hello bob 了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031912.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D82c8d21bfcf9e0433dcbdd8b806c38f7d9276d34\" alt=\"\" title=\"\"></p>\n\n<p>命令行下，按下 ctrl + c，终止运行<code>app.js</code>。</p>\n\n<h2>五、调试非服务脚本</h2>\n\n<p>Web 服务脚本会一直在后台运行，但是大部分脚本只是处理某个任务，运行完就会终止。这时，你可能根本没有时间打开调试工具。等你打开了，脚本早就结束运行了。这时怎么调试呢？</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect=9229 -e &quot;setTimeout(function() { console.log(&apos;yes&apos;); }, 30000)&quot;\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect=9229</code>指定调试端口为 9229，这是调试工具默认的通信端口。<code>-e</code>参数指定一个字符串，作为代码运行。</p>\n\n<p>访问<code>chrome://inspect</code>，就可以进入调试工具，调试这段代码了。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031913.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dfc40b600a1945a361ca5e44607b48d2ce9e6944a\" alt=\"\" title=\"\"></p>\n\n<p>代码放在<code>setTimeout</code>里面，总是不太方便。那些运行时间较短的脚本，可能根本来不及打开调试工具。这时就要使用下面的方法。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node --inspect-brk=9229 app.js\n</code></pre></blockquote>\n\n<p>上面代码中，<code>--inspect-brk</code>指定在第一行就设置断点。也就是说，一开始运行，就是暂停的状态。</p>\n\n<h2>六、忘了写 --inspect 怎么办？</h2>\n\n<p>打开调试工具的前提是，启动 Node 脚本时就加上<code>--inspect</code>参数。如果忘了这个参数，还能不能调试呢？</p>\n\n<p>回答是可以的。首先，正常启动脚本。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node app.js\n</code></pre></blockquote>\n\n<p>然后，在另一个命令行窗口，查找上面脚本的进程号。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ ps ax | grep app.js \n\n30464 pts/11   Sl+    0:00 node app.js\n30541 pts/12   S+     0:00 grep app.js\n</code></pre></blockquote>\n\n<p>上面命令中，<code>app.js</code>的进程号是<code>30464</code>。</p>\n\n<p>接着，运行下面的命令。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ node -e &apos;process._debugProcess(30464)&apos;\n</code></pre></blockquote>\n\n<p>上面命令会建立进程 30464 与调试工具的连接，然后就可以打开调试工具了。</p>\n\n<p>还有一种方法，就是向脚本进程发送 <a href=\"https://stackoverflow.com/questions/13052548/node-js-how-to-attach-to-a-running-process-and-to-debug-the-server-with-a-conso\">SIGUSR1</a> 信号，也可以建立调试连接。</p>\n\n<blockquote><pre><code class=\"language-bash\">\n$ kill -SIGUSR1 30464\n</code></pre></blockquote>\n\n<h2>七、参考链接</h2>\n\n<ul>\n<li><a href=\"https://medium.com/the-node-js-collection/debugging-node-js-with-google-chrome-4965b5f910f4\">Debugging Node.js with Google Chrome</a>, by Jacopo Daeli</li>\n<li><a href=\"https://medium.com/@paul_irish/debugging-node-js-nightlies-with-chrome-devtools-7c4a1b95ae27\">Debugging Node.js with Chrome DevTools</a>, by Paul Irish</li>\n<li><a href=\"https://remysharp.com/2018/03/03/last-minute-node-debugging\">Last minute node debugging</a>, by Remy Sharp</li>\n</ul>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","author":"阮一峰","time":"2018-03-20T00:11:35.000Z","sourceType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/node-debugger.html","createTime":"2018-03-20T00:11:35.000Z","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018031901.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dec2b77d560a7fa934a82bcb95433251c989d5aef","prev":{},"next":{"id":2,"name":"日本70岁退休谈起","content":"\n\n                                    <!-- div class=\"asset-body\" -->\n                                        <p>1、</p>\n\n<p>2018年初，日本政府<a href=\"https://www.qdaily.com/articles/50475.html\">修改法律</a>，推迟公务员的退休年龄。</p>\n\n                                    <!-- /div -->\n\n\n                                    <!-- div id=\"more\" class=\"asset-more\" -->\n                                        <p>现在，日本的公务员是60岁～63岁退休。新法律生效后，退休年龄立刻推迟到65岁，然后逐步推迟到70岁。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd6988d1648c21c3199c38b43b17cdea5e89e1045\" alt=\"\" title=\"\"></p>\n\n<p>更厉害的是，日本政府同时宣布，养老金制度也要改革。现在是65岁领取养老金，将来只有到了70岁才能领。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030802.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D033a894aa81cac356403331c5a1b8e2ccab96a55\" alt=\"\" title=\"\"></p>\n\n<p>如果我是一个刚刚毕业的日本大学生，听到这种消息，恐怕腿都要软了。日本那种毕恭毕敬、论资排辈的社会里面，上班简直像受罪一样。你必须每天小心翼翼地勤勉工作，日复一日地加班，所有前辈都下班了，你才能下班。这种生活要一直过到七十岁，怎不令人害怕？</p>\n\n<p>等到你走也走不动了，吃也吃不下了，才能领养老金，那么养老金又有多大意义呢，能够保障什么质量的生活呢？毕竟七十岁以前，都要靠自己啊。</p>\n\n<p>2、</p>\n\n<p>日本政府推迟退休，实在是迫不得已，因为日本的人口老龄化太严重了。</p>\n\n<p>日本是全世界人均寿命最高的国家之一，男81.7岁，女88.5岁。同时，日本也是全世界出生率最低的国家之一。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030804.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Db5026b30c86604653251a9a03fb161231788124c\" alt=\"\" title=\"\"></p>\n\n<p>结果就是人口不断萎缩，国民的平均年龄越来越大。2015年，日本人的平均年龄已经到了46.5岁，是全世界平均年龄最大的国家，而且这个数字以后还会变大。据估计，四十年后，日本人口会减少三分之一。</p>\n\n<p>日本对输入外国劳动力和外国移民控制极严，导致劳动力越来越少。日本政府发现，一方面，交税的人口不断减少；另一方面，领取养老金的人口不断增多，而且领的时间越来越长。于是别无选择，只能让老年人多上几年班，晚几年领养老金。</p>\n\n<p>3、</p>\n\n<p>几乎所有发达国家都存在同样的问题：养老金存在缺口，无法满足越来越多的老年人口。日本只是问题最严重而已。</p>\n\n<p>有些地区还不那么发达，也出现养老金问题，比如台湾地区。台湾的生育率也是世界最低之一，养老金早就不够用了，破产在即，不得不立刻改革，减少养老金发放规模，每个人的缴款增加，但是未来领取的金额却要减少。台湾年轻人的薪水并不高，台北房价却直逼香港东京，现在养老金又要减少，年轻人的郁闷和绝望可想而知。一个台湾网友给出了三条对策。</p>\n\n<blockquote>\n  <ul>\n<li>上策：要求改变制度设计，每一代人自己养自己，让有钱的老人补贴没钱的老人，不要拿下一代的钱发给上一代人。</li>\n<li>中策：移民，彻底脱离这个制度。自己出不去，也要让下一代出去。</li>\n<li>下策：如果走不了，就不要生育，并且拼命地挣钱和存钱。同时，支持安乐死合法化，因为未来很可能，你的钱都用光了，人却还没死。</li>\n</ul>\n</blockquote>\n\n<p>4、</p>\n\n<p>请设想这样一种情景。未来很可能过了65岁，你的头发白了、眼睛花了、牙齿松了，还不得不朝九晚五地上班，为别人打工。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030803.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Df39c32ae18eb0396a025d9ba0fef256d54c8bda3\" alt=\"\" title=\"\"></p>\n\n<p>就算你能健康活过七十岁领到养老金，那些钱也很可能由于通货膨胀，以及僧多粥少，而变得非常微薄。</p>\n\n<p>这种前景只要想一想，就会觉得不寒而栗。大多数人之所以工作，不是因为热爱工作，而是因为这样可以挣到钱，可以有保障，得到安稳的退休生活。但是这一切看上去很难实现了，如今你必须忍受着疲惫，工作更多年，到头来发现，你的养老并没有保障。</p>\n\n<p>难怪日本和台湾的很多年轻人，看不到前景，对未来不抱希望。日本和台湾都有很高的<a href=\"https://www.zhihu.com/question/19840174\">自杀率</a>，我想这绝不是偶然的。</p>\n\n<p>5、</p>\n\n<p>作为个人，要摆脱这种老无所依的命运，马上能想到的解决办法就是要多多挣钱。你不得不拼命工作，挣更多的钱。但是，这条路上已经挤满了人，很可能你为雇主投入了100%的心力，年复一年，到老还是在为生存挣扎。另一方面，很多人上班其实并不开心，想想看，如果要一直苦闷地熬到60多岁，人生一定没有什么幸福感。</p>\n\n<p>我有时会有另外一种想法：反正已经是这种处境了，为什么不索性换一种活法呢？如果不喜欢这个工作，你是否还要继续下去，熬到退休拿养老金？如果养老金是苦苦支撑到七十岁才能拿到，那能不能就当它不存在，趁早去干一些自己想干的事情？至少也要找一些自己喜欢、做起来开心的工作吧。</p>\n\n<p>甚至可不可以再进一步，与其等待别人决定，你应该在什么时候退休。我也可以做一回命运的主人，哪天觉得没意思了，拍拍衣服说，从现在开始我退休了，过另外一种生活。以前还有养老金可以期待，现在这种期待即使存在，也肯定小多了。</p>\n\n<p>提前退休并不意味着，从此你什么也不干了，而是让你有机会，转身尝试另一种生活，在一个自己有热情的领域创造出更大的价值。一旦你体验过，按照自己的想法生活，自由安排时间，你就完全回不去了，再也无法忍受那种大公司小隔间的呆板压抑的生活了。</p>\n\n<p>6、</p>\n\n<p>你可能会说，我的这种想法是水中月，镜中花，一厢情愿而已。没工作了就没钱，没钱怎么活？确实，提前退休就没收入了，但这注定我一定要为别人打工到退休吗？</p>\n\n<p>事实上，美国早有人研究过这个问题：一个普通的工薪族，怎么样才能在40岁退休？结论居然是，只要你不是那么穷，有一定的积蓄，普通人也可以40岁退休。</p>\n\n<p>这里有一个计算公式，如果你的所有钱都投资在证券上面，只要你一年的支出小于投资组合原始金额的4%，那么你就可以退休了。这被称为<a href=\"https://www.bloomberg.com/features/2016-early-retirement/\">&quot;百分之四&quot;规则</a>（Four Percent Rule）。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030805.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D8348c9d06d0930aa8d40dc192c34e826c21a2303\" alt=\"\" title=\"\"></p>\n\n<p>它的依据是1926年至1976年的美国证券投资回报率，有人发现即使这段时间熊市居多，如果你每年取出原始投资金额的4%，一直要到33年以后才会把钱取光。要是碰到大牛市，就可以撑更久。</p>\n\n<p>如果这条规则正确，那么可以推算，如果你每年的总支出为4万人民币，而你现在的证券投资有100万，那么你就可以退休了。如果每年支出40万，那么证券投资需要1000万。这些钱能够支撑30多年，中国人的平均寿命现在也就是70多岁。事实上，有一项研究专门验证这项规则，结果发现它（在美国）成立的概率是94%。</p>\n\n<p>7、</p>\n\n<p>当然，我不是说，你真的用这个规则，来安排自己的退休规划。尽管随着年龄变老，人的支出一般会越来越少，但是万一有突发事件（比如生了大病），恐怕马上就会耗尽存款。（不过，即使你没有退休，突发事件也有可能耗尽你的存款，你的生活保障并不会因为有没有正在上班，而有实质的不同。）</p>\n\n<p>我举这条规则的用意是，我想用它证明，只要管控好支出，提前退休在财务上是完全可行的。如果你很早就开始提前规划，可能性就会大大增加，如果你对自己的消费有严格的纪律，就完全有可能做到。</p>\n\n<p>普通人的生存正在变得越来越难，养老金和退休这样的字眼，正在离你越来越远，全世界皆是如此。你必须为自己早做打算，而在我看来，如果规划得当，你的人生至少可以不是那么悲惨，要熬到七十岁油干灯尽才能退休。</p>\n\n<p>（说明：本文收录在即将出版的<a href=\"http://www.ruanyifeng.com/survivor/\">《未来世界的幸存者》</a>一书之中。）</p>\n\n<p>（正文完）</p>\n\n<p>=========================================</p>\n\n<p>你最近有没有换工作的打算？下面向大家介绍一个国内著名的 IT 行业招聘网站：<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a>。</p>\n\n<p>优秀的人才不缺工作机会，只缺适合自己的好机会。但是他们往往没有精力，从海量机会中找到最适合的那个。<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 让您可以向数百家互联网企业，匿名展示简历和职业期望，省下查找职位和投递简历的时间。通过这种方式，对您感兴趣的企业，主动邀请您参加面试。</p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\"><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030806.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D01fcbcfdcf5889695623b23f2cd43b6c8cbd35da\" alt=\"\" title=\"\"></a></p>\n\n<p><a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">100offer</a> 的用户之中，既有厌倦了大公司螺丝钉般的重复工作，转而进入创业公司的前 BAT 员工；也有在小公司工作多年，一心想进入大公司的互联网人；还有向往国外的工作与生活，成功肉身翻墙新加坡的工程师。</p>\n\n<p>准备好用不一样的方式迎接更好的职业机会了吗？现在就<a href=\"https://cn.100offer.com/how-it-works/?utm_source=ruanyifeng&amp;utm_medium=display&amp;utm_campaign=ruanyifeng_20180307&amp;utm_content=find_new_job&amp;campaign_code=ruanyifeng\">提交申请</a>吧！</p>\n\n<p>关注 100offer 的公众号，了解更多资讯。</p>\n\n<p><img src=\"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030808.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3D1600ed69252681ee5b8828e6e69c3359562899f1\" alt=\"\" title=\"\"></p>\n\n<p>（完）</p>\n\n                                    <!-- /div -->\n\n                                ","author":"阮一峰","time":"2018-03-08T00:15:38.000Z","sourceType":"ryf","source":"http://www.ruanyifeng.com/blog/2018/03/retire-at-70.html","createTime":"2018-03-08T00:15:38.000Z","fmImg":"https://ycc-1256164624.cos.ap-beijing.myqcloud.com/ryf_bg2018030801.jpg?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDlLm23q0hlbCZjhywCE0Wnoa6uUs6oqQs%26q-sign-time%3D1521612644%3B1553148644%26q-key-time%3D1521612644%3B1553148644%26q-header-list%3D%26q-url-param-list%3D%26q-signature%3Dd6988d1648c21c3199c38b43b17cdea5e89e1045"}},
    '/book/getInfo':{"info":{"id":543,"name":"哑受","author":"三念","time":"2017-12-27T06:54:19.000Z","intro":"    他的名字叫小莫\n    他是个哑巴，他学习很棒，他会踢球，他会打架；\n    他还会弹钢琴、拉小提琴……\n    唯一有所欠缺的是：他不会说话\n    ……\n    和家把他捡回家，让他变成了普通人\n    《哑受》这本书讲述的是三对好基友的故事；\n    腹黑受小莫与单纯攻和平；两小无猜，青梅竹马；\n    苦难和一提与强势楚万成；曲折多变，苦尽甘来；\n    强受高秦涟与黑帮混小子赵本慈；一见钟情，欢喜冤家。\n","type":"二次元小说","state":0,"fmImg":"/static/img/book/552.png","clickHits":0,"zanHits":1},"list":[{"id":337768,"bookId":543,"name":"第一章：童年相遇上","url":"http://www.00ksw.org/html/0/552/220441.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":0},{"id":337769,"bookId":543,"name":"第二章：童年相遇下","url":"http://www.00ksw.org/html/0/552/220443.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":1},{"id":337770,"bookId":543,"name":"第三章：和平的身世上","url":"http://www.00ksw.org/html/0/552/220446.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":2},{"id":337771,"bookId":543,"name":"第四章：和平的身世下","url":"http://www.00ksw.org/html/0/552/220447.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":3},{"id":337772,"bookId":543,"name":"第五章：跟踪","url":"http://www.00ksw.org/html/0/552/220448.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":4},{"id":337773,"bookId":543,"name":"第六章：逃亡","url":"http://www.00ksw.org/html/0/552/220450.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":5},{"id":337774,"bookId":543,"name":"第七章：被劫","url":"http://www.00ksw.org/html/0/552/220453.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":6},{"id":337775,"bookId":543,"name":"第八章：获救","url":"http://www.00ksw.org/html/0/552/220454.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":7},{"id":337776,"bookId":543,"name":"第九章：能接下去吗？","url":"http://www.00ksw.org/html/0/552/220457.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":8},{"id":337777,"bookId":543,"name":"第十章：出国留学","url":"http://www.00ksw.org/html/0/552/220459.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":9},{"id":337778,"bookId":543,"name":"第十一章：无用功","url":"http://www.00ksw.org/html/0/552/220461.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":10},{"id":337779,"bookId":543,"name":"第十二章：矛盾","url":"http://www.00ksw.org/html/0/552/220462.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":11},{"id":337780,"bookId":543,"name":"第十三章：分离一","url":"http://www.00ksw.org/html/0/552/220464.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":12},{"id":337781,"bookId":543,"name":"第十四章：分离二","url":"http://www.00ksw.org/html/0/552/220466.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":13},{"id":337782,"bookId":543,"name":"第十五章：分离三","url":"http://www.00ksw.org/html/0/552/220468.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":14},{"id":337783,"bookId":543,"name":"第十六章：黑化","url":"http://www.00ksw.org/html/0/552/220469.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":15},{"id":337784,"bookId":543,"name":"第十七章：出事","url":"http://www.00ksw.org/html/0/552/220471.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":16},{"id":337785,"bookId":543,"name":"第十八章：闯入","url":"http://www.00ksw.org/html/0/552/220473.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":17},{"id":337786,"bookId":543,"name":"第十九章：你儿子是谁？","url":"http://www.00ksw.org/html/0/552/220475.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":18},{"id":337787,"bookId":543,"name":"第二十章：司徒清林","url":"http://www.00ksw.org/html/0/552/220476.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":19},{"id":337788,"bookId":543,"name":"第二十一章：犹豫","url":"http://www.00ksw.org/html/0/552/220479.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":20},{"id":337789,"bookId":543,"name":"第二十二章：司徒明生","url":"http://www.00ksw.org/html/0/552/220480.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":21},{"id":337790,"bookId":543,"name":"第二十三章：回忆","url":"http://www.00ksw.org/html/0/552/220482.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":22},{"id":337791,"bookId":543,"name":"第二十四章：前夕","url":"http://www.00ksw.org/html/0/552/220484.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":23},{"id":337792,"bookId":543,"name":"第二十五章：明基和明生","url":"http://www.00ksw.org/html/0/552/220487.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":24},{"id":337793,"bookId":543,"name":"第二十六章：约会","url":"http://www.00ksw.org/html/0/552/220489.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":25},{"id":337794,"bookId":543,"name":"第二十七章：离别","url":"http://www.00ksw.org/html/0/552/220490.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":26},{"id":337795,"bookId":543,"name":"第二十八章：两年后","url":"http://www.00ksw.org/html/0/552/220492.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":27},{"id":337796,"bookId":543,"name":"第二十九章：相同之人","url":"http://www.00ksw.org/html/0/552/220494.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":28},{"id":337797,"bookId":543,"name":"第三十章：酒丸子","url":"http://www.00ksw.org/html/0/552/220496.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":29},{"id":337798,"bookId":543,"name":"第三十一章：笨蛋","url":"http://www.00ksw.org/html/0/552/220498.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":30},{"id":337799,"bookId":543,"name":"第三十二章：催青","url":"http://www.00ksw.org/html/0/552/220500.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":31},{"id":337800,"bookId":543,"name":"第三十三章：眉目","url":"http://www.00ksw.org/html/0/552/220502.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":32},{"id":337801,"bookId":543,"name":"第三十四章：阴谋","url":"http://www.00ksw.org/html/0/552/220504.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":33},{"id":337802,"bookId":543,"name":"第三十五章：信息","url":"http://www.00ksw.org/html/0/552/220506.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":34},{"id":337803,"bookId":543,"name":"第三十六章：突然的告白","url":"http://www.00ksw.org/html/0/552/220508.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":35},{"id":337804,"bookId":543,"name":"第三十七章：刀子","url":"http://www.00ksw.org/html/0/552/220510.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":36},{"id":337805,"bookId":543,"name":"第三十八掌：不安","url":"http://www.00ksw.org/html/0/552/220512.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":37},{"id":337806,"bookId":543,"name":"第三十九章：劫持","url":"http://www.00ksw.org/html/0/552/220514.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":38},{"id":337807,"bookId":543,"name":"第四十章：失踪的小莫","url":"http://www.00ksw.org/html/0/552/220516.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":39},{"id":337808,"bookId":543,"name":"第四十一章：他算什么？","url":"http://www.00ksw.org/html/0/552/220518.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":40},{"id":337809,"bookId":543,"name":"第四十二章：小莫的身世","url":"http://www.00ksw.org/html/0/552/220519.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":41},{"id":337810,"bookId":543,"name":"第四十三章：请你相信他","url":"http://www.00ksw.org/html/0/552/220521.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":42},{"id":337811,"bookId":543,"name":"第四十四章：魅影","url":"http://www.00ksw.org/html/0/552/220523.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":43},{"id":337812,"bookId":543,"name":"和父篇01","url":"http://www.00ksw.org/html/0/552/220525.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":44},{"id":337813,"bookId":543,"name":"和父篇02","url":"http://www.00ksw.org/html/0/552/220528.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":45},{"id":337814,"bookId":543,"name":"和父篇03","url":"http://www.00ksw.org/html/0/552/220530.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":46},{"id":337815,"bookId":543,"name":"赵高篇01","url":"http://www.00ksw.org/html/0/552/220532.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":47},{"id":337816,"bookId":543,"name":"赵高篇02","url":"http://www.00ksw.org/html/0/552/220534.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":48}]},
    '/book/chapter':{"id":337769,"bookId":543,"name":"第二章：童年相遇下","url":"http://www.00ksw.org/html/0/552/220443.html","time":"2017-12-27T06:54:19.000Z","chapterIndex":1,"nextChapterId":337770,"prevChapterId":337768,"text":"    兄弟篇    第二章：童年相遇下[1/1页]    第二章：童年相遇下晚上，和平躺在床上转转反侧，睡不着觉，他今天第一次看到小莫露出那种表情，显得烦躁不安，到很晚才睡着。    早上和平睁开眼睛，一张大脸印入眼帘，水灵灵的大眼睛直直地盯着他看。    和平被吓了一跳，往另外一侧逃跑，理所当然地摔在地上，发出咚的一声。    爬起来看小莫站在床边的另一侧才松了一口气。    “啊，原来是小莫！吓死我了，我还以为是谁呢！”    小莫低下头，可怜巴巴地盯着他，看得和平心里七上八下。    “我，我没有怪你的意思，只是你醒了为什么不叫我？”    两人约好一起去晨练，现在都已经7:30，父亲也没有来叫他们。    小莫的表情有些变动，好像在诉说着什么，看得和平脸一红心一跳。    居然是小莫阻止父亲叫他起床，他就在一旁看他的睡觉，和平感觉好微秒，好羞羞！    “好了好了，我们出去吃早餐吧！今天是开学典礼，晚一点到也没关系”    和平急忙拉着小莫的手走出客厅，背对着他，不想让小莫看到他现在怪异的表情。    “爸爸，我饿了。”    和一提正在看着报纸，三个月前，当今少有的贵族家族——司徒家失火，死伤人数m名，失踪人口n名。    “已经在餐桌上了，自己吃吧！小莫今天要上学了，有没有什么要准备的吗？”    小莫摇了摇头，他眼角瞥见和一提摊开在腿上的报纸，大大的封面诉说着一则失火事件，没有多加在意，回过头来继续喝粥。    司徒贵族，在现代来说已经是非常稀有，可是对于和一提来说贵族什么的都是浮云，有传言司徒一族因为争夺主人位子而不断斗争，报纸上也经常说。    “怎么，小莫你也看报纸？”    小莫点点头：我看，但是也不太常看。    和家父子二人已经可以看懂小莫的语言，做到心照不宣，他们能从小莫的表情中找出他想要传达的信息。    “还这么小就能看的懂吗？”    嗯。    小莫的回答让和一提怀疑起来，他以前都生活在什么样的地方？    “小莫，来，这个给你！爸爸做的小笼包很好吃哦！我最喜欢吃爸爸做的小笼包了。”    和平将自己笼子里的小笼包多夹了几个给小莫，小莫则将自己碗里的煎蛋给了和平。    “嗯，煎蛋也好吃。”    看着两人像兄弟一样相处得这么融洽，和一提宽慰地笑了笑，他一向很注重营养，一定要把儿子们养成一个个健健康康的身体。    “既然这样，吃完早饭就上学去吧！”    小莫长得很可爱，在学校很快就出名了。    小莫学习成绩很好，很受欢迎。    小莫足球学得很好，和平邀请他一起去参加比赛，小莫拒绝了。    小莫还会弹钢琴，会拉小提琴，会西式剑法，日本刀法，还能长跑20多公里。    和平每天跟着他一起晨练，每次都累的气喘。    总而言之，小莫什么都会的感觉，除了不会说话，其余堪称完美。    和平很高兴小莫可以跟班上的人打成一片，但是他被大家围着占用了很多时间，所以他和小莫单独相处的时间越来越少，和平很烦躁！    小莫的视野渐渐扩大，和平的心情却越来越沉重，这样小莫就不会只是注视他一个人了。    夜晚，吃饭的时候。    和平的笑脸慢慢阴沉起来，和一提有些担心，问他：“和平，你最近怎么呢？很没精神的样子。”    “没事！”和平的脾气很冲，他也不知道为什么，就是很生气。    “没事你乱发什么脾气？”    和平看着小莫，小莫也看着他，和平想到这双充满灵气的眼睛很快就要转向他人，心情更加不好：“小莫你这个笨蛋，我，我最讨厌你了！”    小莫颤抖了一下，呆呆地望着和平，眼睛里满是不可思议的恐慌！    和平大惊，他怎么会说出这种话？为什么要生小莫的气？不知道该怎么解释，他立刻跑进房间，和一提追了过去。    将门锁上，和一提正义言辞道：“你在干什么，小莫做了什么，你要说这么重的话。”    “没什么！”    “没什么？那你立刻向小莫道歉！”    “我不要，他就只在乎别人，越来越不在乎我了。”    和一提惊愣了一秒，和平居然会有这种想法。    “所以，你因为这种事情就把气出在小莫身上吗？爸爸绝对不会允许你这么做，赶紧收拾好心情，出去跟小莫道歉！既然害怕小莫离开你，你就应该看好他，而不是像刚才那样乱发脾气！”    是这样吗？原来他害怕失去小莫，讨厌那些人一直盯着小莫看，总觉的很恶心，可是小莫还理所当然地跟他们一起玩，难道他这是在嫉妒？他怎么可以这么糟糕？    “对，对不起！”    “知道了就好，一餐好好的晚饭都被你搅得一团糟，快擦干眼泪吧，可别让小莫看见你现在这幅委屈的样子。”    “嗯！”    和平一向听话，虽然调皮了点，可是骨子里还是畏惧着父亲会突然惩罚他，因为父亲的惩罚很吓人，拿着两把手术刀准备解剖的摸样。    两人收拾了一下，走了出来，可是餐桌上的小莫已经不见了踪影。    “爸爸，小莫呢？”    和平有不好的预感，急忙四处寻找小莫的踪影。    卧室，厨房，洗手间，衣柜……    翻箱倒柜，该找的地方都找了，就是没有看见小莫的踪影。    和平不得不意识到一件事情：小莫失踪了！    “爸爸，怎么办？小莫不见了！”    和一提拍拍和平的头，“冷静下来，他可能是出去了，时间这么短，应该没有走远，我们出去找找看。”    和平点点头，急忙跑出家里。    和一提锁上门，两人分头行动。    “小莫，小莫，你在哪里？小莫！”和平沿着街道一直跑一直喊，就算喉咙沙哑了，干涸了，他还是没有停下来。    他一路跑到学校，也没有看见小莫的身影。    小莫到底跑到哪儿去了？他很后悔说出了那句话，和平怎么会讨厌小莫呢？他可是非常喜欢小莫的。    “小莫，你在哪里？出来一下好不好？我不会在骂你了。你出来吧！小莫~~”    和平伤心地蹲在地上，他还漏掉了什么地方，完全回忆不起来，他不知道没有了小莫的日子该怎么办？直到小莫消失他才意识到，他已经离不开他了。    小莫到底会到哪里去？和平努力地回想他这几天和小莫经常呆在一起的地方，对了，就在公园附近，他忘记去找了。    而且，每天早晨也是围着公园跑好几圈，他们在一起的地方离不开公园。他怎么会忘记了那么重要的地方呢？    和平即刻起身，往公园的方向跑去。    跑到公园的时候，走路到他们经常踢足球的地方，他已经感觉到小莫就在那里，他看到父亲和小莫坐在木马上，和平喘着气跑了过来。    来不及道歉，他拥抱着小莫，还好小莫没有消失，幸好他还在，泪水止不住地流了出来。    “小莫，对不起，我不讨厌你，我很喜欢你！”    小莫无法说话，眼泪也像是喷泉涌了出来。    他脸上的表情明显地说着：不要丢下我一个人！    “是我该死，是我不对，我不应该干涉你交朋友，都怪我胡乱吃醋，对不起，小莫，留下来！”    他已经不敢想象小莫不在的日子，想到小莫消失的那一刻，仿佛失去了整个世界。    小莫犹豫了一阵，最终还是点了点头。    和一提终于放心地笑了，“看，我不是说了吗？和平是离不开你的，又怎么会不要你呢？好了，小莫，以后也请你好好呆在和平身边好吗？”    嗯。    和一提蹲下身，环抱着两个娇小的身体：“从今往后，我们就一起生活了！”    他多了一个儿子，从此和平就不会再感到寂寞了！小莫是个好孩子，一定要好好照顾他，治愈他的心灵。    “嗯，小莫，我们回家！”    和平拉着小莫熟悉的小手往前走。    小莫笑着点了点头，这是他和他们遇见后第一次开口微笑，和平怎么也忘不了那让他心跳不止的笑脸；他决定这一辈子都要让小莫露出这样的笑脸，不再让他哭泣。    没错，他们从今往后要一起生活，再也不分离。    小小的愿望隐藏在小莫的心中，生根发芽。"},
    '/getWorksList':{"total":6,"list":[{"id":5,"name":"页面优选","intro":"- -","fmImg":null,"clickHits":0,"zanHits":0,"time":"2018-04-02 10:56:40","url":"/static/works/pages/index.html"},{"id":4,"name":"截图","intro":"根据现有图片截取图片","fmImg":null,"clickHits":0,"zanHits":0,"time":"2018-04-02 10:56:38","url":"/static/works/cut/index.html"},{"id":3,"name":"五子棋","intro":"跟电脑玩五子棋","fmImg":null,"clickHits":0,"zanHits":0,"time":"2018-04-02 10:56:35","url":"/static/works/wuziqi/index.html"},{"id":2,"name":"聊天室","intro":"多人聊天（由于根据cookie识别帐号，请在不同的浏览器测试）","fmImg":null,"clickHits":0,"zanHits":0,"time":"2018-04-02 10:56:31","url":"/static/works/chat/login.html"},{"id":1,"name":"2048","intro":"2048小游戏","fmImg":"","clickHits":0,"zanHits":0,"time":"2018-04-02 10:56:28","url":"/static/works/2048/index.html"},{"id":6,"name":"\"ddd","intro":"\"ddd","fmImg":null,"clickHits":null,"zanHits":null,"time":null,"url":null},{"id":7,"name":"俄罗斯方块","intro":"俄罗斯方块","fmImg":null,"clickHits":null,"zanHits":null,"time":"2018-04-02 10:56:28","url":"/static/works/elsfk/index.html"}]}
};